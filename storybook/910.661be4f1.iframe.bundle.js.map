{"version":3,"file":"910.661be4f1.iframe.bundle.js","mappings":";;;;;;;;;;;;;AAqKA;;;;;;;AAaA;;AAGA;;;AC22BA;AAEA;;;;;;AAMA;AAEA;;;;;;AA4EA;;;;;AAyGA;AACA;;AAQA;;;ACl3BA;;;;AAIA;AACA;;AAGA;AAsMA;AAEA;AAoIA;AAEA;;;;;;AAwLA;;;;;;AAkBA;AAWA;;;;;AAKA;AAEA;;;AAMA;;;;;AAiDA;AA2CA;;;;;;;AAOA;AACA;;;;;;;AAOA;;;;;;;;;;;;;AAaA;;;;;AAMA;AA4RA;AACA;AAEA;;;;;AA2NA;AACA;AAEA;;;;;AA0KA;AACA;AAQA;;;AA6BA;;;AAMA;AAqCA;;AAGA;;AAudA;AACA;AAEA;;;;;;AC3gEA;AAIA;AAIA;;AAaA;AACA;;AAQA;;;;;;;;;AAWA;;AAEA;;;;AAaA;;;;AAKA;;AAg0DA;ACvBA;AACA;AACA;;AAGA;AAKA;;AAEA;AAEA;AAEA;;;;AAMA;;;;;AAYA;;;;;;;AAWA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAuGA;AAmBA;;;;;;AAMA;;AAMA;;;;AA6SA;;;;;;;AAwDA;AAKA;;;;;;;AAiBA;AACA;AAMA;;;AASA;;;;;AAeA;AAIA;;;AAgEA;;;;;;;;AAQA;;;;;AASA;;AAGA;;AAGA;;;AAuNA;AACA;;AAGA;AAkBA;;;;;;;;AAeA;AA0BA;;;AAMA;;;;AAQA;;;;;;;AA+DA;AAKA;;;;;;;;AA0CA;AAIA;AACA;;;;;AAKA;;AAMA;;;;;AA0BA;AACA;AAEA;;;AA2EA;;;;;AAQA;AACA;AACA;;;;AAKA;;;;;;AAwDA;AAGA;AAEA;;;;;;;AAsBA;AACA;AAIA;;;AAsVA;AAEA;;;;;AASA;;;;;;;AAmOA;AAs1HA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AA6DA;;AAEA;;;;AAKA;;;;;ACjnPA;AAEA;;AAGA;;;;;;;;AA0DA;AACA;AACA;;;;;;AAOA;AAwNA;AACA;;;;;AAJA;AACA;;AAWA;;;AASA;AAEA;AACA;AAxBA;;;;AAAA;;AACA;;AAgCA;;;;;;;;AAcA;;;AAGA;;;AAIA;AAuCA;;;;;;;;;AASA;;AASA;AACA;;;;;;;;;;AAUA;;;;;;;AAaA;AACA;;;;;AAMA;;;AA9IA;;AA4RA;;;;;AAMA;;AAsBA;;AAGA;;;AA3TA;;AAiUA;;;AA8FA;;;;;;;;;;;;;;;AAqBA;;AAWA;;;;;AA0TA;;;AAMA;AAIA;;;AAMA;;;;;AAWA;;AAEA;;;AAIA;;;;AA+UA;;AAEA;AAEA;;;;AAKA;;;AAIA;;;;AAKA;;;;;AAMA;;;AAIA;;AAEA;;;AAOA;;;AAkBA;;;;AAMA;;;;AAQA;;;;AAoUA;AACA;AACA;;AAEA;AACA;;AAGA;;;AAMA;;;;AAMA;AACA;AACA;;AAGA;;;;AAOA;AAKA;;;;AAOA;;AAIA;;;AAMA;AAIA;;;AAGA;AACA;;;AAGA;AACA;AACA;;AAGA;;;;AAoGA;;;AAuIA;;AA+VA;;;;;;;;AAWA;AAEA;;;;;;;;AAQA;AAKA;;;;;AAoJA;AACA;;AAQA;;;;;AASA;;AAWA;;;;AAoCA;;;AAgBA;;;;AAKA;;AAeA;;AAGA;;;AAx5EA;;AA85EA;;;AA95EA;;AAm6EA;;;;;AAMA;;;;;;;AA4IA;;AAGA;;AAEA;;AAGA;;;;;AAKA;AAEA;;;;;;;AAOA;;;AAGA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAyDA;;;;;;;AAwOA;;AAGA;;AAEA;;AAGA;;;;;AAKA;AAkDA;AAgOA;AACA;AAOA;AAOA;AAEA;;;AAuPA;;;;AAOA;;;;;;;AASA;AACA;AAIA;;AAGA;;;;;AAMA;;;AAKA;AACA;;;;;;;;AASA;;;;;;AAgBA;;AAQA;;AAQA;;;AAMA;;;;AAOA;;AAQA;AAEA;AACA;AACA;;;AAIA;;;;AAoBA;;;;AA+CA;AAGA;AACA;;;;;;;AAOA;AACA;;;;;;AAMA;AACA;;AAEA;AACA;AA6BA;;AAiEA;;AAGA;;;;;;;;;;;;;AA4MA;;;AAGA;AACA;;AAEA;AAYA;;;AAKA;;AAEA;;;;;AAQA;AACA;;AAeA;AAFA;AAKA;AAcA;AAEA;AACA;AACA;AAEA;;AAEA;;AAKA;AAQA;;;;;;AAwHA;;;;;;AAmHA;;AAMA;;AAGA;AA+DA;AAKA;;;;;AAKA;AAmBA;;;;AAIA;;;;AAYA;AACA;AAKA;;;AAjBA;;;;AA0BA;AACA;AAIA;;AAQA;AAEA;AAGA;AACA;;;AAGA;;AAGA;;AAKA;AAkCA;;;;;;;;AAYA;;;;;;;;AAQA;;AAGA;AAqPA;;;;;;AAOA;AAGA;;;;;AAYA;;;AAIA;AAOA;;AAEA;;AAGA;;;;;AAqIA;;;;;;AA4DA;AACA;AACA;AACA;AAEA;;AAGA;AAoBA;AACA;AAEA;;;;;;AAmGA;AACA;AAIA;ACx8KA;AAMA;AAiBA;AC3GA;AACA;AACA","sources":["webpack://@splunk/ucc_ui_lib/./node_modules/@splunk/dashboard-action-buttons/index.js","webpack://@splunk/ucc_ui_lib/./node_modules/@splunk/dashboard-context/dist/index.js","webpack://@splunk/ucc_ui_lib/./node_modules/@splunk/dashboard-core/index.js","webpack://@splunk/ucc_ui_lib/./node_modules/@splunk/dashboard-inputs/index.js","webpack://@splunk/ucc_ui_lib/./node_modules/@splunk/dashboard-layouts/index.js","webpack://@splunk/ucc_ui_lib/./node_modules/@splunk/dashboard-ui/index.js","webpack://@splunk/ucc_ui_lib/./node_modules/ajv/dist/compile/validate/dataType.js","webpack://@splunk/ucc_ui_lib/./node_modules/ajv/dist/vocabularies/applicator/dependencies.js"],"sourcesContent":["/* Copyright © 2020 Splunk Inc.\nSPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or\nin part without a valid written license from Splunk Inc. is PROHIBITED. */\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  ActionButton: () => ActionButton_default,\n  CloneButton: () => CloneButton_default,\n  DeleteButton: () => DeleteButton_default,\n  ExportButton: () => ExportButton_default,\n  FullscreenButton: () => FullscreenButton_default,\n  LayerButton: () => LayerButton_default,\n  MoveButton: () => MoveButton_default,\n  OpenSearchButton: () => OpenSearchButton_default,\n  PauseResumeButton: () => PauseResumeButton_default,\n  RefreshButton: () => RefreshButton_default\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// esm-externals:react\nvar react_exports = {};\n__export(react_exports, {\n  default: () => react_default\n});\nvar defaultImport = __toESM(require(\"react\"));\n__reExport(react_exports, require(\"react\"));\nvar react_default = \"default\" in defaultImport ? defaultImport.default : defaultImport;\n\n// esm-externals:styled-components\nvar styled_components_exports = {};\n__export(styled_components_exports, {\n  default: () => styled_components_default\n});\nvar defaultImport2 = __toESM(require(\"styled-components\"));\n__reExport(styled_components_exports, require(\"styled-components\"));\nvar styled_components_default = \"default\" in defaultImport2 ? defaultImport2.default : defaultImport2;\n\n// esm-externals:@splunk/themes\nvar themes_exports = {};\n__export(themes_exports, {\n  default: () => themes_default\n});\nvar defaultImport3 = __toESM(require(\"@splunk/themes\"));\n__reExport(themes_exports, require(\"@splunk/themes\"));\nvar themes_default = \"default\" in defaultImport3 ? defaultImport3.default : defaultImport3;\n\n// esm-externals:@splunk/react-ui/Clickable\nvar Clickable_exports = {};\n__export(Clickable_exports, {\n  default: () => Clickable_default\n});\nvar defaultImport4 = __toESM(require(\"@splunk/react-ui/Clickable\"));\n__reExport(Clickable_exports, require(\"@splunk/react-ui/Clickable\"));\nvar Clickable_default = \"default\" in defaultImport4 ? defaultImport4.default : defaultImport4;\n\n// esm-externals:prop-types\nvar prop_types_exports = {};\n__export(prop_types_exports, {\n  default: () => prop_types_default\n});\nvar defaultImport5 = __toESM(require(\"prop-types\"));\n__reExport(prop_types_exports, require(\"prop-types\"));\nvar prop_types_default = \"default\" in defaultImport5 ? defaultImport5.default : defaultImport5;\n\n// src/ActionItem.tsx\nvar handleMouseDown = (e) => {\n  e.stopPropagation();\n};\nvar handleMouseMove = (e) => {\n  e.stopPropagation();\n};\nvar handleMouseUp = (e) => {\n  e.stopPropagation();\n};\nvar ActionItem = (_a) => {\n  var _b = _a, { children } = _b, rest = __objRest(_b, [\"children\"]);\n  return /* @__PURE__ */ react_default.createElement(\n    \"div\",\n    __spreadValues({\n      \"data-test\": \"action-item\",\n      role: \"presentation\",\n      onMouseDown: handleMouseDown,\n      onMouseMove: handleMouseMove,\n      onMouseUp: handleMouseUp\n    }, rest),\n    children\n  );\n};\nActionItem.propTypes = {\n  children: prop_types_default.any\n};\nvar ActionItem_default = ActionItem;\n\n// src/ActionButton.tsx\nvar Button = styled_components_default(Clickable_default)`\n    width: 28px;\n    height: 28px;\n    cursor: pointer;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    &[data-disabled='true'] {\n        cursor: not-allowed;\n    }\n\n    &:hover {\n        background-color: ${(0, themes_exports.pick)({\n  enterprise: {\n    light: themes_exports.variables.gray92,\n    dark: themes_exports.variables.gray30\n  },\n  prisma: themes_exports.variables.interactiveColorOverlayHover\n})};\n    }\n\n    &:focus {\n        outline-style: solid;\n        outline-offset: 1px;\n        outline-width: 2px;\n        outline-color: ${themes_exports.variables.focusColor};\n    }\n`;\nvar noop = () => void 0;\nvar ActionButton = react_default.forwardRef(\n  (_a, ref) => {\n    var _b = _a, { icon: icon2, onClick = noop, disabled = false } = _b, rest = __objRest(_b, [\"icon\", \"onClick\", \"disabled\"]);\n    return /* @__PURE__ */ react_default.createElement(ActionItem_default, null, /* @__PURE__ */ react_default.createElement(\n      Button,\n      __spreadValues({\n        disabled: !!disabled,\n        onClick,\n        \"data-disabled\": !!disabled,\n        \"data-clickable\": true,\n        tabIndex: 0,\n        elementRef: ref\n      }, rest),\n      react_default.cloneElement(icon2, { size: \"18px\" })\n    ));\n  }\n);\nvar ActionButton_default = ActionButton;\n\n// esm-externals:@splunk/ui-utils/i18n\nvar i18n_exports = {};\n__export(i18n_exports, {\n  default: () => i18n_default\n});\nvar defaultImport6 = __toESM(require(\"@splunk/ui-utils/i18n\"));\n__reExport(i18n_exports, require(\"@splunk/ui-utils/i18n\"));\nvar i18n_default = \"default\" in defaultImport6 ? defaultImport6.default : defaultImport6;\n\n// esm-externals:@splunk/dashboard-ui\nvar dashboard_ui_exports = {};\n__export(dashboard_ui_exports, {\n  default: () => dashboard_ui_default\n});\nvar defaultImport7 = __toESM(require(\"@splunk/dashboard-ui\"));\n__reExport(dashboard_ui_exports, require(\"@splunk/dashboard-ui\"));\nvar dashboard_ui_default = \"default\" in defaultImport7 ? defaultImport7.default : defaultImport7;\n\n// esm-externals:@splunk/dashboard-telemetry\nvar dashboard_telemetry_exports = {};\n__export(dashboard_telemetry_exports, {\n  default: () => dashboard_telemetry_default\n});\nvar defaultImport8 = __toESM(require(\"@splunk/dashboard-telemetry\"));\n__reExport(dashboard_telemetry_exports, require(\"@splunk/dashboard-telemetry\"));\nvar dashboard_telemetry_default = \"default\" in defaultImport8 ? defaultImport8.default : defaultImport8;\n\n// esm-externals:@splunk/dashboard-icons\nvar dashboard_icons_exports = {};\n__export(dashboard_icons_exports, {\n  default: () => dashboard_icons_default\n});\nvar defaultImport9 = __toESM(require(\"@splunk/dashboard-icons\"));\n__reExport(dashboard_icons_exports, require(\"@splunk/dashboard-icons\"));\nvar dashboard_icons_default = \"default\" in defaultImport9 ? defaultImport9.default : defaultImport9;\n\n// src/CloneButton.tsx\nvar CloneButton = ({\n  itemId,\n  dashboardApi,\n  screenReaderText\n}) => {\n  const telemetry = (0, react_exports.useContext)(dashboard_telemetry_exports.TelemetryContext);\n  const handleOnClick = (0, react_exports.useCallback)(\n    (toLayout) => {\n      telemetry.collect({\n        source: \"actionMenu\",\n        event: \"paste\"\n      });\n      dashboardApi == null ? void 0 : dashboardApi.cloneDashboardItems({\n        itemIds: [itemId],\n        offsetMultiplier: 1,\n        toLayoutId: toLayout\n      });\n    },\n    [dashboardApi, telemetry, itemId]\n  );\n  const icon2 = (0, react_exports.useMemo)(\n    () => /* @__PURE__ */ react_default.createElement(dashboard_icons_exports.Clone, { screenReaderText: screenReaderText || (0, i18n_exports._)(\"Clone\") }),\n    [screenReaderText]\n  );\n  const { open, handleOpen, handleRequestClose, anchor, setRef } = (0, dashboard_ui_exports.useTabListMenu)();\n  if (itemId == null || dashboardApi == null) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(react_default.Fragment, null, /* @__PURE__ */ react_default.createElement(\n    ActionButton_default,\n    {\n      \"data-test\": \"clone-button\",\n      onClick: handleOpen,\n      icon: icon2,\n      ref: setRef\n    }\n  ), /* @__PURE__ */ react_default.createElement(\n    dashboard_ui_exports.TabListMenu,\n    {\n      open,\n      anchor,\n      onRequestClose: handleRequestClose,\n      onSelectTab: handleOnClick,\n      heading: `${(0, i18n_exports._)(\"Clone to\")}...`,\n      showActiveTab: true\n    }\n  ));\n};\nvar CloneButton_default = CloneButton;\n\n// esm-externals:@splunk/dashboard-state\nvar dashboard_state_exports = {};\n__export(dashboard_state_exports, {\n  default: () => dashboard_state_default\n});\nvar defaultImport10 = __toESM(require(\"@splunk/dashboard-state\"));\n__reExport(dashboard_state_exports, require(\"@splunk/dashboard-state\"));\nvar dashboard_state_default = \"default\" in defaultImport10 ? defaultImport10.default : defaultImport10;\n\n// esm-externals:@splunk/react-icons/ArrowSquareRight\nvar ArrowSquareRight_exports = {};\n__export(ArrowSquareRight_exports, {\n  default: () => ArrowSquareRight_default\n});\nvar defaultImport11 = __toESM(require(\"@splunk/react-icons/ArrowSquareRight\"));\n__reExport(ArrowSquareRight_exports, require(\"@splunk/react-icons/ArrowSquareRight\"));\nvar ArrowSquareRight_default = \"default\" in defaultImport11 ? defaultImport11.default : defaultImport11;\n\n// src/MoveButton.tsx\nvar icon = /* @__PURE__ */ react_default.createElement(ArrowSquareRight_default, { variant: \"filled\" });\nvar MoveButton = ({\n  itemId,\n  dashboardApi\n}) => {\n  const telemetry = (0, react_exports.useContext)(dashboard_telemetry_exports.TelemetryContext);\n  const tabs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectTabs);\n  const handleOnClick = (0, react_exports.useCallback)(\n    (toLayout) => {\n      telemetry.collect({\n        source: \"actionMenu\",\n        event: \"move\"\n      });\n      dashboardApi == null ? void 0 : dashboardApi.moveDashboardItemsToLayout({\n        itemIds: [itemId],\n        toLayoutId: toLayout\n      });\n    },\n    [dashboardApi, telemetry, itemId]\n  );\n  const { open, handleOpen, handleRequestClose, anchor, setRef } = (0, dashboard_ui_exports.useTabListMenu)();\n  if (!itemId || !dashboardApi || tabs.length < 2) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(react_default.Fragment, null, /* @__PURE__ */ react_default.createElement(\n    ActionButton_default,\n    {\n      \"data-test\": \"move-button\",\n      onClick: handleOpen,\n      icon,\n      ref: setRef,\n      title: (0, i18n_exports._)(\"Move\")\n    }\n  ), /* @__PURE__ */ react_default.createElement(\n    dashboard_ui_exports.TabListMenu,\n    {\n      open,\n      anchor,\n      onRequestClose: handleRequestClose,\n      onSelectTab: handleOnClick,\n      heading: `${(0, i18n_exports._)(\"Move to\")}...`\n    }\n  ));\n};\nvar MoveButton_default = MoveButton;\n\n// src/DeleteButton.tsx\nvar DeleteButton = ({\n  itemId,\n  dashboardApi,\n  screenReaderText\n}) => {\n  const telemetry = (0, react_exports.useContext)(dashboard_telemetry_exports.TelemetryContext);\n  const handleOnClick = (0, react_exports.useCallback)(() => {\n    if (!itemId || !dashboardApi) {\n      return;\n    }\n    telemetry.collect({\n      source: \"actionMenu\",\n      event: \"delete\"\n    });\n    dashboardApi.removeDashboardItemsWithPrompt([itemId]);\n  }, [telemetry, dashboardApi, itemId]);\n  if (itemId == null || dashboardApi == null) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(\n    ActionButton_default,\n    {\n      \"data-test\": \"delete-button\",\n      onClick: handleOnClick,\n      icon: /* @__PURE__ */ react_default.createElement(dashboard_icons_exports.Remove, { screenReaderText: screenReaderText || (0, i18n_exports._)(\"Delete\") })\n    }\n  );\n};\nvar DeleteButton_default = DeleteButton;\n\n// esm-externals:@splunk/dashboard-utils\nvar dashboard_utils_exports = {};\n__export(dashboard_utils_exports, {\n  default: () => dashboard_utils_default\n});\nvar defaultImport12 = __toESM(require(\"@splunk/dashboard-utils\"));\n__reExport(dashboard_utils_exports, require(\"@splunk/dashboard-utils\"));\nvar dashboard_utils_default = \"default\" in defaultImport12 ? defaultImport12.default : defaultImport12;\n\n// src/utils/displayUtils.ts\nvar RENDER_ACTION_BUTTON_DENYLIST = [\n  \"viz.rectangle\",\n  \"splunk.rectangle\",\n  \"viz.ellipse\",\n  \"splunk.ellipse\",\n  \"viz.text\",\n  \"viz.markdown\",\n  \"splunk.markdown\"\n];\n\n// src/ExportButton.tsx\nvar ExportButton = ({\n  dashboardApi,\n  screenReaderText = (0, i18n_exports._)(\"Export\"),\n  itemDefinition,\n  itemId,\n  createToast\n}) => {\n  const telemetry = (0, dashboard_telemetry_exports.useTelemetryApi)();\n  const [open, setOpen] = (0, react_exports.useState)(false);\n  const handleModalClose = (0, react_exports.useCallback)(() => setOpen(false), []);\n  (0, react_exports.useEffect)(() => {\n    if (createToast) {\n      (0, dashboard_utils_exports.deprecated)(\n        \"The createToast prop for generating user messages is deprecated. The userMessage API is preferred and will be used when createToast is not provided.\"\n      );\n    }\n  }, [createToast]);\n  const handleOnClick = (0, react_exports.useCallback)(() => {\n    telemetry.emit({\n      pageAction: \"udf.export_viz\",\n      source: \"actionMenu\",\n      event: \"viz.export_open_modal\",\n      metadata: { type: itemDefinition == null ? void 0 : itemDefinition.type }\n    });\n    setOpen(true);\n  }, [itemDefinition, telemetry]);\n  const isValidExportButton = itemDefinition && dashboardApi && itemId && !RENDER_ACTION_BUTTON_DENYLIST.includes(itemDefinition.type);\n  if (!isValidExportButton) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(react_default.Fragment, null, /* @__PURE__ */ react_default.createElement(\n    ActionButton_default,\n    {\n      \"data-test\": \"export-button\",\n      onClick: handleOnClick,\n      icon: /* @__PURE__ */ react_default.createElement(dashboard_icons_exports.DownloadSolid, { screenReaderText })\n    }\n  ), /* @__PURE__ */ react_default.createElement(\n    dashboard_ui_exports.ExportVisualizationModal,\n    {\n      open,\n      onModalClose: handleModalClose,\n      itemDefinition,\n      dashboardApi,\n      itemId,\n      createToast\n    }\n  ));\n};\nvar ExportButton_default = ExportButton;\n\n// src/FullscreenButton.tsx\nvar FullscreenButton = ({\n  itemId,\n  itemDefinition,\n  dashboardApi,\n  screenReaderText\n}) => {\n  const telemetry = (0, react_exports.useContext)(dashboard_telemetry_exports.TelemetryContext);\n  const type = (itemDefinition == null ? void 0 : itemDefinition.type) || null;\n  const handleOnClick = (0, react_exports.useCallback)(() => {\n    telemetry.emit({\n      pageAction: \"udf.fullscreen\",\n      source: \"actionMenu\",\n      event: \"viz.fullscreen\",\n      metadata: { type }\n    });\n    dashboardApi == null ? void 0 : dashboardApi.toggleVisualizationFullscreen(itemId);\n  }, [dashboardApi, telemetry, itemId, type]);\n  if (itemId == null || dashboardApi == null || type === null || RENDER_ACTION_BUTTON_DENYLIST.includes(type)) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(\n    ActionButton_default,\n    {\n      \"data-test\": \"fullscreen-button\",\n      onClick: handleOnClick,\n      icon: /* @__PURE__ */ react_default.createElement(\n        dashboard_icons_exports.Fullscreen,\n        {\n          screenReaderText: screenReaderText || (0, i18n_exports._)(\"Fullscreen\")\n        }\n      )\n    }\n  );\n};\nvar FullscreenButton_default = FullscreenButton;\n\n// esm-externals:@splunk/react-ui/Popover\nvar Popover_exports = {};\n__export(Popover_exports, {\n  default: () => Popover_default\n});\nvar defaultImport13 = __toESM(require(\"@splunk/react-ui/Popover\"));\n__reExport(Popover_exports, require(\"@splunk/react-ui/Popover\"));\nvar Popover_default = \"default\" in defaultImport13 ? defaultImport13.default : defaultImport13;\n\n// esm-externals:@splunk/react-ui/Menu\nvar Menu_exports = {};\n__export(Menu_exports, {\n  default: () => Menu_default\n});\nvar defaultImport14 = __toESM(require(\"@splunk/react-ui/Menu\"));\n__reExport(Menu_exports, require(\"@splunk/react-ui/Menu\"));\nvar Menu_default = \"default\" in defaultImport14 ? defaultImport14.default : defaultImport14;\n\n// src/LayerButton.tsx\nvar menuStyle = { width: 130 };\nvar LayerMenu = ({\n  open,\n  itemIdx,\n  adjustOrder,\n  front,\n  onRequestClose,\n  anchor\n}) => {\n  const handleForwardClick = (0, react_exports.useCallback)(\n    () => adjustOrder({\n      from: itemIdx,\n      to: itemIdx + 1,\n      event: \"layer-forward\"\n    }),\n    [adjustOrder, itemIdx]\n  );\n  const handleFrontClick = (0, react_exports.useCallback)(\n    () => adjustOrder({\n      from: itemIdx,\n      to: front,\n      event: \"layer-front\"\n    }),\n    [adjustOrder, itemIdx, front]\n  );\n  const handleBackwardClick = (0, react_exports.useCallback)(\n    () => adjustOrder({\n      from: itemIdx,\n      to: itemIdx - 1,\n      event: \"layer-backward\"\n    }),\n    [adjustOrder, itemIdx]\n  );\n  const handleBackClick = (0, react_exports.useCallback)(\n    () => adjustOrder({\n      from: itemIdx,\n      to: 0,\n      event: \"layer-back\"\n    }),\n    [adjustOrder, itemIdx]\n  );\n  const onBlur = (0, dashboard_ui_exports.usePopoverBlurCallback)(onRequestClose);\n  const isFront = itemIdx === front;\n  const isBack = itemIdx === 0;\n  return /* @__PURE__ */ react_default.createElement(\n    Popover_default,\n    {\n      open,\n      anchor: anchor.current,\n      onRequestClose,\n      onBlur,\n      defaultPlacement: \"right\",\n      appearance: \"normal\",\n      takeFocus: true\n    },\n    /* @__PURE__ */ react_default.createElement(Menu_default, { style: menuStyle, \"data-test\": \"layer-menu\" }, !isFront && /* @__PURE__ */ react_default.createElement(\n      Menu_default.Item,\n      {\n        \"data-test\": \"layer-forward\",\n        onClick: handleForwardClick\n      },\n      (0, i18n_exports._)(\"Move forward\")\n    ), !isFront && /* @__PURE__ */ react_default.createElement(\n      Menu_default.Item,\n      {\n        \"data-test\": \"layer-front\",\n        onClick: handleFrontClick\n      },\n      (0, i18n_exports._)(\"Bring to front\")\n    ), !isBack && /* @__PURE__ */ react_default.createElement(\n      Menu_default.Item,\n      {\n        \"data-test\": \"layer-backward\",\n        onClick: handleBackwardClick\n      },\n      (0, i18n_exports._)(\"Move backward\")\n    ), !isBack && /* @__PURE__ */ react_default.createElement(Menu_default.Item, { \"data-test\": \"layer-back\", onClick: handleBackClick }, (0, i18n_exports._)(\"Send to back\")))\n  );\n};\nvar LayerButton = ({\n  dashboardApi,\n  itemId,\n  screenReaderText\n}) => {\n  const [open, setOpen] = (0, react_exports.useState)(false);\n  const anchor = (0, react_exports.useRef)(null);\n  const telemetry = (0, react_exports.useContext)(dashboard_telemetry_exports.TelemetryContext);\n  const layoutStructure = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectLayoutStructure);\n  const layoutType = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectLayoutType);\n  const handleRequestClose = (0, react_exports.useCallback)(() => {\n    var _a;\n    setOpen(false);\n    (_a = anchor.current) == null ? void 0 : _a.focus();\n  }, []);\n  const handleOpen = (0, react_exports.useCallback)(() => {\n    setOpen(true);\n  }, []);\n  const setRef = (0, react_exports.useCallback)((refEl) => {\n    anchor.current = refEl;\n  }, []);\n  const adjustOrder = (0, react_exports.useCallback)(\n    ({ from, to, event }) => {\n      telemetry.collect({\n        source: \"actionMenu\",\n        event\n      });\n      dashboardApi.adjustCanvasItemOrder({ from, to });\n      handleRequestClose();\n    },\n    [dashboardApi, handleRequestClose, telemetry]\n  );\n  if (!itemId || !dashboardApi) {\n    return null;\n  }\n  if (layoutType !== \"absolute\" || !Array.isArray(layoutStructure)) {\n    return null;\n  }\n  const order = layoutStructure.filter(dashboard_utils_exports.isBlockItem).map(({ item }) => item);\n  const itemIdx = order.indexOf(itemId);\n  if (order.length <= 1 || itemIdx === -1) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(react_default.Fragment, null, /* @__PURE__ */ react_default.createElement(\n    ActionButton_default,\n    {\n      \"data-test\": \"layer-button\",\n      icon: /* @__PURE__ */ react_default.createElement(\n        dashboard_icons_exports.Layers,\n        {\n          screenReaderText: screenReaderText || (0, i18n_exports._)(\"Layers\")\n        }\n      ),\n      ref: setRef,\n      onClick: handleOpen\n    }\n  ), /* @__PURE__ */ react_default.createElement(\n    LayerMenu,\n    {\n      open,\n      anchor,\n      onRequestClose: handleRequestClose,\n      itemIdx,\n      front: order.length - 1,\n      adjustOrder\n    }\n  ));\n};\nvar LayerButton_default = LayerButton;\n\n// src/OpenSearchButton.tsx\nvar resolvedSearch = ({\n  dataSourceId,\n  dataSourceDef,\n  dashboardApi\n}) => {\n  const { type, options } = dataSourceDef;\n  if (!options) {\n    return null;\n  }\n  if (type === \"ds.chain\") {\n    return __spreadProps(__spreadValues({}, dataSourceDef), {\n      options: __spreadValues(__spreadValues({}, options), dashboardApi.getCompleteSearchQueryAndParameters(\n        dataSourceId\n      ))\n    });\n  }\n  return dataSourceDef;\n};\nvar noop2 = () => void 0;\nvar ActionButtonWrapper = (0, react_exports.memo)(\n  ({\n    onOpenSearchClick = noop2,\n    screenReaderText,\n    disabled,\n    dataSourceId,\n    dataSourceDef,\n    dashboardApi\n  }) => {\n    const telemetry = (0, react_exports.useContext)(dashboard_telemetry_exports.TelemetryContext);\n    const handleClick = (0, react_exports.useCallback)(() => {\n      telemetry.collect({\n        source: \"actionMenu\",\n        event: \"openInSearch\"\n      });\n      onOpenSearchClick(\n        resolvedSearch({\n          dataSourceId,\n          dataSourceDef,\n          dashboardApi\n        })\n      );\n    }, [\n      dataSourceId,\n      dataSourceDef,\n      dashboardApi,\n      onOpenSearchClick,\n      telemetry\n    ]);\n    const icon2 = (0, react_exports.useMemo)(\n      () => /* @__PURE__ */ react_default.createElement(\n        dashboard_icons_exports.Search,\n        {\n          screenReaderText: screenReaderText || (0, i18n_exports._)(\"Open in search\")\n        }\n      ),\n      [screenReaderText]\n    );\n    return /* @__PURE__ */ react_default.createElement(\n      ActionButton_default,\n      {\n        \"data-test\": \"open-search-button\",\n        onClick: handleClick,\n        icon: icon2,\n        disabled\n      }\n    );\n  }\n);\nvar OpenSearchButton = ({\n  itemId,\n  dashboardApi,\n  itemDefinition,\n  dataSources = {},\n  onOpenSearchClick = noop2,\n  screenReaderText,\n  disabled\n}) => {\n  var _a;\n  const primary = (_a = itemDefinition == null ? void 0 : itemDefinition.dataSources) == null ? void 0 : _a.primary;\n  const primaryDataSource = primary ? dataSources[primary] : null;\n  if (itemId == null || dashboardApi == null || primaryDataSource == null || !primary) {\n    return null;\n  }\n  const resolved = resolvedSearch({\n    dataSourceId: primary,\n    dataSourceDef: primaryDataSource,\n    dashboardApi\n  });\n  const disableButton = typeof disabled === \"function\" ? disabled(resolved) : resolved === null || !(resolved.type === \"ds.search\" || resolved.type === \"ds.chain\" || resolved.type === \"ds.savedSearch\");\n  return /* @__PURE__ */ react_default.createElement(\n    ActionButtonWrapper,\n    {\n      dataSourceId: primary,\n      dataSourceDef: primaryDataSource,\n      dashboardApi,\n      onOpenSearchClick,\n      screenReaderText,\n      disabled: disableButton\n    }\n  );\n};\nvar OpenSearchButton_default = OpenSearchButton;\n\n// src/RefreshButton.tsx\nvar RefreshButton = ({\n  itemId,\n  dashboardApi,\n  screenReaderText = (0, i18n_exports._)(\"Refresh\"),\n  itemDefinition\n}) => {\n  var _a;\n  const telemetry = (0, react_exports.useContext)(dashboard_telemetry_exports.TelemetryContext);\n  const handleOnClick = (0, react_exports.useCallback)(() => {\n    telemetry.collect({\n      source: \"actionMenu\",\n      event: \"refresh\"\n    });\n    dashboardApi == null ? void 0 : dashboardApi.refreshVisualization(itemId);\n  }, [telemetry, dashboardApi, itemId]);\n  if (itemId == null || dashboardApi == null || !((_a = itemDefinition == null ? void 0 : itemDefinition.dataSources) == null ? void 0 : _a.primary)) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(\n    ActionButton_default,\n    {\n      \"data-test\": \"refresh-button\",\n      onClick: handleOnClick,\n      icon: /* @__PURE__ */ react_default.createElement(dashboard_icons_exports.Refresh, { screenReaderText })\n    }\n  );\n};\nvar RefreshButton_default = RefreshButton;\n\n// esm-externals:@splunk/react-icons/ControlPlayResume\nvar ControlPlayResume_exports = {};\n__export(ControlPlayResume_exports, {\n  default: () => ControlPlayResume_default\n});\nvar defaultImport15 = __toESM(require(\"@splunk/react-icons/ControlPlayResume\"));\n__reExport(ControlPlayResume_exports, require(\"@splunk/react-icons/ControlPlayResume\"));\nvar ControlPlayResume_default = \"default\" in defaultImport15 ? defaultImport15.default : defaultImport15;\n\n// esm-externals:@splunk/react-ui/ScreenReaderContent\nvar ScreenReaderContent_exports = {};\n__export(ScreenReaderContent_exports, {\n  default: () => ScreenReaderContent_default\n});\nvar defaultImport16 = __toESM(require(\"@splunk/react-ui/ScreenReaderContent\"));\n__reExport(ScreenReaderContent_exports, require(\"@splunk/react-ui/ScreenReaderContent\"));\nvar ScreenReaderContent_default = \"default\" in defaultImport16 ? defaultImport16.default : defaultImport16;\n\n// src/PauseResumeButton.tsx\nvar PauseResumeButton = ({\n  itemId,\n  dashboardApi,\n  screenReaderText = (0, i18n_exports._)(\"Pause/Resume\"),\n  itemDefinition\n}) => {\n  var _a;\n  const telemetry = (0, react_exports.useContext)(dashboard_telemetry_exports.TelemetryContext);\n  const handleOnClick = (0, react_exports.useCallback)(() => {\n    telemetry.collect({\n      source: \"actionMenu\",\n      event: \"togglePause\"\n    });\n    dashboardApi == null ? void 0 : dashboardApi.togglePause(itemId);\n  }, [telemetry, dashboardApi, itemId]);\n  const buttonIcon = (0, react_exports.useMemo)(\n    () => /* @__PURE__ */ react_default.createElement(react_default.Fragment, null, /* @__PURE__ */ react_default.createElement(ControlPlayResume_default, { variant: \"filled\" }), /* @__PURE__ */ react_default.createElement(ScreenReaderContent_default, null, screenReaderText)),\n    [screenReaderText]\n  );\n  if (!itemId || !dashboardApi || !((_a = itemDefinition == null ? void 0 : itemDefinition.dataSources) == null ? void 0 : _a.primary)) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(\n    ActionButton_default,\n    {\n      \"data-test\": \"pause-resume-button\",\n      onClick: handleOnClick,\n      icon: buttonIcon\n    }\n  );\n};\nvar PauseResumeButton_default = PauseResumeButton;\n//# sourceMappingURL=index.js.map\n","/* Copyright © 2020 Splunk Inc.\nSPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or\nin part without a valid written license from Splunk Inc. is PROHIBITED. */\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  ApiRegistry: () => ApiRegistry,\n  ApiRegistryContextProvider: () => ApiRegistryContextProvider,\n  BaseContentExportClient: () => BaseContentExportClient_default,\n  CanvasContext: () => CanvasContext_default,\n  CoreOverridesContext: () => CoreOverridesContext,\n  DEFAULT_RESIZE_HANDLE_DIRECTIONS: () => DEFAULT_RESIZE_HANDLE_DIRECTIONS,\n  DashboardApiConsumer: () => DashboardApiConsumer,\n  DashboardApiContext: () => DashboardApiContext,\n  DashboardApiProvider: () => DashboardApiProvider,\n  DashboardContext: () => DashboardContext,\n  DashboardContextConsumer: () => DashboardContextConsumer,\n  DashboardContextProvider: () => DashboardContextProvider,\n  DashboardCoreApiConsumer: () => DashboardCoreApiConsumer,\n  DashboardCoreApiContext: () => DashboardCoreApiContext,\n  DashboardCoreApiContextWrapper: () => DashboardCoreApiContextWrapper,\n  DashboardCoreApiProvider: () => DashboardCoreApiProvider,\n  DataSourceRegistryContextProvider: () => DataSourceRegistryContextProvider,\n  DefaultElementRefs: () => DefaultElementRefs,\n  DefaultFeatureFlags: () => FeatureFlags_default2,\n  ElementRefContext: () => ElementRefContext,\n  ElementRefContextProvider: () => ElementRefContextProvider,\n  EventListener: () => EventListener,\n  EventRegistry: () => EventRegistry,\n  EventRegistryContextProvider: () => EventRegistryContextProvider,\n  GeoJsonProvider: () => GeoJsonProvider_default,\n  GeoRegistry: () => GeoRegistry_default,\n  IconRegistry: () => IconRegistry_default,\n  ImageRegistry: () => ImageRegistry_default,\n  KeyboardListener: () => KeyboardListener_default,\n  LayoutLayersContextProvider: () => LayoutLayersContextProvider,\n  LocalIconProvider: () => LocalIconProvider_default,\n  LocalImageProvider: () => LocalImageProvider_default,\n  MockedProvider: () => MockedProvider_default,\n  Preset: () => Preset,\n  PresetContextProvider: () => PresetContextProvider,\n  Provider: () => Provider_default,\n  RegistryContextProvider: () => RegistryContext_default,\n  SearchContext: () => SearchContext,\n  SearchContextProvider: () => SearchContextProvider,\n  SearchManager: () => SearchManager,\n  SidebarContext: () => SidebarContext,\n  SidebarContextProvider: () => SidebarContextProvider,\n  StandardIconProvider: () => StandardIconProvider_default,\n  UnboundSmartSourceBindingType: () => UnboundSmartSourceBindingType,\n  UnboundSmartSourceConsumerId: () => UnboundSmartSourceConsumerId,\n  UnboundSmartSourceRequestParams: () => UnboundSmartSourceRequestParams,\n  default: () => DashboardContext,\n  defaultEventsConfig: () => defaultEventsConfig,\n  defaultMapTileConfig: () => defaultMapTileConfig,\n  forEachSearchBinding: () => forEachSearchBinding,\n  getBindingDifferences: () => getBindingDifferences,\n  getConsumerId: () => getConsumerId,\n  getSearchesToExecute: () => getSearchesToExecute,\n  updatePreset: () => updatePreset,\n  useApiRegistry: () => useApiRegistry,\n  useAutoSearchControl: () => useAutoSearchControl,\n  useBeforeUnloadEvent: () => useBeforeUnloadEvent,\n  useCanvas: () => useCanvas,\n  useCoreOverrides: () => useCoreOverrides,\n  useDashboardApi: () => useDashboardApi,\n  useDashboardCoreApi: () => useDashboardCoreApi,\n  useDashboardPlugin: () => useDashboardPlugin,\n  useDataSourceContext: () => useDataSourceContext,\n  useDataSourceRegistry: () => useDataSourceRegistry,\n  useDocumentationLinks: () => useDocumentationLinks,\n  useElementRefs: () => useElementRefs,\n  useEventRegistry: () => useEventRegistry,\n  useFeatureFlags: () => useFeatureFlags,\n  useHeaderRef: () => useHeaderRef,\n  useIconRegistry: () => useIconRegistry,\n  useImageRegistry: () => useImageRegistry,\n  useIsFirstRender: () => useIsFirstRender,\n  useKeyboardListener: () => useKeyboardListener,\n  useLayoutLayers: () => useLayoutLayers,\n  useLogger: () => useLogger,\n  usePreset: () => usePreset,\n  usePrevious: () => usePrevious,\n  useSearchContext: () => useSearchContext,\n  useSearchMetricsCollector: () => useSearchMetricsCollector,\n  useSidebarContext: () => useSidebarContext,\n  useTabsRef: () => useTabsRef,\n  useUserMessageAPI: () => useUserMessageAPI,\n  vizCategories: () => vizCategories,\n  withInputConfig: () => withInputConfig,\n  withVizConfig: () => withVizConfig\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// esm-externals:memoize-one\nvar memoize_one_exports = {};\n__export(memoize_one_exports, {\n  default: () => memoize_one_default\n});\nvar defaultImport = __toESM(require(\"memoize-one\"));\n__reExport(memoize_one_exports, require(\"memoize-one\"));\nvar memoize_one_default = \"default\" in defaultImport ? defaultImport.default : defaultImport;\n\n// esm-externals:react\nvar react_exports = {};\n__export(react_exports, {\n  default: () => react_default\n});\nvar defaultImport2 = __toESM(require(\"react\"));\n__reExport(react_exports, require(\"react\"));\nvar react_default = \"default\" in defaultImport2 ? defaultImport2.default : defaultImport2;\n\n// esm-externals:prop-types\nvar prop_types_exports = {};\n__export(prop_types_exports, {\n  default: () => prop_types_default\n});\nvar defaultImport3 = __toESM(require(\"prop-types\"));\n__reExport(prop_types_exports, require(\"prop-types\"));\nvar prop_types_default = \"default\" in defaultImport3 ? defaultImport3.default : defaultImport3;\n\n// esm-externals:@splunk/dashboard-utils\nvar dashboard_utils_exports = {};\n__export(dashboard_utils_exports, {\n  default: () => dashboard_utils_default\n});\nvar defaultImport4 = __toESM(require(\"@splunk/dashboard-utils\"));\n__reExport(dashboard_utils_exports, require(\"@splunk/dashboard-utils\"));\nvar dashboard_utils_default = \"default\" in defaultImport4 ? defaultImport4.default : defaultImport4;\n\n// esm-externals:@splunk/visualization-context/GeoContext\nvar GeoContext_exports = {};\n__export(GeoContext_exports, {\n  default: () => GeoContext_default\n});\nvar defaultImport5 = __toESM(require(\"@splunk/visualization-context/GeoContext\"));\n__reExport(GeoContext_exports, require(\"@splunk/visualization-context/GeoContext\"));\nvar GeoContext_default = \"default\" in defaultImport5 ? defaultImport5.default : defaultImport5;\n\n// esm-externals:@splunk/visualization-context/ImageContext\nvar ImageContext_exports = {};\n__export(ImageContext_exports, {\n  default: () => ImageContext_default\n});\nvar defaultImport6 = __toESM(require(\"@splunk/visualization-context/ImageContext\"));\n__reExport(ImageContext_exports, require(\"@splunk/visualization-context/ImageContext\"));\nvar ImageContext_default = \"default\" in defaultImport6 ? defaultImport6.default : defaultImport6;\n\n// esm-externals:@splunk/visualization-context/IconContext\nvar IconContext_exports = {};\n__export(IconContext_exports, {\n  default: () => IconContext_default\n});\nvar defaultImport7 = __toESM(require(\"@splunk/visualization-context/IconContext\"));\n__reExport(IconContext_exports, require(\"@splunk/visualization-context/IconContext\"));\nvar IconContext_default = \"default\" in defaultImport7 ? defaultImport7.default : defaultImport7;\n\n// esm-externals:@splunk/visualization-context/FeatureFlagContext\nvar FeatureFlagContext_exports = {};\n__export(FeatureFlagContext_exports, {\n  default: () => FeatureFlagContext_default\n});\nvar defaultImport8 = __toESM(require(\"@splunk/visualization-context/FeatureFlagContext\"));\n__reExport(FeatureFlagContext_exports, require(\"@splunk/visualization-context/FeatureFlagContext\"));\nvar FeatureFlagContext_default = \"default\" in defaultImport8 ? defaultImport8.default : defaultImport8;\n\n// esm-externals:@splunk/visualization-context/TimezoneContext\nvar TimezoneContext_exports = {};\n__export(TimezoneContext_exports, {\n  default: () => TimezoneContext_default\n});\nvar defaultImport9 = __toESM(require(\"@splunk/visualization-context/TimezoneContext\"));\n__reExport(TimezoneContext_exports, require(\"@splunk/visualization-context/TimezoneContext\"));\nvar TimezoneContext_default = \"default\" in defaultImport9 ? defaultImport9.default : defaultImport9;\n\n// esm-externals:@splunk/visualization-context/MessageContext\nvar MessageContext_exports = {};\n__export(MessageContext_exports, {\n  default: () => MessageContext_default\n});\nvar defaultImport10 = __toESM(require(\"@splunk/visualization-context/MessageContext\"));\n__reExport(MessageContext_exports, require(\"@splunk/visualization-context/MessageContext\"));\nvar MessageContext_default = \"default\" in defaultImport10 ? defaultImport10.default : defaultImport10;\n\n// esm-externals:@splunk/visualization-context/MapContext\nvar MapContext_exports = {};\n__export(MapContext_exports, {\n  default: () => MapContext_default\n});\nvar defaultImport11 = __toESM(require(\"@splunk/visualization-context/MapContext\"));\n__reExport(MapContext_exports, require(\"@splunk/visualization-context/MapContext\"));\nvar MapContext_default = \"default\" in defaultImport11 ? defaultImport11.default : defaultImport11;\n\n// esm-externals:@splunk/visualization-context/EventsContext\nvar EventsContext_exports = {};\n__export(EventsContext_exports, {\n  default: () => EventsContext_default\n});\nvar defaultImport12 = __toESM(require(\"@splunk/visualization-context/EventsContext\"));\n__reExport(EventsContext_exports, require(\"@splunk/visualization-context/EventsContext\"));\nvar EventsContext_default = \"default\" in defaultImport12 ? defaultImport12.default : defaultImport12;\n\n// esm-externals:@splunk/dashboard-telemetry\nvar dashboard_telemetry_exports = {};\n__export(dashboard_telemetry_exports, {\n  default: () => dashboard_telemetry_default\n});\nvar defaultImport13 = __toESM(require(\"@splunk/dashboard-telemetry\"));\n__reExport(dashboard_telemetry_exports, require(\"@splunk/dashboard-telemetry\"));\nvar dashboard_telemetry_default = \"default\" in defaultImport13 ? defaultImport13.default : defaultImport13;\n\n// esm-externals:@splunk/dashboard-state\nvar dashboard_state_exports = {};\n__export(dashboard_state_exports, {\n  default: () => dashboard_state_default\n});\nvar defaultImport14 = __toESM(require(\"@splunk/dashboard-state\"));\n__reExport(dashboard_state_exports, require(\"@splunk/dashboard-state\"));\nvar dashboard_state_default = \"default\" in defaultImport14 ? defaultImport14.default : defaultImport14;\n\n// esm-externals:@splunk/datasources\nvar datasources_exports = {};\n__export(datasources_exports, {\n  default: () => datasources_default\n});\nvar defaultImport15 = __toESM(require(\"@splunk/datasources\"));\n__reExport(datasources_exports, require(\"@splunk/datasources\"));\nvar datasources_default = \"default\" in defaultImport15 ? defaultImport15.default : defaultImport15;\n\n// esm-externals:@splunk/dashboard-definition\nvar dashboard_definition_exports = {};\n__export(dashboard_definition_exports, {\n  default: () => dashboard_definition_default\n});\nvar defaultImport16 = __toESM(require(\"@splunk/dashboard-definition\"));\n__reExport(dashboard_definition_exports, require(\"@splunk/dashboard-definition\"));\nvar dashboard_definition_default = \"default\" in defaultImport16 ? defaultImport16.default : defaultImport16;\n\n// esm-externals:lodash\nvar lodash_exports = {};\n__export(lodash_exports, {\n  default: () => lodash_default\n});\nvar defaultImport17 = __toESM(require(\"lodash\"));\n__reExport(lodash_exports, require(\"lodash\"));\nvar lodash_default = \"default\" in defaultImport17 ? defaultImport17.default : defaultImport17;\n\n// esm-externals:@splunk/dashboard-search\nvar dashboard_search_exports = {};\n__export(dashboard_search_exports, {\n  default: () => dashboard_search_default\n});\nvar defaultImport18 = __toESM(require(\"@splunk/dashboard-search\"));\n__reExport(dashboard_search_exports, require(\"@splunk/dashboard-search\"));\nvar dashboard_search_default = \"default\" in defaultImport18 ? defaultImport18.default : defaultImport18;\n\n// src/registries/extensions/ApiRegistry.ts\nvar ApiRegistry = class {\n  constructor() {\n    this.layoutApis = {};\n    this.visualizationApis = {};\n    this.visualizationActionApis = {};\n    this.globalInputsApi = null;\n    this.inputApis = {};\n    this.inputActionApis = {};\n    this.layoutApiPromises = {};\n    this.layoutApiPromiseResolvers = {};\n    this.toolbarApi = {};\n  }\n  registerLayoutApi({\n    layoutId,\n    layoutApi\n  }) {\n    this.layoutApis[layoutId] = layoutApi;\n    const resolver = this.layoutApiPromiseResolvers[layoutId];\n    if (resolver) {\n      resolver(layoutApi);\n    }\n    this.notifyLayoutApiReady();\n  }\n  registerVisualizationActionsApi(vizId, api) {\n    this.visualizationActionApis[vizId] = api;\n  }\n  registerVisualizationApi(vizId, api) {\n    this.visualizationApis[vizId] = api;\n  }\n  registerGlobalInputsApi(api) {\n    this.globalInputsApi = api;\n  }\n  registerInputApi(inputId, api) {\n    this.inputApis[inputId] = api;\n  }\n  registerInputActionsApi(inputId, api) {\n    this.inputActionApis[inputId] = api;\n  }\n  registerToolbarApi(api) {\n    this.toolbarApi = api;\n  }\n  removeLayoutApi(layoutId) {\n    delete this.layoutApis[layoutId];\n    delete this.layoutApiPromises[layoutId];\n    delete this.layoutApiPromiseResolvers[layoutId];\n  }\n  removeAllLayoutApis() {\n    this.layoutApis = {};\n    this.layoutApiPromises = {};\n    this.layoutApiPromiseResolvers = {};\n  }\n  removeVisualizationApi(vizId) {\n    delete this.visualizationApis[vizId];\n  }\n  removeVisualizationActionsApi(vizId) {\n    delete this.visualizationActionApis[vizId];\n  }\n  removeGlobalInputsApi() {\n    this.globalInputsApi = null;\n  }\n  removeInputApi(inputId) {\n    delete this.inputApis[inputId];\n  }\n  removeInputActionsApi(inputId) {\n    delete this.inputActionApis[inputId];\n  }\n  removeToolbarApi() {\n    this.toolbarApi = null;\n  }\n  getToolbarApi() {\n    return this.toolbarApi;\n  }\n  getLayoutApi(layoutId) {\n    return this.layoutApis[layoutId] || null;\n  }\n  getLayoutApiAsync(layoutId) {\n    return __async(this, null, function* () {\n      const promise = this.layoutApiPromises[layoutId];\n      if (typeof promise !== \"undefined\") {\n        return promise;\n      }\n      const newPromise = new Promise((resolve) => {\n        const layoutApi = this.layoutApis[layoutId];\n        if (layoutApi) {\n          resolve(layoutApi);\n          return;\n        }\n        this.layoutApiPromiseResolvers[layoutId] = resolve;\n      });\n      this.layoutApiPromises[layoutId] = newPromise;\n      return newPromise;\n    });\n  }\n  getVisualizationApi(vizId) {\n    return this.visualizationApis[vizId];\n  }\n  getVisualizationActionsApi(vizId) {\n    return this.visualizationActionApis[vizId];\n  }\n  getGlobalInputsApi() {\n    return this.globalInputsApi;\n  }\n  getInputApi(inputId) {\n    return this.inputApis[inputId];\n  }\n  getInputActionsApi(inputId) {\n    return this.inputActionApis[inputId];\n  }\n  notifyLayoutApiReady() {\n    if (typeof this.onLayoutApiReady === \"function\") {\n      this.onLayoutApiReady();\n    }\n  }\n  // teardown is a bit of a strong word as it has a connotation of self-destruction, which this doesn't do.\n  teardown() {\n    this.cleanup();\n  }\n  cleanup() {\n    this.removeAllLayoutApis();\n    this.removeGlobalInputsApi();\n    this.visualizationApis = {};\n    this.visualizationActionApis = {};\n    this.inputApis = {};\n    this.inputActionApis = {};\n    this.toolbarApi = null;\n  }\n};\n\n// src/ApiRegistryContext.tsx\nvar defaultRegistry = new ApiRegistry();\nvar ApiRegistryContext = (0, react_exports.createContext)(defaultRegistry);\nvar ApiRegistryContextProvider = ({\n  children\n}) => {\n  const registry = (0, react_exports.useMemo)(() => new ApiRegistry(), []);\n  (0, react_exports.useEffect)(() => {\n    return () => registry.teardown();\n  }, [registry]);\n  return /* @__PURE__ */ react_default.createElement(ApiRegistryContext.Provider, { value: registry }, children);\n};\nvar useApiRegistry = () => {\n  return (0, react_exports.useContext)(ApiRegistryContext);\n};\n\n// src/registries/events/EventRegistry.ts\nvar EventRegistry = class {\n  constructor() {\n    this.idSeq = 0;\n    this.storedEvents = {};\n  }\n  registerEvent(e) {\n    this.idSeq = this.idSeq < Number.MAX_SAFE_INTEGER ? this.idSeq + 1 : 0;\n    const id = `event${this.idSeq}`;\n    this.storedEvents[id] = e;\n    return id;\n  }\n  retrieveEvent(id) {\n    const event = this.storedEvents[id];\n    delete this.storedEvents[id];\n    return event;\n  }\n  teardown() {\n    this.cleanup();\n  }\n  cleanup() {\n    this.storedEvents = {};\n    this.idSeq = 0;\n  }\n};\n\n// src/EventRegistryContext.tsx\nvar defaultRegistry2 = new EventRegistry();\nvar EventRegistryContext = (0, react_exports.createContext)(defaultRegistry2);\nvar EventRegistryContextProvider = ({\n  children\n}) => {\n  const registry = (0, react_exports.useMemo)(() => new EventRegistry(), []);\n  (0, react_exports.useEffect)(() => {\n    return () => registry.teardown();\n  }, [registry]);\n  return /* @__PURE__ */ react_default.createElement(EventRegistryContext.Provider, { value: registry }, children);\n};\nvar useEventRegistry = () => (0, react_exports.useContext)(EventRegistryContext);\n\n// src/PresetContext.ts\nvar PresetContext = (0, react_exports.createContext)(null);\nvar PresetContextProvider = PresetContext.Provider;\nvar usePreset = () => {\n  const ctx = (0, react_exports.useContext)(PresetContext);\n  if (ctx === null) {\n    throw new Error(\n      \"usePreset can only be used in a component that is a child of a PresetContextProvider\"\n    );\n  }\n  return ctx;\n};\n\n// src/DataSourceRegistryContext.ts\nvar DataSourceRegistryContext = (0, react_exports.createContext)(\n  null\n);\nvar DataSourceRegistryContextProvider = DataSourceRegistryContext.Provider;\nvar useDataSourceRegistry = () => {\n  const ctx = (0, react_exports.useContext)(DataSourceRegistryContext);\n  if (ctx === null) {\n    throw new Error(\n      \"useDataSourceRegistry can only be used in a component that is a child of a DataSourceRegistryContextProvider\"\n    );\n  }\n  return ctx;\n};\n\n// src/hooks/useBeforeUnloadEvent.tsx\nvar useBeforeUnloadEvent = (cleanupFn) => {\n  (0, react_exports.useEffect)(() => {\n    const runCleanup = cleanupFn;\n    window.addEventListener(\"beforeunload\", runCleanup);\n    return () => {\n      window.removeEventListener(\"beforeunload\", runCleanup);\n    };\n  }, [cleanupFn]);\n};\n\n// src/hooks/usePrevious.tsx\nvar usePrevious = (value) => {\n  const ref = (0, react_exports.useRef)(null);\n  (0, react_exports.useEffect)(() => {\n    ref.current = value;\n  });\n  return ref.current;\n};\n\n// src/hooks/useAutoSearchControl.ts\nvar useAutoSearchControl = ({\n  activeTab,\n  searchesToExecuteByLayout,\n  searchesToRemove,\n  prevSearchesToRemove,\n  searchesToRemoveFromCache,\n  prevSearchesToRemoveFromCache\n}) => {\n  var _a, _b;\n  const dsRegistry = useDataSourceRegistry();\n  const prevActiveTab = usePrevious(activeTab);\n  if (!activeTab) {\n    return;\n  }\n  if (prevSearchesToRemove !== searchesToRemove && activeTab) {\n    const searchesToPause = Object.keys(searchesToRemove).filter(\n      (dsId) => {\n        var _a2;\n        return (0, dashboard_utils_exports.isEmptyOrUndefined)((_a2 = searchesToExecuteByLayout[activeTab]) == null ? void 0 : _a2[dsId]);\n      }\n    );\n    if (searchesToPause.length) {\n      dsRegistry.pauseDataSources(searchesToPause, {\n        checkIfInUse: true\n      });\n    }\n  }\n  if (prevSearchesToRemoveFromCache !== searchesToRemoveFromCache && activeTab) {\n    const searchesToPause = Object.keys(searchesToRemoveFromCache).filter(\n      (dsId) => {\n        var _a2;\n        return (0, dashboard_utils_exports.isEmptyOrUndefined)((_a2 = searchesToExecuteByLayout[activeTab]) == null ? void 0 : _a2[dsId]);\n      }\n    );\n    if (searchesToPause.length) {\n      dsRegistry.pauseDataSources(searchesToPause);\n    }\n  }\n  if (prevActiveTab && prevActiveTab !== activeTab) {\n    const prevTabDsIds = Object.keys(\n      (_a = searchesToExecuteByLayout[prevActiveTab]) != null ? _a : {}\n    );\n    const currentTabSearches = (_b = searchesToExecuteByLayout[activeTab]) != null ? _b : {};\n    const currentTabDsIds = Object.keys(currentTabSearches);\n    const currentTabBaseControllers = new Set(\n      currentTabDsIds.map(\n        (dsId) => {\n          var _a2;\n          return (_a2 = dsRegistry.getDataSourceController(dsId)) == null ? void 0 : _a2.getBase();\n        }\n      ).filter(Boolean)\n    );\n    const searchesToPause = new Set(prevTabDsIds);\n    prevTabDsIds.forEach((dsId) => {\n      var _a2;\n      if (!(0, dashboard_utils_exports.isEmptyOrUndefined)(currentTabSearches[dsId])) {\n        searchesToPause.delete(dsId);\n        return;\n      }\n      const base = (_a2 = dsRegistry.getDataSourceController(dsId)) == null ? void 0 : _a2.getBase();\n      if (currentTabBaseControllers.has(base)) {\n        searchesToPause.delete(dsId);\n      }\n    });\n    if (searchesToPause.size) {\n      dsRegistry.pauseDataSources(Array.from(searchesToPause.values()));\n    }\n    if (currentTabDsIds.length) {\n      dsRegistry.resumeDataSources(currentTabDsIds);\n    }\n  }\n};\n\n// src/hooks/useIsFirstRender.tsx\nvar useIsFirstRender = () => {\n  const isFirstRenderRef = (0, react_exports.useRef)(true);\n  const isFirstRender = isFirstRenderRef.current;\n  isFirstRenderRef.current = false;\n  return isFirstRender;\n};\n\n// src/DataSourceContext/DataSourceContext.ts\nvar defaultDataSourceContextValue = Object.freeze({});\nvar DataSourceContext = (0, react_exports.createContext)(\n  defaultDataSourceContextValue\n);\nvar DataSourceContextProvider = DataSourceContext.Provider;\nvar useDataSourceContext = () => (0, react_exports.useContext)(DataSourceContext);\n\n// src/RegistryContext.tsx\nvar UpdateMiddlewareContext = () => {\n  const { updateMiddlewareContext } = (0, dashboard_state_exports.useUpdateMiddlewareContext)();\n  const preset = usePreset();\n  const dataSourceRegistry = useDataSourceRegistry();\n  const apiRegistry = useApiRegistry();\n  const eventRegistry = useEventRegistry();\n  const featureFlags = useFeatureFlags();\n  const telemetryApi = (0, dashboard_telemetry_exports.useTelemetryApi)();\n  const prevPreset = usePrevious(preset);\n  const prevDataSourceRegistry = usePrevious(dataSourceRegistry);\n  const prevApiRegistry = usePrevious(apiRegistry);\n  const prevEventRegistry = usePrevious(eventRegistry);\n  const prevFeatureFlags = usePrevious(featureFlags);\n  const prevTelemetryApi = usePrevious(telemetryApi);\n  const contextToUpdate = {};\n  if (preset !== prevPreset) {\n    contextToUpdate.preset = preset;\n  }\n  if (dataSourceRegistry !== prevDataSourceRegistry) {\n    contextToUpdate.dataSourceRegistry = dataSourceRegistry;\n  }\n  if (apiRegistry !== prevApiRegistry) {\n    contextToUpdate.apiRegistry = apiRegistry;\n  }\n  if (eventRegistry !== prevEventRegistry) {\n    contextToUpdate.eventRegistry = eventRegistry;\n  }\n  if (featureFlags !== prevFeatureFlags) {\n    contextToUpdate.featureFlags = featureFlags;\n  }\n  if (telemetryApi !== prevTelemetryApi) {\n    contextToUpdate.telemetryApi = telemetryApi;\n  }\n  if (Object.keys(contextToUpdate).length) {\n    updateMiddlewareContext(contextToUpdate);\n  }\n  return null;\n};\nvar RegistryContextProvider = ({\n  children,\n  dataSourceContext = defaultDataSourceContextValue,\n  preset\n}) => {\n  const store = (0, dashboard_state_exports.useStore)();\n  const dataSourceDefinitions = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectDataSourceDefinitions);\n  const dsContextRef = (0, react_exports.useRef)(dataSourceContext);\n  const presetRef = (0, react_exports.useRef)(preset);\n  const dataSourceDefinitionsRef = (0, react_exports.useRef)();\n  const dataSourceRegistry = (0, react_exports.useRef)(null);\n  if (dataSourceRegistry.current === null) {\n    dataSourceRegistry.current = new dashboard_search_exports.DataSourceRegistry({\n      preset: presetRef.current,\n      dataSourceContext: dsContextRef.current\n    });\n    dataSourceRegistry.current.subscribeToStore(store);\n  }\n  if (!(0, lodash_exports.isEqual)(dataSourceContext, dsContextRef.current)) {\n    dsContextRef.current = dataSourceContext;\n    dataSourceRegistry.current.setDataSourceContext(dsContextRef.current);\n  }\n  if (preset !== presetRef.current) {\n    presetRef.current = preset;\n    dataSourceRegistry.current.setPreset(presetRef.current);\n  }\n  if (dataSourceDefinitions !== dataSourceDefinitionsRef.current) {\n    dataSourceDefinitionsRef.current = dataSourceDefinitions;\n    dataSourceRegistry.current.updateDefinition({\n      definition: dataSourceDefinitions\n    });\n  }\n  const teardownDataSources = (0, react_exports.useCallback)(() => {\n    var _a;\n    (_a = dataSourceRegistry.current) == null ? void 0 : _a.teardown();\n  }, []);\n  useBeforeUnloadEvent(teardownDataSources);\n  return /* @__PURE__ */ react_default.createElement(PresetContextProvider, { value: preset }, /* @__PURE__ */ react_default.createElement(ApiRegistryContextProvider, null, /* @__PURE__ */ react_default.createElement(EventRegistryContextProvider, null, /* @__PURE__ */ react_default.createElement(\n    DataSourceRegistryContextProvider,\n    {\n      value: dataSourceRegistry.current\n    },\n    /* @__PURE__ */ react_default.createElement(UpdateMiddlewareContext, null),\n    children\n  ))));\n};\nvar RegistryContext_default = RegistryContextProvider;\n\n// esm-externals:mousetrap\nvar mousetrap_exports = {};\n__export(mousetrap_exports, {\n  default: () => mousetrap_default\n});\nvar defaultImport19 = __toESM(require(\"mousetrap\"));\n__reExport(mousetrap_exports, require(\"mousetrap\"));\nvar mousetrap_default = \"default\" in defaultImport19 ? defaultImport19.default : defaultImport19;\n\n// src/EventListener.ts\nvar EventListener = class {\n  constructor() {\n    this.events = {};\n  }\n  // Simple and Generic PubSub (not keyboard specific)\n  subscribe(eventName, callback) {\n    if (!eventName || !callback || typeof eventName !== \"string\" || typeof callback !== \"function\") {\n      throw new TypeError(\"wrong parameters given to subscriber\");\n    }\n    this.events[eventName] = this.getSubscribers(eventName);\n    this.events[eventName].push(callback);\n    return () => {\n      this.events[eventName] = this.getSubscribers(eventName).filter(\n        (cb) => cb !== callback\n      );\n    };\n  }\n  subscribeOnce(eventName, callback) {\n    const unsubscribe = this.subscribe(eventName, (...args) => {\n      unsubscribe();\n      callback(...args);\n    });\n    return unsubscribe;\n  }\n  publish(eventName, ...data) {\n    this.getSubscribers(eventName).forEach((cb) => cb(...data));\n  }\n  unsubscribeAll() {\n    this.events = {};\n  }\n  getSubscribers(eventName) {\n    return this.events[eventName] || [];\n  }\n  hasSubscribers(eventName) {\n    return this.getSubscribers(eventName).length > 0;\n  }\n};\n\n// src/KeyboardListener.ts\nmousetrap_default.addKeycodes({ 173: \"-\" });\nvar DEFAULT_KEYMAP = [\n  {\n    event: \"move.left.unsnap\",\n    keys: \"shift+left\",\n    meta: { snap: false, dir: \"w\" }\n  },\n  { event: \"move.left\", keys: \"left\", meta: { snap: true, dir: \"w\" } },\n  {\n    event: \"move.right.unsnap\",\n    keys: \"shift+right\",\n    meta: { snap: false, dir: \"e\" }\n  },\n  { event: \"move.right\", keys: \"right\", meta: { snap: true, dir: \"e\" } },\n  {\n    event: \"move.up.unsnap\",\n    keys: \"shift+up\",\n    meta: { snap: false, dir: \"n\" }\n  },\n  { event: \"move.up\", keys: \"up\", meta: { snap: true, dir: \"n\" } },\n  {\n    event: \"move.down.unsnap\",\n    keys: \"shift+down\",\n    meta: { snap: false, dir: \"s\" }\n  },\n  { event: \"move.down\", keys: \"down\", meta: { snap: true, dir: \"s\" } },\n  { event: \"copy\", keys: \"meta+c\", when: \"mac\" },\n  { event: \"copy\", keys: \"ctrl+c\", when: \"!mac\" },\n  { event: \"paste\", keys: \"meta+v\", when: \"mac\" },\n  { event: \"paste\", keys: \"ctrl+v\", when: \"!mac\" },\n  { event: \"duplicate\", keys: \"meta+d\", when: \"mac\" },\n  { event: \"duplicate\", keys: \"ctrl+d\", when: \"!mac\" },\n  { event: \"selectAll\", keys: \"meta+a\", when: \"mac\" },\n  { event: \"selectAll\", keys: \"ctrl+a\", when: \"!mac\" },\n  { event: \"selectNone\", keys: \"meta+shift+a\", when: \"mac\" },\n  { event: \"selectNone\", keys: \"ctrl+shift+a\", when: \"!mac\" },\n  { event: \"removeItems\", keys: \"backspace\" },\n  { event: \"removeItems\", keys: \"del\" },\n  { event: \"cancel\", keys: \"escape\" },\n  { event: \"undo\", keys: \"meta+z\", when: \"mac\" },\n  { event: \"undo\", keys: \"ctrl+z\", when: \"!mac\" },\n  { event: \"redo\", keys: \"meta+shift+z\", when: \"mac\" },\n  { event: \"redo\", keys: \"ctrl+shift+z\", when: \"!mac\" },\n  { event: \"zoom.in\", keys: \"ctrl+meta+=\", meta: { dir: \"in\" }, when: \"mac\" },\n  {\n    event: \"zoom.out\",\n    keys: \"ctrl+meta+-\",\n    meta: { dir: \"out\" },\n    when: \"mac\"\n  },\n  {\n    event: \"zoom.reset\",\n    keys: \"ctrl+meta+0\",\n    meta: { dir: \"reset\" },\n    when: \"mac\"\n  },\n  { event: \"zoom.in\", keys: \"ctrl+alt+=\", meta: { dir: \"in\" }, when: \"!mac\" },\n  {\n    event: \"zoom.out\",\n    keys: \"ctrl+alt+-\",\n    meta: { dir: \"out\" },\n    when: \"!mac\"\n  },\n  {\n    event: \"zoom.reset\",\n    keys: \"ctrl+alt+0\",\n    meta: { dir: \"reset\" },\n    when: \"!mac\"\n  }\n];\nvar isValid = (when) => {\n  const isMacOS = (0, dashboard_utils_exports.isMac)();\n  return !when || isMacOS && when === \"mac\" || !isMacOS && when === \"!mac\";\n};\nvar defaultMousetrapStopCallback = mousetrap_default.prototype.stopCallback;\nmousetrap_default.prototype.stopCallback = function stopCallback(e, element, combo) {\n  if (defaultMousetrapStopCallback.call(this, e, element, combo)) {\n    return true;\n  }\n  const popoverContainer = document.querySelectorAll(\n    '[data-test=\"layer-container\"]'\n  );\n  if (popoverContainer == null ? void 0 : popoverContainer.length) {\n    return Array.from(popoverContainer).some(\n      (container) => container.contains(element)\n    );\n  }\n  return false;\n};\nvar KeyboardListener = class extends EventListener {\n  constructor(keyMapConfig = DEFAULT_KEYMAP) {\n    super();\n    this.keyMaps = {};\n    /**\n     * update key mapping config\n     * @param {Object} keyMapConfig\n     * @public\n     */\n    this.updateKeyMap = (keyMapConfig = DEFAULT_KEYMAP) => {\n      this.buildKeyMaps(keyMapConfig);\n      this.setup();\n    };\n    /**\n     * build reverse key mapping, using keys as the mapping key\n     * @param {Object} keyMapConfig\n     * @private\n     */\n    this.buildKeyMaps = (keyMapConfig) => {\n      this.keyMaps = {};\n      keyMapConfig.forEach((keyRule) => {\n        const valid = isValid(keyRule.when);\n        if (valid) {\n          if (this.keyMaps[keyRule.keys]) {\n            dashboard_utils_exports.console.warn(\n              `duplicate key mapping detected for ${keyRule.keys}`\n            );\n          }\n          this.keyMaps[keyRule.keys] = __spreadValues({}, keyRule);\n        }\n      });\n    };\n    /** publish keyboard action event(s)\n     * @param {Object} event\n     * @private\n     */\n    this.publishKeyEvent = (eventName, payload) => {\n      eventName.split(\".\").forEach((_7, i, arr) => {\n        this.publish(arr.slice(0, i + 1).join(\".\"), payload);\n      });\n    };\n    this.updateKeyMap(keyMapConfig);\n  }\n  /**\n   * set up keyboard listener\n   * @public\n   */\n  setup() {\n    this.teardown();\n    Object.keys(this.keyMaps).forEach((key) => {\n      mousetrap_default.bind(key, () => {\n        let defaultPrevented = false;\n        const payload = __spreadProps(__spreadValues({}, this.keyMaps[key].meta), {\n          preventDefault: () => {\n            defaultPrevented = true;\n          }\n        });\n        const eventName = this.keyMaps[key].event;\n        this.publishKeyEvent(eventName, payload);\n        return !defaultPrevented;\n      });\n    });\n  }\n  /**\n   * teardown all keyboard listener\n   * @public\n   */\n  // eslint-disable-next-line class-methods-use-this\n  teardown() {\n    mousetrap_default.reset();\n  }\n};\nvar KeyboardListener_default = KeyboardListener;\n\n// esm-externals:@splunk/visualization-context/FeatureFlags\nvar FeatureFlags_exports = {};\n__export(FeatureFlags_exports, {\n  default: () => FeatureFlags_default\n});\nvar defaultImport20 = __toESM(require(\"@splunk/visualization-context/FeatureFlags\"));\n__reExport(FeatureFlags_exports, require(\"@splunk/visualization-context/FeatureFlags\"));\nvar FeatureFlags_default = \"default\" in defaultImport20 ? defaultImport20.default : defaultImport20;\n\n// src/FeatureFlags.ts\nvar defaultFeatureFlags = __spreadProps(__spreadValues({}, FeatureFlags_default), {\n  enableTestDataSourceEditor: false,\n  enableImageFileUpload: false,\n  enableIconUploads: true,\n  enableIconDelete: true,\n  enableSVGImageUpload: true,\n  enableSvgHttpDownloader: true,\n  showProgressBar: true,\n  showLastUpdated: true,\n  enableVizSourceEditor: true,\n  enableVizIdEditor: true,\n  enableDSSourceEditor: true,\n  enableDSIdEditor: true,\n  enableDSModuleEditor: true,\n  enableDSApplyButton: false,\n  enableDragDropInputs: true,\n  enableInputOptionsEditor: true,\n  enableInputDSEditor: false,\n  enableInputSourceEditor: true,\n  enableInputIdEditor: true,\n  enableGridLayoutErrors: false,\n  enableGallerySharingWarning: true,\n  enableCollapsibleToolbar: false,\n  enableZoomCenter: false,\n  showNewDataForViz: true,\n  enableGridLayoutCssScaling: true,\n  enableTokensInUrl: true,\n  trackActiveTabInUrl: true,\n  enableVizMigrationCheck: false,\n  enableDefaultTokenUI: false,\n  enableMarginDeselection: false,\n  enableSmartSourceDS: false,\n  enableInputsOnCanvas: false,\n  enableTokensInBackgroundImage: false,\n  enableShowHide: false,\n  enableExpandedSourceEditor: false,\n  enableSSR: false,\n  enableSourceModeValidation: true,\n  allowMultipleInteractions: false,\n  showCornerRadiusEditor: false,\n  confirmGlobalTimeRangeDeletion: false,\n  allowImportTab: false,\n  simplifySchemaErrors: false\n});\nvar FeatureFlags_default2 = defaultFeatureFlags;\n\n// esm-externals:styled-components\nvar styled_components_exports = {};\n__export(styled_components_exports, {\n  default: () => styled_components_default\n});\nvar defaultImport21 = __toESM(require(\"styled-components\"));\n__reExport(styled_components_exports, require(\"styled-components\"));\nvar styled_components_default = \"default\" in defaultImport21 ? defaultImport21.default : defaultImport21;\n\n// esm-externals:@splunk/react-ui/Message\nvar Message_exports = {};\n__export(Message_exports, {\n  default: () => Message_default\n});\nvar defaultImport22 = __toESM(require(\"@splunk/react-ui/Message\"));\n__reExport(Message_exports, require(\"@splunk/react-ui/Message\"));\nvar Message_default = \"default\" in defaultImport22 ? defaultImport22.default : defaultImport22;\n\n// esm-externals:@splunk/themes\nvar themes_exports = {};\n__export(themes_exports, {\n  default: () => themes_default\n});\nvar defaultImport23 = __toESM(require(\"@splunk/themes\"));\n__reExport(themes_exports, require(\"@splunk/themes\"));\nvar themes_default = \"default\" in defaultImport23 ? defaultImport23.default : defaultImport23;\n\n// esm-externals:@splunk/ui-utils/i18n\nvar i18n_exports = {};\n__export(i18n_exports, {\n  default: () => i18n_default\n});\nvar defaultImport24 = __toESM(require(\"@splunk/ui-utils/i18n\"));\n__reExport(i18n_exports, require(\"@splunk/ui-utils/i18n\"));\nvar i18n_default = \"default\" in defaultImport24 ? defaultImport24.default : defaultImport24;\n\n// src/DashboardContextErrorBoundary.tsx\nvar DashboardContextError = (0, i18n_exports._)(\n  \"An internal error occurred. Contact your Splunk Administrator.\"\n);\nvar ErrorPage = styled_components_default.div`\n    width: 100%;\n    height: 100%;\n    background-color: ${themes_exports.variables.backgroundColorPage};\n`;\nvar ErrorContainer = styled_components_default.div`\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    font-size: 15px;\n    background-color: ${themes_exports.variables.backgroundColorPage};\n`;\nvar DashboardContextErrorMessage = /* @__PURE__ */ react_default.createElement(ErrorPage, null, /* @__PURE__ */ react_default.createElement(ErrorContainer, { \"data-test\": \"dashboard-context-error\" }, /* @__PURE__ */ react_default.createElement(Message_default, { type: \"error\" }, DashboardContextError)));\nvar DashboardContextErrorBoundary_default = class extends react_exports.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      hasError: true,\n      errorMessage: typeof error === \"string\" ? error : error == null ? void 0 : error.message\n    };\n  }\n  render() {\n    return this.state.hasError ? DashboardContextErrorMessage : this.props.children;\n  }\n};\n\n// esm-externals:@dnd-kit/core\nvar core_exports = {};\n__export(core_exports, {\n  default: () => core_default\n});\nvar defaultImport25 = __toESM(require(\"@dnd-kit/core\"));\n__reExport(core_exports, require(\"@dnd-kit/core\"));\nvar core_default = \"default\" in defaultImport25 ? defaultImport25.default : defaultImport25;\n\n// esm-externals:@dnd-kit/sortable\nvar sortable_exports = {};\n__export(sortable_exports, {\n  default: () => sortable_default\n});\nvar defaultImport26 = __toESM(require(\"@dnd-kit/sortable\"));\n__reExport(sortable_exports, require(\"@dnd-kit/sortable\"));\nvar sortable_default = \"default\" in defaultImport26 ? defaultImport26.default : defaultImport26;\n\n// esm-externals:@dnd-kit/utilities\nvar utilities_exports = {};\n__export(utilities_exports, {\n  default: () => utilities_default\n});\nvar defaultImport27 = __toESM(require(\"@dnd-kit/utilities\"));\n__reExport(utilities_exports, require(\"@dnd-kit/utilities\"));\nvar utilities_default = \"default\" in defaultImport27 ? defaultImport27.default : defaultImport27;\n\n// src/dndModifiers/SnapCenterXToCursor.ts\nvar SnapCenterXToCursor = ({\n  activatorEvent,\n  active,\n  draggingNodeRect,\n  transform\n}) => {\n  var _a, _b;\n  if ((_b = (_a = active == null ? void 0 : active.data) == null ? void 0 : _a.current) == null ? void 0 : _b.snapCenterToCursor) {\n    if (draggingNodeRect && activatorEvent) {\n      const activatorCoordinates = (0, utilities_exports.getEventCoordinates)(activatorEvent);\n      if (!activatorCoordinates) {\n        return transform;\n      }\n      const offsetX = activatorCoordinates.x - draggingNodeRect.left;\n      return __spreadProps(__spreadValues({}, transform), {\n        x: transform.x + offsetX - draggingNodeRect.width / 2\n      });\n    }\n  }\n  return transform;\n};\n\n// src/DragAndDropContext.tsx\nvar dndModifiers = [SnapCenterXToCursor];\nvar DndAccessibility = styled_components_default.div`\n    width: 0px;\n    height: 0px;\n    // @dnd-kit/accessibility is injected by the DndContext and has a left margin\n    // of -1px which messes with visual tests but has no impact when rendered in browser\n    transform: translateX(1px);\n`;\nvar DragAndDropContext = ({\n  children,\n  dndAccessibilityPortal\n}) => {\n  const sensors = (0, core_exports.useSensors)(\n    (0, core_exports.useSensor)(core_exports.MouseSensor),\n    (0, core_exports.useSensor)(core_exports.KeyboardSensor, {\n      coordinateGetter: sortable_exports.sortableKeyboardCoordinates\n    })\n  );\n  const dndAccessibility = (0, react_exports.useMemo)(\n    () => dndAccessibilityPortal ? { container: dndAccessibilityPortal } : void 0,\n    [dndAccessibilityPortal]\n  );\n  return /* @__PURE__ */ react_default.createElement(\n    core_exports.DndContext,\n    {\n      sensors,\n      modifiers: dndModifiers,\n      accessibility: dndAccessibility\n    },\n    children\n  );\n};\nvar DragAndDropContextProvider = ({\n  children\n}) => {\n  const [dndAccessibilityPortal, setDndAccessibilityPortal] = (0, react_exports.useState)(null);\n  const setDndAccessibilityRef = (0, react_exports.useCallback)((element) => {\n    setDndAccessibilityPortal(element);\n  }, []);\n  return /* @__PURE__ */ react_default.createElement(react_default.Fragment, null, /* @__PURE__ */ react_default.createElement(DragAndDropContext, { dndAccessibilityPortal }, children), /* @__PURE__ */ react_default.createElement(\n    DndAccessibility,\n    {\n      ref: setDndAccessibilityRef,\n      \"data-test\": \"dnd-accessibility-portal\"\n    }\n  ));\n};\n\n// src/LayoutLayersContext.tsx\nvar isLayerableStructureItem = (item) => typeof item === \"object\" && item !== null && typeof item.item === \"string\";\nvar convertToMemoizedContextValue = (0, lodash_exports.memoize)(\n  (items) => items.reduce((newValue, { item }, idx) => {\n    newValue[item] = {\n      layer: idx,\n      // 0-index layer\n      selection: items.length,\n      // 1 above all layers (selections are all at the same z-index)\n      actionMenu: items.length + idx + 1,\n      // 1 above all selections + layer\n      dragHandle: items.length * 2 + idx + 1\n      // 1 above all action menus + layer\n    };\n    return newValue;\n  }, {}),\n  // Only key the cache using the item IDs so position changes don't create new results.\n  // Use Array.prototype.join instead of JSON.stringify due to slightly better performance\n  (items) => items.map(({ item }) => item).join(\",\")\n);\nvar defaultContextValue = {};\nvar LayoutLayersContext = (0, react_exports.createContext)(defaultContextValue);\nvar LayoutLayersContextProvider = ({\n  children\n}) => {\n  const layoutStructure = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectLayoutStructure);\n  const contextValue = (0, react_exports.useMemo)(() => {\n    if (!Array.isArray(layoutStructure)) {\n      return defaultContextValue;\n    }\n    const validItems = layoutStructure.filter(isLayerableStructureItem);\n    if (validItems.length === 0) {\n      return defaultContextValue;\n    }\n    return convertToMemoizedContextValue(validItems);\n  }, [layoutStructure]);\n  return /* @__PURE__ */ react_default.createElement(LayoutLayersContext.Provider, { value: contextValue }, children);\n};\nvar useLayoutLayers = () => (0, react_exports.useContext)(LayoutLayersContext);\n\n// esm-externals:lodash/defaultsDeep\nvar defaultsDeep_exports = {};\n__export(defaultsDeep_exports, {\n  default: () => defaultsDeep_default\n});\nvar defaultImport28 = __toESM(require(\"lodash/defaultsDeep\"));\n__reExport(defaultsDeep_exports, require(\"lodash/defaultsDeep\"));\nvar defaultsDeep_default = \"default\" in defaultImport28 ? defaultImport28.default : defaultImport28;\n\n// esm-externals:lodash/cloneDeep\nvar cloneDeep_exports = {};\n__export(cloneDeep_exports, {\n  default: () => cloneDeep_default\n});\nvar defaultImport29 = __toESM(require(\"lodash/cloneDeep\"));\n__reExport(cloneDeep_exports, require(\"lodash/cloneDeep\"));\nvar cloneDeep_default = \"default\" in defaultImport29 ? defaultImport29.default : defaultImport29;\n\n// src/preset/Message.tsx\nvar centerDiv = styled_components_exports.css`\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n`;\nvar MessageContainer = styled_components_default.div`\n    ${(props) => props.centered ? centerDiv : null}\n    font-size: 15px;\n`;\nvar Message = ({\n  level = \"info\",\n  message = \"\",\n  centered = true\n}) => /* @__PURE__ */ react_default.createElement(MessageContainer, { \"data-test\": \"dashboard-message\", centered }, /* @__PURE__ */ react_default.createElement(Message_default, { type: level }, message));\nvar Message_default2 = Message;\n\n// src/preset/Preset.ts\nvar TooSmallToRenderContentMessage = (0, i18n_exports._)(\"Too small to render content\");\nvar TooSmallToRenderContentComponent = react_default.createElement(Message_default2, {\n  message: TooSmallToRenderContentMessage,\n  centered: false\n});\nvar noopHandler = {\n  canHandle: () => false,\n  handle: () => Promise.resolve([])\n};\nvar DEFAULT_RESIZE_HANDLE_DIRECTIONS = [\n  \"n\",\n  \"ne\",\n  \"e\",\n  \"se\",\n  \"s\",\n  \"sw\",\n  \"w\",\n  \"nw\"\n];\nvar DEFAULT_PRESET = {\n  visualizations: {},\n  inputs: {},\n  dataSources: {},\n  eventHandlers: {},\n  layouts: {}\n};\nvar Preset = class {\n  // eslint-disable-next-line class-methods-use-this\n  getDefaultPreset() {\n    return __spreadProps(__spreadValues({}, DEFAULT_PRESET), {\n      dataSources: __spreadProps(__spreadValues({}, DEFAULT_PRESET.dataSources), {\n        \"_ds.snapshot_\": this.SnapshotDataSource\n      })\n    });\n  }\n  normalize(preset) {\n    return defaultsDeep_default(preset, this.getDefaultPreset());\n  }\n  constructor({\n    presetDefinition = {},\n    featureFlags = {},\n    SnapshotDataSource: SnapshotDataSource2\n  }) {\n    this.SnapshotDataSource = SnapshotDataSource2;\n    this.presetDef = this.normalize(cloneDeep_default(presetDefinition));\n    if (featureFlags.enableSmartSourceDS) {\n      this.populateSmartSourceOptionsSchema();\n    }\n  }\n  /* eslint no-param-reassign: [\"error\", { \"props\": true, \"ignorePropertyModificationsFor\": [\"dsPreset\"] }] */\n  populateSmartSourceOptionsSchema() {\n    Object.values(this.presetDef.dataSources).forEach((dsPreset) => {\n      var _a;\n      if ((_a = dsPreset.config) == null ? void 0 : _a.optionsSchema) {\n        dsPreset.config.optionsSchema.enableSmartSources = {\n          type: \"boolean\",\n          description: `When enabled, this datasource can be referenced elsewhere in the dashboard with the $data source name:result.<field>$ syntax`\n        };\n      }\n    });\n  }\n  getPresetDefinition() {\n    return this.presetDef;\n  }\n  findVisualization(type) {\n    return this.presetDef.visualizations[type];\n  }\n  findDataSource(type) {\n    return this.presetDef.dataSources[type];\n  }\n  findInput(type) {\n    return this.presetDef.inputs[type];\n  }\n  findItem(type, layoutType) {\n    return layoutType === \"block\" ? this.findVisualization(type) : this.findInput(type);\n  }\n  findEventHandler(type) {\n    return this.presetDef.eventHandlers[type];\n  }\n  findLayout(type) {\n    return this.presetDef.layouts[type];\n  }\n  getLayoutConfig(type) {\n    var _a;\n    return (_a = this.presetDef.layouts[type]) == null ? void 0 : _a.config;\n  }\n  /**\n   * Gets a name from a DS definition using getDataSourceName\n   * from the static configuration of the data source implementation\n   * @param {DataSourceDefinition} [definition] Data source definition\n   * @returns {string | undefined} Data source name if available else undefined\n   */\n  getDataSourceName(definition) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    let dsType = definition == null ? void 0 : definition.type;\n    let dsDef = definition;\n    if (!dsType || !dsDef) {\n      return void 0;\n    }\n    if (dsType === \"_ds.snapshot_\") {\n      const dsMeta = (_b = (_a = definition == null ? void 0 : definition.options) == null ? void 0 : _a.meta) != null ? _b : {};\n      dsDef = (_c = dsMeta.originalDefinition) != null ? _c : {};\n      dsType = dsDef.type;\n    }\n    return (_g = (_f = (_e = (_d = this.presetDef.dataSources[dsType]) == null ? void 0 : _d.config) == null ? void 0 : _e.getDataSourceName) == null ? void 0 : _f.call(_e, {\n      dataSource: dsDef\n    })) != null ? _g : dsDef.name;\n  }\n  getPlaceholderIcon(type) {\n    var _a;\n    const vizConfig = (_a = this.presetDef.visualizations[type]) == null ? void 0 : _a.config;\n    return (vizConfig == null ? void 0 : vizConfig.placeholderIcon) || (vizConfig == null ? void 0 : vizConfig.icon);\n  }\n  getDataContract(type, layoutType) {\n    var _a, _b;\n    if (!type || !layoutType) {\n      return null;\n    }\n    const item = this.findItem(type, layoutType);\n    if (!item) {\n      return null;\n    }\n    return (_b = (_a = item.config) == null ? void 0 : _a.dataContract) != null ? _b : null;\n  }\n  getVisualizationDataContract(type) {\n    return this.getDataContract(type, \"block\");\n  }\n  getInputDataContract(type) {\n    return this.getDataContract(type, \"input\");\n  }\n  getOptionsSchema(type, layoutType) {\n    var _a, _b;\n    if (!type || !layoutType) {\n      return null;\n    }\n    const item = this.findItem(type, layoutType);\n    if (!item) {\n      return null;\n    }\n    return (_b = (_a = item.config) == null ? void 0 : _a.optionsSchema) != null ? _b : null;\n  }\n  getVisualizationOptionsSchema(type) {\n    return this.getOptionsSchema(type, \"block\");\n  }\n  getInputOptionsSchema(type) {\n    return this.getOptionsSchema(type, \"input\");\n  }\n  getEditorConfig(type, layoutType) {\n    var _a, _b;\n    if (!type || !layoutType) {\n      return null;\n    }\n    const item = this.findItem(type, layoutType);\n    if (!item) {\n      return null;\n    }\n    return (_b = (_a = item.config) == null ? void 0 : _a.editorConfig) != null ? _b : null;\n  }\n  getVisualizationEditorConfig(type) {\n    return this.getEditorConfig(type, \"block\");\n  }\n  getInputEditorConfig(type) {\n    return this.getEditorConfig(type, \"input\");\n  }\n  getVisualizationInitialOptions(type) {\n    var _a, _b, _c, _d;\n    if (!type) {\n      return {};\n    }\n    const item = this.findVisualization(type);\n    if (!item) {\n      return {};\n    }\n    return (_d = (_c = (_a = item.meta) == null ? void 0 : _a.initialOptions) != null ? _c : (_b = item.config) == null ? void 0 : _b.baseShape) != null ? _d : {};\n  }\n  getDrilldownOptions(type) {\n    var _a;\n    const item = this.findVisualization(type) || this.findInput(type);\n    return {\n      canSetCustomUrl: item == null ? void 0 : item.canSetCustomUrl,\n      canSetTokens: (_a = item == null ? void 0 : item.canSetTokens) != null ? _a : [],\n      canResetTokens: item == null ? void 0 : item.canResetTokens,\n      canSwitchToTab: item == null ? void 0 : item.canSwitchToTab,\n      canSetTimeRange: item == null ? void 0 : item.canSetTimeRange\n    };\n  }\n  /**\n   * create visualization component\n   * @param {*} type visualization type\n   * @param {*} props computed react props\n   */\n  createVisualization(type, props) {\n    try {\n      const VizImplementation = this.findVisualization(type);\n      if (!VizImplementation) {\n        throw new Error((0, i18n_exports._)(`${type} is not defined`));\n      }\n      return react_default.createElement(\n        VizImplementation,\n        __spreadProps(__spreadValues({}, props), {\n          type\n        })\n      );\n    } catch (ex) {\n      return react_default.createElement(Message_default2, {\n        level: \"error\",\n        message: ex.message\n      });\n    }\n  }\n  /**\n   * Determine if preset class recommends displaying a title and description\n   * @param {String} type Visualization type, e.g. ('viz.singlevalue')\n   */\n  shouldDisplayVisualizationSiblingContent(type) {\n    const Viz = this.findVisualization(type);\n    return {\n      showTitleAndDescription: !!(Viz == null ? void 0 : Viz.showTitleAndDescription),\n      showProgressBar: !!(Viz == null ? void 0 : Viz.showProgressBar),\n      showLastUpdated: !!(Viz == null ? void 0 : Viz.showLastUpdated)\n    };\n  }\n  /**\n   * Get flags from preset for viz or input\n   * @param {String} type Item Type 'splunk.singlevalue'\n   */\n  shouldDisplaySiblingContent(type, itemLayoutType) {\n    const Item = itemLayoutType === \"block\" ? this.findVisualization(type) : this.findInput(type);\n    return {\n      showTitleAndDescription: !!(Item == null ? void 0 : Item.showTitleAndDescription),\n      showProgressBar: !!(Item == null ? void 0 : Item.showProgressBar),\n      showLastUpdated: !!(Item == null ? void 0 : Item.showLastUpdated)\n    };\n  }\n  shouldShowDrilldown(type) {\n    const Input = this.findInput(type);\n    const Viz = this.findVisualization(type);\n    return !!(Input == null ? void 0 : Input.showDrilldown) || !!(Viz == null ? void 0 : Viz.showDrilldown);\n  }\n  shouldShowCornerRadiusEditor({\n    itemType,\n    layoutType = \"block\"\n  }) {\n    var _a;\n    return !!((_a = this.findItem(itemType, layoutType)) == null ? void 0 : _a.showCornerRadiusEditor);\n  }\n  shouldShowDragHandle(type) {\n    const Input = this.findInput(type);\n    const Viz = this.findVisualization(type);\n    return !!Input || !!(Viz == null ? void 0 : Viz.showDragHandle);\n  }\n  shouldShowInputTitle(type) {\n    const item = this.findItem(type, \"input\");\n    if (typeof (item == null ? void 0 : item.config) === \"undefined\") {\n      return false;\n    }\n    return item.config.showTitle !== false;\n  }\n  getResizeHandleDirections(type) {\n    var _a, _b;\n    if (!type) {\n      return DEFAULT_RESIZE_HANDLE_DIRECTIONS;\n    }\n    const inputHandleDirections = (_a = this.findInput(type)) == null ? void 0 : _a.handleDirections;\n    if (Array.isArray(inputHandleDirections)) {\n      return inputHandleDirections;\n    }\n    const vizHandleDirections = (_b = this.findVisualization(type)) == null ? void 0 : _b.handleDirections;\n    if (Array.isArray(vizHandleDirections)) {\n      return vizHandleDirections;\n    }\n    return DEFAULT_RESIZE_HANDLE_DIRECTIONS;\n  }\n  /**\n   * Determine if the dashboard item, in the current dashboard mode, can render an action menu\n   * @param {Mode} args.mode Current dashboard mode (view or edit)\n   * @param {LayoutItemType} args.layoutItemType Type of the dashboard item (block or input)\n   */\n  // eslint-disable-next-line class-methods-use-this\n  shouldShowActionMenu({\n    mode,\n    layoutItemType\n  }) {\n    return mode !== \"view\" || layoutItemType !== \"input\";\n  }\n  /**\n   * Determine if a layout should initialize with `showGridLines = true`\n   * @param {string} type the layout type\n   */\n  shouldShowInitialGrid(type) {\n    var _a;\n    return !!((_a = this.findLayout(type)) == null ? void 0 : _a.initialShowGrid);\n  }\n  /**\n   * instantiate datasource\n   * @param {*} type datasource type\n   * @param {*} options datasource options\n   * @param {*} dataSourceContext  datasource context\n   * @param {*} meta metadata\n   * @param {*} id datasource id\n   */\n  createDataSource(type, options, dataSourceContext, meta, id, baseChainModel) {\n    try {\n      const DSImplementation = this.findDataSource(type);\n      if (!DSImplementation) {\n        throw new Error((0, i18n_exports._)(`${type} is not defined`));\n      }\n      return new DSImplementation(\n        options,\n        __spreadProps(__spreadValues({}, dataSourceContext), { id }),\n        meta,\n        baseChainModel\n      );\n    } catch (ex) {\n      return new this.SnapshotDataSource({\n        errorLevel: \"error\",\n        error: ex.message\n      });\n    }\n  }\n  /**\n   * instantiate input component\n   * @param {*} type\n   * @param {*} props\n   */\n  createInput(type, props) {\n    var _a, _b, _c, _d;\n    try {\n      const InputImplementation = this.findInput(type);\n      if (!InputImplementation) {\n        throw new Error((0, i18n_exports._)(`${type} is not defined`));\n      }\n      if (typeof props.width === \"number\" && ((_b = (_a = InputImplementation.minimumSize) == null ? void 0 : _a.width) != null ? _b : 0) > props.width) {\n        return TooSmallToRenderContentComponent;\n      }\n      if (typeof props.height === \"number\" && ((_d = (_c = InputImplementation.minimumSize) == null ? void 0 : _c.height) != null ? _d : 0) > props.height) {\n        return TooSmallToRenderContentComponent;\n      }\n      return react_default.createElement(\n        InputImplementation,\n        __spreadProps(__spreadValues({}, props), {\n          type\n        })\n      );\n    } catch (ex) {\n      return react_default.createElement(Message_default2, {\n        level: \"error\",\n        message: ex.message,\n        centered: false\n      });\n    }\n  }\n  /**\n   * instantiate event handlers\n   * @param {*} type\n   * @param {*} options\n   */\n  createEventHandler(type, options) {\n    try {\n      const EventHandlerImplementation = this.findEventHandler(type);\n      if (!EventHandlerImplementation) {\n        throw new ReferenceError((0, i18n_exports._)(`${type} is not defined`));\n      }\n      const handler = new EventHandlerImplementation(options);\n      if (typeof handler.canHandle !== \"function\" || typeof handler.handle !== \"function\") {\n        throw new TypeError((0, i18n_exports._)(`${type} is not a valid event handler`));\n      }\n      return handler;\n    } catch (ex) {\n      return noopHandler;\n    }\n  }\n  /**\n   * instantiate layout component\n   * @param {*} type\n   * @param {*} props\n   */\n  createLayout(type, props) {\n    try {\n      const LayoutImplementation = this.findLayout(type);\n      if (!LayoutImplementation) {\n        throw new Error((0, i18n_exports._)(`${type} is not defined`));\n      }\n      return react_default.createElement(\n        LayoutImplementation,\n        __spreadProps(__spreadValues({}, props), {\n          type\n        })\n      );\n    } catch (ex) {\n      return react_default.createElement(Message_default2, {\n        level: \"error\",\n        message: ex.message\n      });\n    }\n  }\n};\n\n// src/utils/presetUtils.jsx\nvar withVizConfig = (Viz, key) => {\n  if (Viz.config) {\n    return Viz;\n  }\n  const { dataContract = {}, editor = [], schema = {} } = Viz;\n  Viz.config = {\n    dataContract,\n    editorConfig: editor,\n    optionsSchema: schema,\n    key\n  };\n  if (Viz.meta) {\n    const { label: name, icon, category, key: metaKey } = Viz.meta;\n    Viz.config = __spreadProps(__spreadValues({}, Viz.config), {\n      key: metaKey != null ? metaKey : Viz.config.key,\n      name,\n      icon,\n      category\n    });\n  }\n  return Viz;\n};\nvar withInputConfig = (Input) => {\n  if (Input.config) {\n    return Input;\n  }\n  const { dataContract = {}, editor = [], schema = {}, meta } = Input;\n  Input.config = {\n    dataContract,\n    editorConfig: editor,\n    optionsSchema: schema\n  };\n  if (meta) {\n    Input.config = __spreadValues(__spreadValues({}, Input.config), (0, lodash_exports.mapKeys)(\n      meta,\n      (_value, key) => key === \"defaultConfig\" ? \"baseShape\" : key\n    ));\n  }\n  return Input;\n};\nvar updatePreset = (preset) => {\n  const { visualizations, inputs } = preset;\n  return __spreadProps(__spreadValues({}, preset), {\n    visualizations: (0, lodash_exports.mapValues)(visualizations != null ? visualizations : {}, withVizConfig),\n    inputs: (0, lodash_exports.mapValues)(inputs != null ? inputs : {}, withInputConfig)\n  });\n};\nvar vizCategories = /* @__PURE__ */ new Map([\n  [\"table\", \"Table\"],\n  [\"singleValue\", \"Single Value\"],\n  [\"trends\", \"Trends\"],\n  [\"comparisons\", \"Comparisons\"],\n  [\"correlation\", \"Correlation\"],\n  [\"gauge\", \"Gauge\"],\n  [\"distributions\", \"Distributions\"],\n  [\"spatial\", \"Spatial\"],\n  [\"choropleth\", \"Choropleth Maps\"],\n  [\"image\", \"Image\"],\n  [\"text\", \"Text\"],\n  [\"shapes\", \"Shapes\"],\n  [\"flow\", \"Flow\"]\n]);\n\n// src/SidebarContext.tsx\nvar SidebarContext = (0, react_exports.createContext)(null);\nvar SidebarContextProvider = ({\n  children\n}) => {\n  const [collapsibleState, setCollapsibleState] = (0, react_exports.useState)({});\n  const onCollapsibleOpen = (0, react_exports.useCallback)(\n    (label) => setCollapsibleState((prevState) => __spreadProps(__spreadValues({}, prevState), {\n      [label]: true\n    })),\n    []\n  );\n  const onCollapsibleClose = (0, react_exports.useCallback)(\n    (label) => setCollapsibleState((prevState) => __spreadProps(__spreadValues({}, prevState), {\n      [label]: false\n    })),\n    []\n  );\n  const contextValue = (0, react_exports.useMemo)(\n    () => ({\n      collapsibleState,\n      onCollapsibleOpen,\n      onCollapsibleClose\n    }),\n    [collapsibleState, onCollapsibleClose, onCollapsibleOpen]\n  );\n  return /* @__PURE__ */ react_default.createElement(SidebarContext.Provider, { value: contextValue }, children);\n};\nvar useSidebarContext = () => (0, react_exports.useContext)(SidebarContext);\n\n// esm-externals:@splunk/datasource-utils\nvar datasource_utils_exports = {};\n__export(datasource_utils_exports, {\n  default: () => datasource_utils_default\n});\nvar defaultImport30 = __toESM(require(\"@splunk/datasource-utils\"));\n__reExport(datasource_utils_exports, require(\"@splunk/datasource-utils\"));\nvar datasource_utils_default = \"default\" in defaultImport30 ? defaultImport30.default : defaultImport30;\n\n// src/utils/constants.ts\nvar UnboundSmartSourceConsumerId = \"<smart_source>\";\nvar UnboundSmartSourceBindingType = \"unbound\";\nvar UnboundSmartSourceRequestParams = { count: 1 };\n\n// src/utils/getConsumerId.ts\nvar getConsumerId = ({\n  consumerId,\n  bindingType\n}) => `${consumerId}-${bindingType}`;\n\n// src/utils/getSearchesToExecute.ts\nvar findSearchesToExecute = ({\n  items,\n  dataSources,\n  result,\n  itemToLayoutMap\n}) => {\n  if (!items) {\n    return;\n  }\n  Object.keys(items).forEach((itemId) => {\n    const { dataSources: itemBindings } = items[itemId];\n    if (!itemBindings) {\n      return;\n    }\n    Object.keys(itemBindings).forEach((bindingType) => {\n      var _a;\n      const dsId = itemBindings[bindingType];\n      if (typeof (dataSources == null ? void 0 : dataSources[dsId]) === \"undefined\") {\n        return;\n      }\n      const layouts = (_a = itemToLayoutMap[itemId]) != null ? _a : [];\n      layouts.forEach((layoutId) => {\n        var _a2, _b, _c, _d, _e;\n        (_a2 = result[layoutId]) != null ? _a2 : result[layoutId] = {};\n        (_c = (_b = result[layoutId])[dsId]) != null ? _c : _b[dsId] = {};\n        (_e = (_d = result[layoutId][dsId])[itemId]) != null ? _e : _d[itemId] = [];\n        result[layoutId][dsId][itemId].push(bindingType);\n      });\n    });\n  });\n};\nvar getSearchesToExecute = ({\n  dataSources,\n  inputs,\n  visualizations,\n  featureFlags,\n  itemToLayoutMap,\n  globalSearchesId\n}) => {\n  const searchesToExecuteByLayout = {};\n  findSearchesToExecute({\n    items: visualizations,\n    dataSources,\n    result: searchesToExecuteByLayout,\n    itemToLayoutMap\n  });\n  findSearchesToExecute({\n    items: inputs,\n    dataSources,\n    result: searchesToExecuteByLayout,\n    itemToLayoutMap\n  });\n  if ((featureFlags == null ? void 0 : featureFlags.enableSmartSourceDS) && dataSources) {\n    Object.keys(dataSources).forEach((dsId) => {\n      var _a, _b;\n      if (dsId in ((_a = searchesToExecuteByLayout[globalSearchesId]) != null ? _a : {})) {\n        return;\n      }\n      const { options } = dataSources[dsId];\n      if (options == null ? void 0 : options.enableSmartSources) {\n        (_b = searchesToExecuteByLayout[globalSearchesId]) != null ? _b : searchesToExecuteByLayout[globalSearchesId] = {};\n        searchesToExecuteByLayout[globalSearchesId][dsId] = {\n          [UnboundSmartSourceConsumerId]: [\n            UnboundSmartSourceBindingType\n          ]\n        };\n      }\n    });\n  }\n  return searchesToExecuteByLayout;\n};\n\n// src/utils/SearchManager.ts\nvar forEachSearchBinding = (searches, callback) => {\n  Object.entries(searches).forEach(([dsId, bindings]) => {\n    Object.entries(bindings).forEach(\n      ([consumerId, bindingTypes]) => callback({\n        dsId,\n        consumerId,\n        bindingTypes\n      })\n    );\n  });\n};\nvar isItemInCachedLayout = ({\n  cachedLayoutIds,\n  itemId,\n  itemToLayoutMap,\n  currentLayoutId\n}) => {\n  var _a;\n  const itemLayouts = (_a = itemToLayoutMap[itemId]) != null ? _a : [];\n  if (itemLayouts.length === 1 && itemLayouts[0] === currentLayoutId) {\n    return false;\n  }\n  return itemLayouts.some((id) => cachedLayoutIds.has(id));\n};\nvar getBindingDifferences = ({\n  bindingTypes,\n  previousBindingTypes\n}) => {\n  const added = [];\n  const existing = [];\n  const removed = [];\n  bindingTypes.forEach((bindingType) => {\n    if (previousBindingTypes.includes(bindingType)) {\n      existing.push(bindingType);\n    } else {\n      added.push(bindingType);\n    }\n  });\n  previousBindingTypes.forEach((previousBindingType) => {\n    if (!bindingTypes.includes(previousBindingType)) {\n      removed.push(previousBindingType);\n    }\n  });\n  return { added, existing, removed };\n};\nvar SearchManager = class {\n  constructor() {\n    this.previousSearchesToExecuteByLayout = {};\n    this.previousDataSourcesByLayout = {};\n  }\n  manageSearches({\n    searchesToExecuteByLayout,\n    dataSourceDefinitions,\n    activeLayoutIds,\n    itemToLayoutMap,\n    cachedLayoutIds\n  }) {\n    const searchesToCreate = {};\n    const searchesToRemove = {};\n    const searchesToUpdate = {};\n    activeLayoutIds.forEach((layoutId) => {\n      var _a;\n      const searchesToExecuteForLayout = (_a = searchesToExecuteByLayout[layoutId]) != null ? _a : {};\n      const previousSearchesToExecuteForLayout = this.previousSearchesToExecuteByLayout[layoutId];\n      const previousDataSourcesForLayout = this.previousDataSourcesByLayout[layoutId];\n      forEachSearchBinding(\n        searchesToExecuteForLayout,\n        ({ dsId, consumerId, bindingTypes }) => {\n          var _a2, _b, _c, _d, _e;\n          const previousBindingTypes = (_b = (_a2 = previousSearchesToExecuteForLayout == null ? void 0 : previousSearchesToExecuteForLayout[dsId]) == null ? void 0 : _a2[consumerId]) != null ? _b : [];\n          const { added, existing, removed } = getBindingDifferences({\n            bindingTypes,\n            previousBindingTypes\n          });\n          if (added.length) {\n            (_c = searchesToCreate[dsId]) != null ? _c : searchesToCreate[dsId] = {};\n            searchesToCreate[dsId][consumerId] = added;\n          }\n          if (removed.length && !isItemInCachedLayout({\n            cachedLayoutIds,\n            itemId: consumerId,\n            itemToLayoutMap,\n            currentLayoutId: layoutId\n          })) {\n            (_d = searchesToRemove[dsId]) != null ? _d : searchesToRemove[dsId] = {};\n            searchesToRemove[dsId][consumerId] = removed;\n          }\n          const prevDS = (0, dashboard_search_exports.computeStableDSDefinition)(\n            previousDataSourcesForLayout == null ? void 0 : previousDataSourcesForLayout[dsId]\n          );\n          const currentDS = (0, dashboard_search_exports.computeStableDSDefinition)(\n            dataSourceDefinitions == null ? void 0 : dataSourceDefinitions[dsId]\n          );\n          if (existing.length && !(0, lodash_exports.isEqual)(prevDS, currentDS)) {\n            (_e = searchesToUpdate[dsId]) != null ? _e : searchesToUpdate[dsId] = {};\n            searchesToUpdate[dsId][consumerId] = existing;\n          }\n        }\n      );\n      forEachSearchBinding(\n        previousSearchesToExecuteForLayout != null ? previousSearchesToExecuteForLayout : {},\n        ({ dsId, consumerId, bindingTypes }) => {\n          var _a2, _b;\n          if (typeof ((_a2 = searchesToExecuteForLayout[dsId]) == null ? void 0 : _a2[consumerId]) === \"undefined\" && !isItemInCachedLayout({\n            cachedLayoutIds,\n            itemId: consumerId,\n            itemToLayoutMap,\n            currentLayoutId: layoutId\n          })) {\n            (_b = searchesToRemove[dsId]) != null ? _b : searchesToRemove[dsId] = {};\n            searchesToRemove[dsId][consumerId] = bindingTypes;\n          }\n        }\n      );\n    });\n    activeLayoutIds.forEach((layoutId) => {\n      this.previousSearchesToExecuteByLayout[layoutId] = searchesToExecuteByLayout[layoutId];\n      this.previousDataSourcesByLayout[layoutId] = dataSourceDefinitions;\n    });\n    return {\n      searchesToCreate,\n      searchesToRemove,\n      searchesToUpdate\n    };\n  }\n  removeLayoutsFromCache({\n    layoutIds,\n    itemToLayoutMap,\n    cachedLayoutIds\n  }) {\n    const searchesToRemove = {};\n    layoutIds.forEach((layoutId) => {\n      var _a;\n      forEachSearchBinding(\n        (_a = this.previousSearchesToExecuteByLayout[layoutId]) != null ? _a : {},\n        ({ dsId, consumerId, bindingTypes }) => {\n          var _a2;\n          if (!isItemInCachedLayout({\n            cachedLayoutIds,\n            itemId: consumerId,\n            itemToLayoutMap,\n            currentLayoutId: layoutId\n          })) {\n            (_a2 = searchesToRemove[dsId]) != null ? _a2 : searchesToRemove[dsId] = {};\n            searchesToRemove[dsId][consumerId] = bindingTypes;\n          }\n        }\n      );\n      delete this.previousDataSourcesByLayout[layoutId];\n      delete this.previousSearchesToExecuteByLayout[layoutId];\n    });\n    return searchesToRemove;\n  }\n};\n\n// src/SearchProvider.ts\nvar SearchProvider = class {\n  constructor({\n    searchModule\n  }) {\n    this.data = {};\n    this.subscriptions = {};\n    this.subscribers = {};\n    this.searchModule = searchModule;\n  }\n  handleUpdateSubscribers({\n    dsId,\n    consumerId,\n    bindingType,\n    payload\n  }) {\n    var _a, _b, _c, _d;\n    const augmentedConsumerId = getConsumerId({\n      consumerId,\n      bindingType\n    });\n    (_b = (_a = this.data)[dsId]) != null ? _b : _a[dsId] = {};\n    this.data[dsId][augmentedConsumerId] = payload;\n    const subs = (_d = (_c = this.subscribers[dsId]) == null ? void 0 : _c[augmentedConsumerId]) != null ? _d : {};\n    Object.values(subs).forEach((onUpdate) => {\n      onUpdate(payload);\n    });\n  }\n  handleDataFactory(arg0) {\n    return (data) => this.handleUpdateSubscribers(__spreadProps(__spreadValues({}, arg0), { payload: data }));\n  }\n  handleErrorFactory(arg0) {\n    return ({ meta, level, message }) => this.handleUpdateSubscribers(__spreadProps(__spreadValues({}, arg0), {\n      payload: { error: { level, message }, meta }\n    }));\n  }\n  createSearch(_0) {\n    return __async(this, arguments, function* ({\n      dsId,\n      consumerId,\n      bindingType,\n      initialRequestParams\n    }) {\n      var _a, _b;\n      const handleError = this.handleErrorFactory({\n        dsId,\n        consumerId,\n        bindingType\n      });\n      try {\n        const augmentedConsumerId = getConsumerId({\n          consumerId,\n          bindingType\n        });\n        const sub = yield this.searchModule.create({\n          consumerId: augmentedConsumerId,\n          dataSourceId: dsId,\n          onData: this.handleDataFactory({\n            dsId,\n            consumerId,\n            bindingType\n          }),\n          onError: handleError,\n          initialRequestParams\n        });\n        (_b = (_a = this.subscriptions)[dsId]) != null ? _b : _a[dsId] = {};\n        this.subscriptions[dsId][augmentedConsumerId] = sub;\n      } catch (error) {\n        if (error instanceof Error) {\n          handleError({\n            level: \"error\",\n            message: error.message\n          });\n        }\n      }\n    });\n  }\n  updateSearch(_0) {\n    return __async(this, arguments, function* ({\n      dsId,\n      consumerId,\n      bindingType,\n      initialRequestParams\n    }) {\n      const augmentedConsumerId = getConsumerId({\n        consumerId,\n        bindingType\n      });\n      try {\n        const sub = this.subscriptions[dsId][augmentedConsumerId];\n        this.subscriptions[dsId][augmentedConsumerId] = yield this.searchModule.update({\n          consumerId: augmentedConsumerId,\n          dataSourceId: dsId,\n          subscription: sub,\n          initialRequestParams\n        });\n      } catch (error) {\n        if (error instanceof Error) {\n          this.handleErrorFactory({\n            dsId,\n            consumerId,\n            bindingType\n          })({\n            level: \"error\",\n            message: error.message\n          });\n        }\n      }\n    });\n  }\n  removeSearch({ dsId, consumerId, bindingType }) {\n    var _a, _b, _c, _d, _e;\n    const augmentedConsumerId = getConsumerId({\n      consumerId,\n      bindingType\n    });\n    const subscription = (_a = this.subscriptions[dsId]) == null ? void 0 : _a[augmentedConsumerId];\n    if (subscription) {\n      this.searchModule.cancel({ subscription });\n    }\n    (_b = this.subscriptions[dsId]) == null ? true : delete _b[augmentedConsumerId];\n    if (!Object.keys((_c = this.subscriptions[dsId]) != null ? _c : {}).length) {\n      delete this.subscriptions[dsId];\n    }\n    (_d = this.data[dsId]) == null ? true : delete _d[augmentedConsumerId];\n    if (!Object.keys((_e = this.data[dsId]) != null ? _e : {}).length) {\n      delete this.data[dsId];\n    }\n  }\n  teardown() {\n    Object.values(this.subscriptions).forEach((bindings) => {\n      Object.values(bindings).forEach((subscription) => {\n        this.searchModule.cancel({ subscription });\n      });\n    });\n  }\n  createSearchAndSubscribe({\n    dsId,\n    consumerId,\n    bindingType,\n    initialRequestParams,\n    subscriberId,\n    onUpdate\n  }) {\n    var _a;\n    const augmentedConsumerId = getConsumerId({\n      consumerId,\n      bindingType\n    });\n    if (typeof ((_a = this.subscriptions[dsId]) == null ? void 0 : _a[augmentedConsumerId]) !== \"undefined\") {\n      throw new Error(\n        `${(0, i18n_exports._)(\"The search\")} ${dsId} ${(0, i18n_exports._)(\n          \"created for consumerId\"\n        )} ${consumerId} ${(0, i18n_exports._)(\"and bindingType\")} ${bindingType} ${(0, i18n_exports._)(\n          \"already exists. In order to avoid a memory leak, unsubscribe and cancel the existing search before creating it again.\"\n        )}`\n      );\n    }\n    const unsubscribe = this.subscribe({\n      dsId,\n      consumerId,\n      bindingType,\n      subscriberId,\n      onUpdate\n    });\n    this.createSearch({\n      dsId,\n      consumerId,\n      bindingType,\n      initialRequestParams\n    });\n    return () => {\n      unsubscribe();\n      this.removeSearch({ dsId, consumerId, bindingType });\n    };\n  }\n  subscribe({\n    dsId,\n    consumerId,\n    bindingType,\n    subscriberId,\n    onUpdate\n  }) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const augmentedConsumerId = getConsumerId({\n      consumerId,\n      bindingType\n    });\n    if (typeof ((_b = (_a = this.subscribers[dsId]) == null ? void 0 : _a[augmentedConsumerId]) == null ? void 0 : _b[subscriberId]) !== \"undefined\") {\n      throw new Error(\n        `${subscriberId} ${(0, i18n_exports._)(\n          \"is already to subscribed to\"\n        )} ${dsId}. ${(0, i18n_exports._)(\n          \"Overwriting the subscription without first cancelling it will cause a memory leak. Please unsubscribe before resubscribing again or provide a different subscriberId.\"\n        )}`\n      );\n    }\n    (_d = (_c = this.subscribers)[dsId]) != null ? _d : _c[dsId] = {};\n    (_f = (_e = this.subscribers[dsId])[augmentedConsumerId]) != null ? _f : _e[augmentedConsumerId] = {};\n    this.subscribers[dsId][augmentedConsumerId][subscriberId] = onUpdate;\n    const data = (_g = this.data[dsId]) == null ? void 0 : _g[augmentedConsumerId];\n    if (data) {\n      onUpdate(data);\n    }\n    return () => {\n      delete this.subscribers[dsId][augmentedConsumerId][subscriberId];\n      if (!Object.keys(this.subscribers[dsId][augmentedConsumerId]).length) {\n        delete this.subscribers[dsId][augmentedConsumerId];\n      }\n      if (!Object.keys(this.subscribers[dsId]).length) {\n        delete this.subscribers[dsId];\n      }\n    };\n  }\n  refresh({ consumerId, bindingType, dsId, options }) {\n    var _a, _b, _c, _d;\n    const augmentedConsumerId = getConsumerId({\n      consumerId,\n      bindingType\n    });\n    (_c = (_b = (_a = this.subscriptions[dsId]) == null ? void 0 : _a[augmentedConsumerId]) == null ? void 0 : _b.refresh) == null ? void 0 : _c.call(_b, options);\n    Object.entries((_d = this.subscribers[dsId]) != null ? _d : {}).forEach(\n      ([subscriberId, dsSubscribers]) => {\n        if (subscriberId === augmentedConsumerId) {\n          return;\n        }\n        Object.values(dsSubscribers).forEach((onUpdate) => {\n          onUpdate({\n            data: { columns: [], fields: [] },\n            error: void 0,\n            meta: { status: \"refreshing\" },\n            requestParams: void 0\n          });\n        });\n      }\n    );\n  }\n  control(_0) {\n    return __async(this, arguments, function* ({\n      consumerId,\n      bindingType,\n      dsId,\n      action\n    }) {\n      var _a, _b, _c, _e;\n      const augmentedConsumerId = getConsumerId({\n        consumerId,\n        bindingType\n      });\n      const sub = (_a = this.subscriptions[dsId]) == null ? void 0 : _a[augmentedConsumerId];\n      if (!(sub == null ? void 0 : sub.supportsControlActions())) {\n        return;\n      }\n      const subIsPaused = action !== \"pause\" && sub.getPauseStatus();\n      const nextStatus = subIsPaused ? \"running\" : \"pause\";\n      yield sub.control(action);\n      const _d = (_c = (_b = this.data[dsId]) == null ? void 0 : _b[augmentedConsumerId]) != null ? _c : {}, { meta = {} } = _d, searchDataOrError = __objRest(_d, [\"meta\"]);\n      const onUpdatePayload = __spreadProps(__spreadValues({\n        data: { columns: [], fields: [] },\n        error: void 0,\n        requestParams: void 0\n      }, searchDataOrError), {\n        meta: __spreadProps(__spreadValues({}, meta), { status: nextStatus })\n      });\n      Object.values((_e = this.subscribers[dsId]) != null ? _e : {}).forEach((dsSubscribers) => {\n        Object.values(dsSubscribers).forEach((onUpdate) => {\n          onUpdate(onUpdatePayload);\n        });\n      });\n    });\n  }\n  updateRequestParams({\n    consumerId,\n    dsId,\n    bindingType,\n    requestParams\n  }) {\n    var _a, _b;\n    const augmentedConsumerId = getConsumerId({\n      consumerId,\n      bindingType\n    });\n    const sub = (_a = this.subscriptions[dsId]) == null ? void 0 : _a[augmentedConsumerId];\n    if (!sub) {\n      return;\n    }\n    (_b = sub.updateRequestParams) == null ? void 0 : _b.call(sub, requestParams);\n  }\n};\n\n// src/SearchContext.tsx\nvar DefaultSearchContextValue = {\n  subscribe: () => dashboard_utils_exports.noop,\n  refresh: dashboard_utils_exports.noop,\n  control: dashboard_utils_exports.noop,\n  updateRequestParams: dashboard_utils_exports.noop,\n  createSearchAndSubscribe: () => dashboard_utils_exports.noop\n};\nvar SearchContext = (0, react_exports.createContext)(\n  DefaultSearchContextValue\n);\nvar SearchContextProvider = ({\n  children,\n  getSearchesToExecute: getSearchesToExecute2 = getSearchesToExecute,\n  searchModule: SearchModule = dashboard_search_exports.SearchModule\n}) => {\n  const featureFlags = useFeatureFlags();\n  const preset = usePreset();\n  const dataSourceRegistry = useDataSourceRegistry();\n  const dataSourceDefinitions = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectDataSourceDefinitions);\n  const visualizations = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectVisualizations);\n  const inputs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectInputs);\n  const layout = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectRootLayoutObject);\n  const searchProviderRef = (0, react_exports.useRef)();\n  if (!searchProviderRef.current) {\n    searchProviderRef.current = new SearchProvider({\n      searchModule: new SearchModule({ registry: dataSourceRegistry })\n    });\n  }\n  const { definition, definitionClass } = (0, react_exports.useMemo)(() => {\n    const def = {\n      dataSources: dataSourceDefinitions,\n      visualizations,\n      inputs,\n      layout\n    };\n    return {\n      definition: def,\n      definitionClass: dashboard_definition_exports.DashboardDefinition.fromJSON(def)\n    };\n  }, [dataSourceDefinitions, inputs, visualizations, layout]);\n  const globalSearchesId = (0, react_exports.useMemo)(() => `global_searches_${(0, dashboard_utils_exports.uniqueId)()}`, []);\n  const itemToLayoutMap = (0, react_exports.useMemo)(\n    () => definitionClass.getItemToLayoutMap({\n      globalSearchesId\n    }),\n    [globalSearchesId, definitionClass]\n  );\n  const searchesToExecuteByLayout = (0, react_exports.useMemo)(\n    () => getSearchesToExecute2({\n      dataSources: definition.dataSources,\n      inputs: definition.inputs,\n      visualizations: definition.visualizations,\n      featureFlags,\n      itemToLayoutMap,\n      globalSearchesId\n    }),\n    [\n      definition.dataSources,\n      definition.inputs,\n      definition.visualizations,\n      featureFlags,\n      getSearchesToExecute2,\n      globalSearchesId,\n      itemToLayoutMap\n    ]\n  );\n  const activeTab = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectActiveTab);\n  const searchManager = (0, react_exports.useMemo)(() => new SearchManager(), []);\n  const activeLayoutIds = (0, react_exports.useMemo)(() => {\n    const ids = [globalSearchesId];\n    if (activeTab) {\n      ids.push(activeTab);\n    }\n    return ids;\n  }, [activeTab, globalSearchesId]);\n  const cachedLayoutIds = (0, react_exports.useRef)();\n  const layoutIdsToRemoveFromCache = (0, react_exports.useMemo)(() => {\n    var _a;\n    (_a = cachedLayoutIds.current) != null ? _a : cachedLayoutIds.current = /* @__PURE__ */ new Set();\n    if (typeof searchesToExecuteByLayout[globalSearchesId] !== \"undefined\") {\n      cachedLayoutIds.current.add(globalSearchesId);\n    }\n    if (activeTab && typeof searchesToExecuteByLayout[activeTab] !== \"undefined\") {\n      cachedLayoutIds.current.add(activeTab);\n    }\n    const layoutIdsToRemove = [];\n    cachedLayoutIds.current.forEach((layoutId) => {\n      var _a2;\n      if (typeof searchesToExecuteByLayout[layoutId] === \"undefined\") {\n        (_a2 = cachedLayoutIds.current) == null ? void 0 : _a2.delete(layoutId);\n        layoutIdsToRemove.push(layoutId);\n      }\n    });\n    return layoutIdsToRemove;\n  }, [activeTab, globalSearchesId, searchesToExecuteByLayout]);\n  const searchesToRemoveFromCache = (0, react_exports.useMemo)(\n    () => {\n      var _a;\n      return searchManager.removeLayoutsFromCache({\n        layoutIds: layoutIdsToRemoveFromCache,\n        itemToLayoutMap,\n        cachedLayoutIds: (_a = cachedLayoutIds.current) != null ? _a : /* @__PURE__ */ new Set()\n      });\n    },\n    [itemToLayoutMap, layoutIdsToRemoveFromCache, searchManager]\n  );\n  const { searchesToCreate, searchesToUpdate, searchesToRemove } = (0, react_exports.useMemo)(\n    () => {\n      var _a;\n      return searchManager.manageSearches({\n        searchesToExecuteByLayout,\n        dataSourceDefinitions,\n        activeLayoutIds,\n        itemToLayoutMap,\n        cachedLayoutIds: (_a = cachedLayoutIds.current) != null ? _a : /* @__PURE__ */ new Set()\n      });\n    },\n    [\n      dataSourceDefinitions,\n      searchManager,\n      searchesToExecuteByLayout,\n      activeLayoutIds,\n      itemToLayoutMap\n    ]\n  );\n  const getInitialRequestParams = (0, react_exports.useCallback)(\n    ({\n      consumerId,\n      bindingType\n    }) => {\n      if (consumerId === UnboundSmartSourceConsumerId) {\n        return UnboundSmartSourceRequestParams;\n      }\n      const itemPresetType = definitionClass.getItemPresetType(consumerId);\n      if (!itemPresetType) {\n        return {};\n      }\n      const itemLayoutType = definitionClass.getItemType(consumerId);\n      const initialRequestParams = (0, datasource_utils_exports.findInitialRequestParams)({\n        bindingType,\n        consumerModule: preset.findItem(itemPresetType, itemLayoutType),\n        options: definitionClass.getItemOptions(consumerId)\n      });\n      return initialRequestParams;\n    },\n    [definitionClass, preset]\n  );\n  const prevSearchesToCreate = usePrevious(searchesToCreate);\n  if (prevSearchesToCreate !== searchesToCreate) {\n    forEachSearchBinding(\n      searchesToCreate,\n      ({ dsId, consumerId, bindingTypes }) => {\n        bindingTypes.forEach((bindingType) => {\n          var _a;\n          (_a = searchProviderRef.current) == null ? void 0 : _a.createSearch({\n            dsId,\n            consumerId,\n            bindingType,\n            initialRequestParams: getInitialRequestParams({\n              consumerId,\n              bindingType\n            })\n          });\n        });\n      }\n    );\n  }\n  const prevSearchesToUpdate = usePrevious(searchesToUpdate);\n  if (prevSearchesToUpdate !== searchesToUpdate) {\n    forEachSearchBinding(\n      searchesToUpdate,\n      ({ dsId, consumerId, bindingTypes }) => {\n        bindingTypes.forEach((bindingType) => {\n          var _a;\n          (_a = searchProviderRef.current) == null ? void 0 : _a.updateSearch({\n            dsId,\n            consumerId,\n            bindingType,\n            initialRequestParams: getInitialRequestParams({\n              consumerId,\n              bindingType\n            })\n          });\n        });\n      }\n    );\n  }\n  const prevSearchesToRemove = usePrevious(searchesToRemove);\n  if (prevSearchesToRemove !== searchesToRemove) {\n    forEachSearchBinding(\n      searchesToRemove,\n      ({ dsId, consumerId, bindingTypes }) => {\n        bindingTypes.forEach((bindingType) => {\n          var _a;\n          (_a = searchProviderRef.current) == null ? void 0 : _a.removeSearch({\n            dsId,\n            consumerId,\n            bindingType\n          });\n        });\n      }\n    );\n  }\n  const prevSearchesToRemoveFromCache = usePrevious(\n    searchesToRemoveFromCache\n  );\n  if (prevSearchesToRemoveFromCache !== searchesToRemoveFromCache) {\n    forEachSearchBinding(\n      searchesToRemoveFromCache,\n      ({ dsId, consumerId, bindingTypes }) => {\n        bindingTypes.forEach((bindingType) => {\n          var _a;\n          (_a = searchProviderRef.current) == null ? void 0 : _a.removeSearch({\n            dsId,\n            consumerId,\n            bindingType\n          });\n        });\n      }\n    );\n  }\n  useAutoSearchControl({\n    activeTab,\n    searchesToExecuteByLayout,\n    searchesToRemove,\n    prevSearchesToRemove,\n    searchesToRemoveFromCache,\n    prevSearchesToRemoveFromCache\n  });\n  (0, react_exports.useEffect)(() => {\n    return () => {\n      var _a;\n      (_a = searchProviderRef.current) == null ? void 0 : _a.teardown();\n    };\n  }, []);\n  const searchApi = (0, react_exports.useMemo)(() => {\n    const searchProvider = searchProviderRef.current;\n    return {\n      createSearchAndSubscribe: (args) => searchProvider.createSearchAndSubscribe(args),\n      subscribe: (args) => searchProvider.subscribe(args),\n      control: (args) => __async(void 0, null, function* () {\n        return searchProvider.control(args);\n      }),\n      refresh: (args) => searchProvider.refresh(args),\n      updateRequestParams: (args) => searchProvider.updateRequestParams(args)\n    };\n  }, []);\n  return /* @__PURE__ */ react_default.createElement(SearchContext.Provider, { value: searchApi }, children);\n};\nvar useSearchContext = () => (0, react_exports.useContext)(SearchContext);\n\n// src/DashboardPluginContext/events/DashboardLifecycleEvent.ts\nvar DashboardLifecycleEvent = class {\n  constructor(payload) {\n    Object.assign(this, payload);\n  }\n};\n\n// src/DashboardPluginContext/events/CancellableDashboardLifecycleEvent.ts\nvar CancellableDashboardLifecycleEvent = class extends DashboardLifecycleEvent {\n  constructor() {\n    super(...arguments);\n    this.cancelled = false;\n  }\n  preventDefault() {\n    this.cancelled = true;\n  }\n  isCancelled() {\n    return this.cancelled;\n  }\n};\n\n// src/DashboardPluginContext/plugin/DashboardPlugin.ts\nvar lifecycleCallbacks = {\n  onInitialize: {},\n  onEventTrigger: {},\n  onLinkToUrl: {}\n};\nvar isDataSourceEvent = (event) => /^datasource\\./.test(`${event.type}`);\nfunction invokePluginCallbackWithEvent(plugin, name, eventGen) {\n  const fn = plugin[name];\n  if (typeof fn === \"function\") {\n    const event = eventGen();\n    try {\n      fn(event);\n    } catch (e) {\n      dashboard_utils_exports.console.error(\n        `Caught error while invoking lifecycle plugin callback ${name}`,\n        e\n      );\n      event.error = e;\n    }\n    return event;\n  }\n  return null;\n}\nfunction validateDashboardPlugin(plugin) {\n  if (!plugin || typeof plugin !== \"object\") {\n    throw new Error(\n      \"Invalid lifecycle plugin provided - should be an object\"\n    );\n  }\n  Object.keys(plugin).forEach((key) => {\n    if (!(key in lifecycleCallbacks)) {\n      if (typeof plugin[key] === \"function\") {\n        dashboard_utils_exports.console.warn(\n          `Unknown callback function \"${key}\" in lifecycle plugin`\n        );\n      }\n    } else if (lifecycleCallbacks[key].deprecated) {\n      dashboard_utils_exports.console.warn(\n        `Lifecycle plugin callback function \"${key}\" is DEPRECATED.`\n      );\n    }\n  });\n  return plugin;\n}\nvar createOnInitialize = memoize_one_default(\n  (plugin, searchMetricsCollector) => (payload) => {\n    var _a, _b;\n    if (typeof payload.dataSourceCount === \"number\" && payload.dataSourceCount === 0) {\n      searchMetricsCollector.forceComplete();\n    }\n    (_b = (_a = plugin.current).onInitialize) == null ? void 0 : _b.call(_a, payload);\n  }\n);\nvar createOnEventTrigger = memoize_one_default(\n  (plugin, searchMetricsCollector) => {\n    const searchJobMap = {};\n    let prevType;\n    let timeToFirstResult;\n    return (event) => {\n      var _a, _b, _c, _d, _e, _f, _g;\n      if (isDataSourceEvent(event)) {\n        const { targetId, type, payload } = event;\n        switch (type) {\n          case \"datasource.setup\": {\n            searchJobMap[targetId] = performance.now();\n            searchMetricsCollector.addInFlightDataSource(targetId);\n            prevType = type;\n            break;\n          }\n          case \"datasource.progress\": {\n            if (prevType === type) {\n              break;\n            }\n            const startTime = searchJobMap[targetId];\n            if (startTime) {\n              if (payload.data && // We're assuming search progressed when some results are returned.\n              // Caveat: If search runs but returns no results, we may not log its progress.\n              (((_b = (_a = payload.data) == null ? void 0 : _a.fields) == null ? void 0 : _b.length) || ((_d = (_c = payload.data) == null ? void 0 : _c.columns) == null ? void 0 : _d.length))) {\n                timeToFirstResult = performance.now() - startTime;\n              }\n            } else {\n              searchJobMap[targetId] = performance.now();\n            }\n            prevType = type;\n            break;\n          }\n          case \"datasource.done\":\n          case \"datasource.error\": {\n            const startTime = searchJobMap[targetId];\n            delete searchJobMap[targetId];\n            const duration = performance.now() - startTime;\n            searchMetricsCollector.collect({\n              status: type,\n              duration,\n              ttfr: timeToFirstResult || duration,\n              // Time To First Result\n              consumerId: payload.consumerId,\n              sid: (_e = payload == null ? void 0 : payload.meta) == null ? void 0 : _e.sid,\n              dataSourceId: targetId\n            });\n            prevType = type;\n            timeToFirstResult = null;\n            break;\n          }\n          default:\n            break;\n        }\n      }\n      (_g = (_f = plugin.current).onEventTrigger) == null ? void 0 : _g.call(_f, event);\n    };\n  }\n);\nvar DashboardPluginWrapper = class {\n  constructor({\n    plugin,\n    collector\n  }) {\n    this.plugin = plugin;\n    this.onEventTrigger = createOnEventTrigger(plugin, collector);\n    this.onInitialize = createOnInitialize(plugin, collector);\n  }\n  invokePluginCallback(name, payload) {\n    invokePluginCallbackWithEvent(\n      __spreadProps(__spreadValues({}, this.plugin.current), {\n        onEventTrigger: this.onEventTrigger,\n        onInitialize: this.onInitialize\n      }),\n      name,\n      () => new DashboardLifecycleEvent(payload)\n    );\n  }\n  invokeCancellablePluginCallback(name, payload) {\n    var _a;\n    const event = invokePluginCallbackWithEvent(\n      __spreadProps(__spreadValues({}, this.plugin.current), {\n        onEventTrigger: this.onEventTrigger,\n        onInitialize: this.onInitialize\n      }),\n      name,\n      () => new CancellableDashboardLifecycleEvent(payload)\n    );\n    return (_a = event == null ? void 0 : event.isCancelled()) != null ? _a : false;\n  }\n};\nvar createDashboardPlugin = (plugin, searchMetricsCollector) => {\n  validateDashboardPlugin(plugin.current);\n  return new DashboardPluginWrapper({\n    plugin,\n    collector: searchMetricsCollector\n  });\n};\n\n// src/DashboardPluginContext/DashboardPluginContext.tsx\nvar emptyDef = Object.freeze({});\nvar createCollector = ({\n  initialDefinition = emptyDef\n} = {}) => {\n  var _a;\n  return new dashboard_telemetry_exports.SearchMetricsCollector({\n    dataSourceCount: Object.keys((_a = initialDefinition.dataSources) != null ? _a : {}).length,\n    timeout: 60 * 1e3\n    // 60s timeout before we force log metrics\n  });\n};\nvar createPlugin = ({\n  plugin,\n  collector\n}) => createDashboardPlugin(plugin, collector);\nvar DashboardPluginContext = (0, react_exports.createContext)(\n  []\n);\nvar DashboardPluginContextProvider = ({\n  children,\n  value\n}) => {\n  const telemetryAPI = (0, dashboard_telemetry_exports.useTelemetryApi)();\n  const [, searchMetricsCollector] = value;\n  const handleSearchMetricsComplete = (0, react_exports.useCallback)(\n    ({ searchMetrics, loadTime, isUnmounting }) => {\n      telemetryAPI.emit({\n        pageAction: isUnmounting ? \"dashboard.unmount_metrics\" : \"dashboard.metrics\",\n        // If dashboard is unmounting, we don't want to record the load time since it will be inaccurate\n        loadTime: isUnmounting ? null : `${loadTime}`,\n        searchMetrics\n      });\n    },\n    [telemetryAPI]\n  );\n  (0, react_exports.useEffect)(() => {\n    searchMetricsCollector.addMetricsCollectedCallback(\n      handleSearchMetricsComplete\n    );\n    return () => {\n      searchMetricsCollector.forceComplete({ isUnmounting: true });\n    };\n  }, [searchMetricsCollector, handleSearchMetricsComplete]);\n  return /* @__PURE__ */ react_default.createElement(DashboardPluginContext.Provider, { value }, children);\n};\nvar DashboardPluginContextConsumer = DashboardPluginContext.Consumer;\nvar useDashboardPlugin = () => {\n  const [plugin] = (0, react_exports.useContext)(DashboardPluginContext);\n  return plugin;\n};\nvar useSearchMetricsCollector = () => {\n  const [, collector] = (0, react_exports.useContext)(DashboardPluginContext);\n  return collector;\n};\n\n// src/onChange/useDefinitionChangeCallback.ts\nvar useDefinitionChangeCallback = ({\n  onDefinitionChange: onChange\n}) => {\n  const definition = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectDefinition);\n  const firstRender = (0, react_exports.useRef)(true);\n  (0, react_exports.useEffect)(() => {\n    if (!onChange || firstRender.current) {\n      firstRender.current = false;\n      return;\n    }\n    onChange((0, lodash_exports.cloneDeep)(definition));\n  }, [definition, onChange]);\n};\n\n// src/onChange/useActiveTabChangeCallback.ts\nvar useActiveTabChangeCallback = ({\n  onActiveTabChange: onChange\n}) => {\n  const activeTab = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectActiveTab);\n  const firstRender = (0, react_exports.useRef)(true);\n  (0, react_exports.useEffect)(() => {\n    if (!onChange || firstRender.current) {\n      firstRender.current = false;\n      return;\n    }\n    onChange(activeTab);\n  }, [activeTab, onChange]);\n};\n\n// src/onChange/useTokenBindingChangeCallback.ts\nvar useTokenBindingChangeCallback = ({\n  initialTokenBinding,\n  onTokenBindingChange: onChange\n}) => {\n  const submittedTokens = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectSubmittedTokens);\n  const initialSubmittedTokens = (0, react_exports.useRef)(submittedTokens);\n  (0, react_exports.useEffect)(() => {\n    if (!onChange) {\n      return;\n    }\n    if (submittedTokens === initialSubmittedTokens.current && (0, lodash_exports.isEqual)(submittedTokens, initialTokenBinding)) {\n      return;\n    }\n    onChange((0, lodash_exports.cloneDeep)(submittedTokens));\n  }, [initialTokenBinding, submittedTokens, onChange]);\n};\n\n// src/onChange/useModeChangeCallback.ts\nvar useModeChangeCallback = ({\n  onModeChange: onChange\n}) => {\n  const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);\n  const firstRender = (0, react_exports.useRef)(true);\n  (0, react_exports.useEffect)(() => {\n    if (!onChange || firstRender.current) {\n      firstRender.current = false;\n      return;\n    }\n    onChange(mode);\n  }, [mode, onChange]);\n};\n\n// src/onChange/useSelectedItemsChangeCallback.ts\nvar useSelectedItemsChangeCallback = ({\n  onItemsSelect: onChange\n}) => {\n  const selectedItems = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectSelectedItems);\n  const firstRender = (0, react_exports.useRef)(true);\n  (0, react_exports.useEffect)(() => {\n    if (!onChange || firstRender.current) {\n      firstRender.current = false;\n      return;\n    }\n    onChange(selectedItems);\n  }, [selectedItems, onChange]);\n};\n\n// src/onChange/OnChangeCallbacks.tsx\nvar OnChangeCallbacks = ({\n  children,\n  initialTokenBinding,\n  onDefinitionChange,\n  onActiveTabChange,\n  onTokenBindingChange,\n  onModeChange,\n  onItemsSelect\n}) => {\n  useDefinitionChangeCallback({\n    onDefinitionChange\n  });\n  useActiveTabChangeCallback({ onActiveTabChange });\n  const initialTokenBindingRef = (0, react_exports.useRef)(initialTokenBinding);\n  useTokenBindingChangeCallback({\n    initialTokenBinding: initialTokenBindingRef.current,\n    onTokenBindingChange\n  });\n  useModeChangeCallback({ onModeChange });\n  useSelectedItemsChangeCallback({\n    onItemsSelect\n  });\n  return children;\n};\n\n// src/DashboardCoreApiContext/snapshot.ts\nvar dsSnapshotProps = [\n  \"requestParams\",\n  \"meta\",\n  \"error\",\n  \"data\"\n];\nvar SnapshotAssembler = class {\n  constructor({\n    definition,\n    tokens,\n    dataSourceRegistry,\n    apiRegistry\n  }) {\n    this.snapshotDefinition = (0, lodash_exports.cloneDeep)(definition);\n    this.tokens = tokens;\n    this.dataSourceSnapshot = dataSourceRegistry.snapshot();\n    this.apiRegistry = apiRegistry;\n  }\n  createNewBindingMap({\n    vizId,\n    dataSources,\n    dsSnapshots\n  }) {\n    const newBindings = {};\n    Object.entries(dataSources).forEach(([bindingType, dsId]) => {\n      var _a, _b, _c;\n      const consumerId = getConsumerId({\n        consumerId: vizId,\n        bindingType\n      });\n      const dsDef = (_a = this.snapshotDefinition.dataSources) == null ? void 0 : _a[dsId];\n      const dsState = (_c = (_b = this.dataSourceSnapshot) == null ? void 0 : _b[dsId]) == null ? void 0 : _c[consumerId];\n      const newDsId = (0, lodash_exports.uniqueId)(\"ds_\");\n      Object.assign(dsSnapshots, {\n        [newDsId]: __spreadProps(__spreadValues({}, dsDef != null ? dsDef : {}), {\n          state: __spreadValues({}, (0, lodash_exports.pick)(dsState != null ? dsState : {}, dsSnapshotProps))\n        })\n      });\n      newBindings[bindingType] = newDsId;\n    });\n    return newBindings;\n  }\n  /**\n   * Process the visualizations in the definition and, for each bound datasource, convert\n   * it to a snapshot datasource so it is self-contained.\n   *\n   * This call will mutate both the `visualizations` and `dataSources` properties of\n   * `this.snapshotDefinition`\n   */\n  processDataSourceSnapshots() {\n    var _a;\n    const dsSnapshots = {};\n    Object.entries((_a = this.snapshotDefinition.visualizations) != null ? _a : {}).forEach(\n      ([vizId, vizDef]) => {\n        var _a2, _b, _c;\n        const newBindings = this.createNewBindingMap({\n          vizId,\n          dsSnapshots,\n          dataSources: (_a2 = vizDef.dataSources) != null ? _a2 : {}\n        });\n        if (!((_c = (_b = this.snapshotDefinition) == null ? void 0 : _b.visualizations) == null ? void 0 : _c[vizId])) {\n          return;\n        }\n        this.snapshotDefinition.visualizations[vizId].dataSources = newBindings;\n        const vizApi = this.apiRegistry.getVisualizationApi(vizId);\n        if (vizApi && (0, lodash_exports.isFunction)(vizApi.snapshot)) {\n          this.snapshotDefinition.visualizations[vizId] = __spreadValues(__spreadValues({}, this.snapshotDefinition.visualizations[vizId]), vizApi.snapshot());\n        }\n      }\n    );\n    this.snapshotDefinition.dataSources = dsSnapshots;\n  }\n  processLayoutSnapshots() {\n    var _a, _b;\n    Object.entries(\n      (_b = (_a = this.snapshotDefinition.layout) == null ? void 0 : _a.layoutDefinitions) != null ? _b : {}\n    ).forEach(([layoutId, layoutDef]) => {\n      var _a2;\n      const layouts = (_a2 = this.snapshotDefinition.layout) == null ? void 0 : _a2.layoutDefinitions;\n      if (!layouts) {\n        return;\n      }\n      const layoutApi = this.apiRegistry.getLayoutApi(layoutId);\n      if (layoutApi && (0, lodash_exports.isFunction)(layoutApi.snapshot)) {\n        const snapshot = layoutApi.snapshot();\n        layouts[layoutId] = __spreadValues(__spreadValues({}, layoutDef), snapshot);\n      }\n    });\n  }\n  // TODO: revisit processInputs as part of SCP-66648\n  processInputs() {\n    delete this.snapshotDefinition.inputs;\n    if (this.snapshotDefinition.layout) {\n      delete this.snapshotDefinition.layout.globalInputs;\n      if (this.snapshotDefinition.layout.options) {\n        delete this.snapshotDefinition.layout.options.submitButton;\n      }\n    }\n  }\n  assemble() {\n    if (this.snapshot) {\n      return this.snapshot;\n    }\n    this.processDataSourceSnapshots();\n    this.processLayoutSnapshots();\n    this.processInputs();\n    this.snapshot = {\n      snapshotDefinition: this.snapshotDefinition,\n      tokens: this.tokens\n    };\n    return this.snapshot;\n  }\n};\nvar assembleSnapshot = ({\n  definition,\n  tokens = {},\n  dataSourceRegistry,\n  apiRegistry\n}) => new SnapshotAssembler({\n  definition,\n  tokens,\n  dataSourceRegistry,\n  apiRegistry\n}).assemble();\n\n// src/DashboardCoreApiContext/DashboardCoreApi.ts\nvar emptyDatasourceMeta = {};\nvar NO_ACTIVE_TAB_ID_ERROR = (0, i18n_exports._)(\n  \"No active tab Id is available. Cannot get layout API\"\n);\nvar DashboardCoreApi = class {\n  get activeLayoutId() {\n    const tabId = (0, dashboard_state_exports.selectActiveTab)(this.store.getState());\n    if (!tabId) {\n      throw new Error(NO_ACTIVE_TAB_ID_ERROR);\n    }\n    return tabId;\n  }\n  constructor({\n    store,\n    apiRegistry,\n    dataSourceRegistry\n  }) {\n    this.store = store;\n    this.apiRegistry = apiRegistry;\n    this.dataSourceRegistry = dataSourceRegistry;\n  }\n  /**\n   * Replace the dashboard definition. This method causes a lot of redux state to recompute, use sparingly\n   * ```js\n   * dashboardCoreApi.replaceDefinition({ definition });\n   * ```\n   * @method replaceDefinition\n   * @param {ReplaceDefinitionParams} options\n   * @param {DashboardJSON} options.definition dashboard definition\n   * @public\n   */\n  replaceDefinition({ definition }) {\n    this.store.dispatch(\n      (0, dashboard_state_exports.resetStore)({\n        definition\n      })\n    );\n  }\n  /**\n   * Replace read-only token namespaces with the ones provided\n   * ```ts\n   * const namespaces = new Set<string>(['readonlyTokens']);\n   * dashboardCoreApi.replaceReadOnlyTokenNamespaces({ namespaces });\n   * ```\n   * @method replaceReadOnlyTokenNamespaces\n   * @param {ReplaceReadOnlyTokenNamespacesParams} options\n   * @param {Set<TokenNamespace>} options.namespaces read-only token namespaces\n   * @public\n   */\n  replaceReadOnlyTokenNamespaces({\n    namespaces\n  }) {\n    this.store.dispatch((0, dashboard_state_exports.replaceReadOnlyTokenNamespaces)({ namespaces }));\n  }\n  /**\n   * Replace the token binding.\n   * This will replace all tokens in state with the tokens provided in the tokenBinding object\n   * ```js\n   * dashboardCoreApi.replaceTokenBinding({ tokenBinding: { default: { token1: 'foo' } } });\n   * ```\n   * @method replaceTokenBinding\n   * @param {ReplaceTokenBindingParams} options\n   * @param {TokenState} options.tokenBinding new token binding\n   * @public\n   */\n  replaceTokenBinding({ tokenBinding }) {\n    this.store.dispatch((0, dashboard_state_exports.replaceTokenBinding)({ tokenBinding }));\n  }\n  /**\n   * Update the dashboard definition. This method causes a lot of redux state to recompute, use sparingly\n   * ```js\n   * dashboardCoreApi.updateDefinition({\n   *     layout: {\n   *         type: 'absolute',\n   *     },\n   * });\n   * ```\n   * @method updateDefinition\n   * @param {DashboardJSON} definition dashboard definition\n   * @public\n   */\n  updateDefinition(definition) {\n    this.store.dispatch((0, dashboard_state_exports.updateDefinition)(definition));\n  }\n  /**\n   * Fetch the current definition from state\n   * @returns {DashboardJSON} The current definition\n   * @public\n   */\n  getDefinition() {\n    return (0, dashboard_state_exports.selectDefinition)(this.store.getState());\n  }\n  /**\n   * Get the layout definition for the provided layoutId. If no layoutId is provided, it will fetch the currently active layoutId\n   * @method getLayoutDefinition\n   * @returns {LayoutDefinitionItem}  The layout definition, or undefined if the layout does not exist\n   * @public\n   */\n  getLayoutDefinition(layoutId) {\n    const layout = (0, dashboard_state_exports.selectLayout)(this.store.getState(), layoutId);\n    return (0, lodash_exports.isEmpty)(layout) ? void 0 : layout;\n  }\n  /**\n   * Get the current dashboard mode\n   * @method getMode\n   * @returns {Mode}  'view' | 'edit'\n   * @public\n   */\n  getMode() {\n    return (0, dashboard_state_exports.selectMode)(this.store.getState());\n  }\n  /**\n   * Set token bindings.\n   * This will only update the tokens provided in the tokenBinding object\n   * @param {Object} tokenBindingsConfig\n   * @param {Object} tokenBindingsConfig.tokenBindings token bindings\n   * @param {TokenNamespace} [tokenBindingsConfig.namespace = 'default'] - namespace for token bindings\n   * ```js\n   * dashboardCoreApi.setTokenBindings({\n   *     tokenBindings: { myToken: 'myTokenValue' },\n   * })\n   * ```\n   * @method setTokenBindings\n   * @param {Object} options\n   * @param {Object} options.tokenBindings token bindings\n   * @param {TokenNamespace} [options.namespace = 'default'] - namespace for token bindings\n   * @public\n   */\n  setTokenBindings({\n    tokenBindings,\n    namespace = dashboard_utils_exports.DEFAULT_TOKEN_NAMESPACE\n  }) {\n    this.store.dispatch(\n      (0, dashboard_state_exports.setToken)(tokenBindings, namespace)\n    );\n  }\n  /**\n   * Unset token bindings. This will not unset any tokens other than those provided and no error is thrown if the token to be unset does not exist.\n   * ```js\n   * dashboardCoreApi.unsetTokenBinding({\n   *     tokenName: 'myToken',\n   * })\n   *\n   * // This method is capable of unsetting multiple tokens within a single namespace if an array of token names is provided:\n   * dashboardCoreApi.unsetTokenBinding({\n   *     tokenName: ['myToken', 'myToken2', 'myToken3'],\n   * })\n   * ```\n   * @method unsetTokenBinding\n   * @param {Object} options\n   * @param {TokenName} options.tokenName token name\n   * @param {TokenNamespace} [options.namespace = 'default'] - namespace for token bindings\n   * @public\n   */\n  unsetTokenBinding({\n    tokenName,\n    namespace = dashboard_utils_exports.DEFAULT_TOKEN_NAMESPACE\n  }) {\n    this.store.dispatch((0, dashboard_state_exports.unsetToken)({ namespace, tokenName }));\n  }\n  /**\n   * Retrieve a promise which resolves with the current layout's API once it is available\n   * ```js\n   * dashboardCoreApi.getLayoutApi().then((layoutApi) => {\n   *     this.layoutApi = layoutApi;\n   * });\n   * ```\n   * @method getLayoutApi\n   * @returns {Promise} A Promise that resolves to layoutApi object\n   * @public\n   */\n  getLayoutApi() {\n    const activeTab = this.activeLayoutId;\n    return new Promise((resolve) => {\n      const api = this.apiRegistry.getLayoutApi(activeTab);\n      if (api) {\n        resolve(api);\n      }\n      this.apiRegistry.onLayoutApiReady = () => resolve(this.apiRegistry.getLayoutApi(activeTab));\n    });\n  }\n  /**\n   * Create a visualization and add it to the dashboard. If the visualization requires a new data source it can be created and bound in the same call by providing values for `dataSourceType` and `dataSourceDefinition`.\n   * ```js\n   * const myTableDefinition = {\n   *     type: 'splunk.table',\n   *     options: {\n   *         count: 25,\n   *         showRowNumbers: true,\n   *         showInternalFields: false\n   *     },\n   * };\n   *\n   * const myTableDataDefinition = {\n   *     type': 'ds.search',\n   *     options': {\n   *         \"query\": `| makeresults count=100\n   * | streamstats count as row\n   * | eval value=random() % 4000\n   * | table row, value`,\n   *     },\n   *     name: 'My Table Data',\n   * };\n   *\n   * dashboardCoreApi.createVisualization({\n   *     visualizationId: 'viz_myNewTable',\n   *     visualizationDefinition: myTableDefinition,\n   *     layoutItemType: 'block',\n   *     dataSourceType: 'primary',\n   *     dataSourceDefinition: myTableDataDefinition,\n   * });\n   * ```\n   * @method createVisualization\n   * @param {CreateVisualizationActionPayload} options\n   * @param {string} options.visualizationId A unique identifier for the visualization\n   * @param {VisualizationDefinition} options.visualizationDefinition The JSON definition for the visualization\n   * @param {StructureItemType} [options.layoutItemType='block'] An optional layout type to tell the layout how to render the visualization\n   * @param {string | null} [options.dataSourceType] An optional data source binding type (i.e. 'primary')\n   * @param {DataSourceDefinition | null} [options.dataSourceDefinition] An optional definition for the data source to be created\n   * @public\n   */\n  createVisualization({\n    visualizationId,\n    visualizationDefinition,\n    layoutItemType = \"block\",\n    dataSourceType,\n    dataSourceDefinition\n  }) {\n    this.store.dispatch(\n      (0, dashboard_state_exports.createVisualization)({\n        visualizationId,\n        visualizationDefinition,\n        layoutItemType,\n        dataSourceType,\n        dataSourceDefinition\n      })\n    );\n  }\n  /**\n   * Clone one or more existing dashboard items (input or visualization)\n   * ```js\n   * dashboardCoreApi.cloneDashboardItems({\n   *     from: ['viz_1', 'viz_2', 'input_1'],\n   *     to: ['viz_clone1', 'viz_clone2', 'input_clone1'],\n   * });\n   * ```\n   * @method cloneDashboardItems\n   * @param {Object} options\n   * @param {String[]} options.fromIds Original item Ids\n   * @param {String[]} options.toIds Ids for cloned items\n   * @param {Number} [options.offsetMultiplier=1] Multiplier for the position offset of the cloned items\n   * @param {String} [options.fromLayoutId] Layout to clone from\n   * @param {String} [options.toLayoutId] Layout to clone to\n   * @public\n   */\n  cloneDashboardItems({\n    fromIds,\n    toIds,\n    offsetMultiplier = 1,\n    fromLayoutId,\n    toLayoutId\n  }) {\n    const activeTab = this.activeLayoutId;\n    this.store.dispatch(\n      (0, dashboard_state_exports.cloneDashboardItems)({\n        fromIds,\n        toIds,\n        offsetMultiplier,\n        fromLayoutId: fromLayoutId != null ? fromLayoutId : activeTab,\n        toLayoutId: toLayoutId != null ? toLayoutId : activeTab\n      })\n    );\n  }\n  /**\n   * Move one or more existing dashboard items (input or visualization) to a specified layout.\\\n   * This is a no-op if `toLayoutId` equals `fromLayoutId`\n   *\n   * @example\n   * ```js\n   * dashboardCoreApi.moveDashboardItemsToLayout({\n   *     itemIds: ['viz_1', 'viz_2', 'input_1'],\n   *     toLayoutId: 'layout_2',\n   * });\n   * ```\n   * @method moveDashboardItemsToLayout\n   * @param {Object} options\n   * @param {String[]} options.itemIds ids of the items being moved\n   * @param {String} options.toLayoutId Layout to move items to\n   * @param {String} [options.fromLayoutId=<activeLayoutId>] Layout to move items from. Will be the active layout if not provided.\n   * @public\n   */\n  moveDashboardItemsToLayout({\n    itemIds,\n    fromLayoutId = this.activeLayoutId,\n    toLayoutId\n  }) {\n    this.store.dispatch(\n      (0, dashboard_state_exports.moveDashboardItemsToLayout)({ itemIds, toLayoutId, fromLayoutId })\n    );\n  }\n  /**\n   * Remove one or more dashboard items (visualizations or inputs)\n   * ```js\n   * // Remove single item `viz_5`\n   * dashboardCoreApi.removeDashboardItems(['viz_5']);\n   *\n   * // Remove multiple items `viz_2` and `input_1`\n   * dashboardCoreApi.removeDashboardItems(['viz_2', 'input_1']);\n   * ```\n   * @method removeDashboardItems\n   * @param {String[]} ids list of item IDs to remove\n   * @param {String} layoutId optional Layout ID\n   * @public\n   */\n  removeDashboardItems(ids, layoutId) {\n    this.store.dispatch(\n      (0, dashboard_state_exports.removeDashboardItems)({ itemIds: ids, layoutId })\n    );\n  }\n  /**\n   * Remove one or more dashboard items with a possible confirmation prompt\n   * @method removeDashboardItemsWithPrompt\n   * @param {String[]} ids list of item IDs to remove\n   * @param {String} layoutId optional layout ID\n   * @private\n   */\n  removeDashboardItemsWithPrompt(ids, layoutId) {\n    this.store.dispatch(\n      (0, dashboard_state_exports.removeDashboardItems)(\n        { itemIds: ids, layoutId },\n        { confirmDeletion: true }\n      )\n    );\n  }\n  /**\n   * Replace a visualization's definition.\n   * ```js\n   * dashboardCoreApi.updateVisualization({\n   *     id: 'viz_1',\n   *     vizDefinition: {\n   *         options: {\n   *             count: 25,\n   *             showRowNumbers: true,\n   *             showInternalFields: false,\n   *         },\n   *     },\n   * });\n   * ```\n   * @method updateVisualization\n   * @param {Object} options\n   * @param {String} options.id ID of the visualization to be updated\n   * @param {Object} options.vizDefinition A new visualization definition to be applied\n   * @public\n   */\n  updateVisualization({\n    id,\n    vizDefinition\n  }) {\n    this.store.dispatch(\n      (0, dashboard_state_exports.updateVisualization)({\n        id,\n        vizDefinition\n      })\n    );\n  }\n  /**\n   * Remove a data source from a visualization definition\n   * ```js\n   * dashboardCoreApi.removeDataSourceFromVisualization({\n   *     vizId: 'viz_1',\n   *     dsBindingType: 'primary',\n   * });\n   * ```\n   * @method removeDataSourceFromVisualization\n   * @param {Object} options\n   * @param {String} options.vizId ID of the visualization to be updated\n   * @param {String} options.dsBindingType Type of the data source binding (e.g. 'primary' or 'annotation') to be removed\n   * @public\n   */\n  removeDataSourceFromVisualization({\n    vizId,\n    dsBindingType\n  }) {\n    this.store.dispatch(\n      (0, dashboard_state_exports.removeDataSourceFromVisualization)({\n        vizId,\n        dsBindingType\n      })\n    );\n  }\n  /**\n   * Get the DOM element for the global inputs container\n   * ```ts\n   * const globalInputContainer: HTMLElement | null = dashboardCoreApi.getInputsDomElement();\n   * ```\n   * @method getInputsDomElement\n   * @returns {HTMLElement | null} DOM element for the global inputs container. If no global inputs exist in the dashboard then this will return `null`\n   * @public\n   */\n  getInputsDomElement() {\n    const globalInputsApi = this.apiRegistry.getGlobalInputsApi();\n    return globalInputsApi ? globalInputsApi.getInputsDomElement() : null;\n  }\n  /**\n   * Get the DOM element for the dashboard canvas\n   * ```ts\n   * const dashboardCanvas: HTMLElement | null = dashboardCoreApi.getCanvasDomElement();\n   * ```\n   * @method getCanvasDomElement\n   * @returns {HTMLElement | null} DOM element for the dashboard canvas. If the layout API is not yet ready then this will return `null`\n   * @public\n   */\n  getCanvasDomElement() {\n    const layoutApi = this.apiRegistry.getLayoutApi(this.activeLayoutId);\n    return (layoutApi == null ? void 0 : layoutApi.getCanvasDomElement()) || null;\n  }\n  /**\n   * Get the DOM element for a dashboard visualization.\n   * ```ts\n   * const visualizationElement: HTMLElement | null = dashboardCoreApi.getVisualizationDomElement('viz_1');\n   * ```\n   * @method getVisualizationDomElement\n   * @returns {HTMLElement | null} DOM element for the visualization. If the visualization API is not yet\n   * ready, the provided visualization ID does not correspond to an item in the dashboard, or the provided\n   * ID corresponds to a global or in-canvas input, then this will return `null`\n   * @public\n   */\n  getVisualizationDomElement(vizId) {\n    const vizActionsApi = this.apiRegistry.getVisualizationApi(vizId);\n    return (vizActionsApi == null ? void 0 : vizActionsApi.getDomElement()) || null;\n  }\n  /**\n   * Pause data sources in the dashboard with the given data source ID values\n   * ```js\n   * dashboardCoreApi.pauseDataSources([\"ds_1\", \"ds_2\"]);\n   * ```\n   * @method pauseDataSources\n   * @public\n   */\n  pauseDataSources(dsIds) {\n    this.dataSourceRegistry.pauseDataSources(dsIds);\n  }\n  /**\n   * Pause all data sources in the dashboard\n   * ```js\n   * dashboardCoreApi.pauseAllDataSources();\n   * ```\n   * @method pauseAllDataSources\n   * @public\n   */\n  pauseAllDataSources() {\n    this.dataSourceRegistry.pauseDataSources();\n  }\n  /**\n   * Resume data sources in the dashboard with the given data source ID values\n   * ```js\n   * dashboardCoreApi.resumeDataSources([\"ds_1\", \"ds_2\"]);\n   * ```\n   * @method resumeDataSources\n   * @public\n   */\n  resumeDataSources(dsIds) {\n    this.dataSourceRegistry.resumeDataSources(dsIds);\n  }\n  /**\n   * Resume all data sources in the dashboard\n   * ```js\n   * dashboardCoreApi.resumeAllDataSources();\n   * ```\n   * @method resumeAllDataSources\n   * @public\n   */\n  resumeAllDataSources() {\n    this.dataSourceRegistry.resumeDataSources();\n  }\n  /**\n   * Get the metadata for a data source\n   * ```js\n   * dashboardCoreApi.getDataSourceMetaData('ds_search1');\n   * ```\n   * @method getDataSourceMetaData\n   * @param {String} dataSourceId ID of a data source\n   * @returns {DataSourceMeta} Metadata for the data source\n   * @public\n   */\n  getDataSourceMetaData(dataSourceId) {\n    const state = this.store.getState();\n    const dataSources = (0, dashboard_state_exports.selectDataSourceDefinitions)(state);\n    const dataSourceDef = dataSources[dataSourceId];\n    const dataSourceController = dataSourceDef ? this.dataSourceRegistry.getDataSourceController(dataSourceId) : null;\n    return (dataSourceController == null ? void 0 : dataSourceController.getDataSourceMetaData()) || emptyDatasourceMeta;\n  }\n  /**\n   * Return visualization and input IDs in the order they are defined in the `.layout.structure` section of the definition\n   * ```js\n   * dashboardCoreApi.getCanvasItemOrder();\n   * ```\n   * @method getCanvasItemOrder\n   * @param {String} [layoutId=<activeTab>] layout whose canvas item order should be returned\n   * @returns {String[] | null} An array of visualization or input IDs, or `null` if the layout API is not yet available\n   * @public\n   */\n  getCanvasItemOrder(layoutId) {\n    const layoutApi = this.apiRegistry.getLayoutApi(\n      layoutId != null ? layoutId : this.activeLayoutId\n    );\n    return typeof (layoutApi == null ? void 0 : layoutApi.getLayoutItemOrder) === \"function\" ? layoutApi.getLayoutItemOrder() : null;\n  }\n  /**\n   * Adjust the order of visualizations or in-canvas inputs in the dashboard. This will produce a new definition.\n   * If `config.from` is negative or geq the number of visualizations in the layout structure then this is a no-op. Negative `config.to` values are treated as 0.\n   * ```js\n   * dashboardCoreApi.getCanvasItemOrder();\n   * // > ['viz_1', 'viz_2', 'input_1', 'viz_3']\n   *\n   * dashboardCoreApi.adjustCanvasItemOrder({ from: 1, to: 3 });\n   *\n   * dashboardCoreApi.getCanvasItemOrder();\n   * // > ['viz_1', 'input_1', 'viz_3', 'viz_2']\n   * ```\n   * @method adjustCanvasItemOrder\n   * @param {Number} config.from The numeric index in the current order of the item to be moved\n   * @param {Number} config.to The new order index\n   * @public\n   */\n  adjustCanvasItemOrder({ from, to }) {\n    this.store.dispatch((0, dashboard_state_exports.adjustCanvasItemOrder)({ from, to }));\n  }\n  /**\n   * Take snapshot of current dashboard\n   * ```js\n   * const snapshot = dashboardCoreApi.takeSnapshotSync();\n   * ```\n   * @method takeSnapshotSync\n   * @returns {Snapshot} The dashboard snapshot object\n   * @public\n   */\n  takeSnapshotSync() {\n    const state = this.store.getState();\n    const definition = (0, dashboard_state_exports.selectDefinition)(state);\n    const tokens = (0, dashboard_state_exports.selectSubmittedTokens)(state);\n    return assembleSnapshot({\n      definition,\n      tokens,\n      apiRegistry: this.apiRegistry,\n      dataSourceRegistry: this.dataSourceRegistry\n    });\n  }\n  /**\n   * Take snapshot of current dashboard\n   * ```js\n   * const snapshot = await dashboardCoreApi.takeSnapshot();\n   * ```\n   * @method takeSnapshot\n   * @returns {Promise<Snapshot>} A promise that resolves to a dashboard snapshot object\n   * @deprecated This method exists only for backwards compatibility with the legacy async API.\n   * @see {@link takeSnapshotSync}\n   */\n  takeSnapshot() {\n    return __async(this, null, function* () {\n      return this.takeSnapshotSync();\n    });\n  }\n  /**\n   * Focus on a visualization.\n   * This will call the visualization's `focus` function if implemented\n   * ```js\n   * dashboardCoreApi.focusOnVisualization('viz_1');\n   * ```\n   * @method focusOnVisualization\n   * @param {String} vizId The ID of the visualization to be focused\n   * @public\n   */\n  focusOnVisualization(vizId) {\n    const vizApi = this.apiRegistry.getVisualizationApi(vizId);\n    if (typeof (vizApi == null ? void 0 : vizApi.focus) === \"function\") {\n      vizApi.focus();\n    }\n  }\n  /**\n   * Refresh all searches associated with the given visualization\n   * ```js\n   * dashboardCoreApi.refreshVisualization('viz_1', { checkRiskyCommand: false });\n   * ```\n   * @method refreshVisualization\n   * @param {String} vizId ID of the visualization\n   * @param {Object} options\n   * @param {Boolean} [options.checkRiskyCommand=true] Sets the check_risky_command option. Set to `false` to continue searches with risky commands\n   * @public\n   */\n  refreshVisualization(vizId, { checkRiskyCommand = true } = {}) {\n    const vizActionsApi = this.apiRegistry.getVisualizationActionsApi(vizId);\n    vizActionsApi == null ? void 0 : vizActionsApi.refresh({ checkRiskyCommand });\n  }\n  /**\n   * refresh all searches associated with the given input\n   * ```js\n   * dashboardCoreApi.refreshInput('input_1', { checkRiskyCommand: true });\n   * ```\n   * @method refreshInput\n   * @param {String} inputId ID of the input\n   * @param {Object} options\n   * @param {Boolean} [options.checkRiskyCommand=true] Sets the check_risky_command option. Set to `false` to continue searches with risky commands\n   * @public\n   */\n  refreshInput(inputId, { checkRiskyCommand = true } = {}) {\n    const inputActionsApi = this.apiRegistry.getInputActionsApi(inputId);\n    inputActionsApi == null ? void 0 : inputActionsApi.refresh({ checkRiskyCommand });\n  }\n  /**\n   * toggle the pause/resume state for all searches associated with the given item\n   * ```js\n   * dashboardCoreApi.togglePause('viz_1');\n   * ```\n   * @method togglePause\n   * @param {String} inputId ID of the panel\n   * @public\n   */\n  togglePause(itemId) {\n    var _a;\n    const actionsApi = (_a = this.apiRegistry.getVisualizationActionsApi(itemId)) != null ? _a : this.apiRegistry.getInputActionsApi(itemId);\n    actionsApi == null ? void 0 : actionsApi.control(\"togglePause\");\n  }\n  /**\n   * Set if grid lines should be shown when in edit mode\n   * ```js\n   * dashboardCoreApi.toggleGridLines(false);\n   * ```\n   * @method toggleGridLines\n   * @param gridToggleValue\n   * @private\n   */\n  toggleGridLines(gridToggleValue) {\n    this.store.dispatch((0, dashboard_state_exports.showGridLines)(gridToggleValue));\n  }\n  /**\n   * Toggles (expands/collapses) the toolbar if available\n   * @method toggleToolbar\n   * @public\n   */\n  toggleToolbar() {\n    var _a;\n    const toolbarApi = this.apiRegistry.getToolbarApi();\n    (_a = toolbarApi == null ? void 0 : toolbarApi.toggle) == null ? void 0 : _a.call(toolbarApi);\n  }\n  /**\n   * Expand the toolbar if available\n   * @method expandToolbar\n   * @public\n   */\n  expandToolbar() {\n    var _a;\n    const toolbarApi = this.apiRegistry.getToolbarApi();\n    (_a = toolbarApi == null ? void 0 : toolbarApi.expand) == null ? void 0 : _a.call(toolbarApi);\n  }\n  /**\n   * Collapse the toolbar if available\n   * @method expandToolbar\n   * @public\n   */\n  collapseToolbar() {\n    var _a;\n    const toolbarApi = this.apiRegistry.getToolbarApi();\n    (_a = toolbarApi == null ? void 0 : toolbarApi.collapse) == null ? void 0 : _a.call(toolbarApi);\n  }\n  /**\n   * Set the current fullscreen item to be the provided visualization.\n   * This call must be done in response to a user interaction or it will likely fail due to browser security rules.\n   * ```jsx\n   * <button onClick={() => dashboardCoreApi.toggleVisualizationFullscreen('viz_1')}>\n   *     Fullscreen Visualization\n   * </button>\n   * ```\n   * @method toggleVisualizationFullscreen\n   * @param {String} vizId ID of the visualization to fullscreen\n   * @public\n   */\n  toggleVisualizationFullscreen(vizId) {\n    this.store.dispatch((0, dashboard_state_exports.setFullscreenItem)(vizId));\n  }\n  /**\n   * Check if the dashboard has any running searches\n   * ```js\n   * if (dashboardCoreApi.hasRunningSearches()) {\n   *     console.info(\"The dashboard has running searches\");\n   * }\n   * ```\n   * @method hasRunningSearches\n   * @returns {boolean} Boolean indicating if at least one search is running\n   * i.e. status is one of 'queued', 'parsing', 'running', 'pause' or 'finalizing'.\n   * @public\n   */\n  hasRunningSearches() {\n    const snapshotSync = this.takeSnapshotSync();\n    const { dataSources = {} } = (snapshotSync == null ? void 0 : snapshotSync.snapshotDefinition) || {};\n    return (0, lodash_exports.some)(dataSources, (datasource) => {\n      var _a, _b;\n      const status = (_b = (_a = datasource.state) == null ? void 0 : _a.meta) == null ? void 0 : _b.status;\n      return dashboard_utils_exports.runningSearchStatuses.includes(status);\n    });\n  }\n  /**\n   * Applies new scale to the dashboard\n   * ```js\n   * dashboardCoreApi.setScale(2.5);\n   * ```\n   * @method setScale\n   * @param {Number} scale Scale factor as a floating point number\n   * @public\n   */\n  setScale(scale) {\n    const layoutApi = this.apiRegistry.getLayoutApi(this.activeLayoutId);\n    if (typeof (layoutApi == null ? void 0 : layoutApi.setScale) === \"function\") {\n      layoutApi.setScale(scale);\n    }\n  }\n  /**\n   * Increases dashboard zoom level for one step\n   * ```js\n   * dashboardCoreApi.zoomIn();\n   * ```\n   * @method zoomIn\n   * @public\n   */\n  zoomIn() {\n    const layoutApi = this.apiRegistry.getLayoutApi(this.activeLayoutId);\n    if (typeof (layoutApi == null ? void 0 : layoutApi.zoomIn) === \"function\") {\n      layoutApi.zoomIn();\n    }\n  }\n  /**\n   * Decreases dashboard zoom level for one step\n   * ```js\n   * dashboardCoreApi.zoomOut();\n   * ```\n   * @method zoomOut\n   * @public\n   */\n  zoomOut() {\n    const layoutApi = this.apiRegistry.getLayoutApi(this.activeLayoutId);\n    if (typeof (layoutApi == null ? void 0 : layoutApi.zoomOut) === \"function\") {\n      layoutApi.zoomOut();\n    }\n  }\n  /**\n   * Adjusts dashboard's width to fit its parent element.\n   * ```js\n   * dashboardCoreApi.fitToWidth();\n   * ```\n   * @method fitToWidth\n   * @param {Number} [maxScale=Infinity] The maximum scale factor at which the dashboard stops adjusting its width\n   * @public\n   */\n  fitToWidth(maxScale = Infinity) {\n    const layoutApi = this.apiRegistry.getLayoutApi(this.activeLayoutId);\n    if (typeof (layoutApi == null ? void 0 : layoutApi.fitToWidth) === \"function\") {\n      layoutApi.fitToWidth(maxScale);\n    }\n  }\n  /**\n   * Get an observable to which a listener can subscribe for notifications when the dashboard zoom level changes\n   * ```js\n   * React.useEffect(() => {\n   *     let subscription = null;\n   *     dashboardCoreApi.getZoomLevel().then((observable) => {\n   *         if (subscription === null) {\n   *             subscription = observable.subscribe((zoomLevel) => {\n   *                 console.log(`Dashboard zoom changed to [${zoomLevel}]`);\n   *             });\n   *         }\n   *     });\n   *\n   *     return () => {\n   *         subscription?.unsubscribe();\n   *         subscription = undefined;\n   *     };\n   * }, [dashboardCoreApi]);\n   * ```\n   * @method getZoomLevel\n   * @returns {Promise<BehaviorSubject<Number> | null>} Promise that resolves to an observable that yields zoom level\n   * @public\n   */\n  getZoomLevel() {\n    return __async(this, null, function* () {\n      const layoutApi = yield this.getLayoutApi();\n      return (layoutApi == null ? void 0 : layoutApi.getZoomLevel()) || null;\n    });\n  }\n  /**\n   * Get input definition given a token ID\n   * ```js\n   * dashboardCoreApi.getInputByToken('input1_token');\n   * ```\n   * @method getInputByToken\n   * @param {String} tokenId ID of the token associated with an input\n   * @returns {InputDefinition | null} The definition of the associated input if it exists, else `null`\n   * @public\n   */\n  getInputByToken(tokenId) {\n    const state = this.store.getState();\n    const definition = new dashboard_definition_exports.DashboardDefinition((0, dashboard_state_exports.selectDefinition)(state));\n    return definition.getInputByToken(tokenId);\n  }\n  /**\n   * Add an input to the end of the global inputs bar\n   * ```js\n   * const myInputDefinition = {\n   *     type: 'input.text',\n   *     title: 'my text input',\n   *     options: {\n   *         token: 'input2_token',\n   *     },\n   * };\n   *\n   * dashboardCoreApi.addInput('input_2', myInputDefinition);\n   * ```\n   * @method addInput\n   * @param {String} inputId The ID of the input being added\n   * @param {Object} inputDefinition The definition of the input being added\n   * @public\n   */\n  addInput(inputId, inputDefinition) {\n    this.store.dispatch(\n      (0, dashboard_state_exports.createInput)({\n        inputId,\n        inputDefinition\n      })\n    );\n  }\n  /**\n   * Reorder the global inputs in the dashboard. Invalid `from` and/or `to` indexes cause this to be a no-op.\n   * ```js\n   * dashboardCoreApi.moveInput(0, 2);\n   * ```\n   * @method moveInput\n   * @param {Number} from array index of the input to move\n   * @param {Number} to array index of where the input should move to\n   * @public\n   */\n  moveInput(from, to) {\n    this.store.dispatch(\n      (0, dashboard_state_exports.adjustInputOrder)({\n        from,\n        to\n      })\n    );\n  }\n  /**\n   * Update an input definition\n   * ```js\n   * const myUpdatedInputDefinition = {\n   *     type: 'input.text',\n   *     title: 'Updated Input Title',\n   *     options: {\n   *         token: 'input2_token',\n   *         defaultValue: 'Default Text Value',\n   *     },\n   * };\n   *\n   * dashboardCoreApi.updateInput({\n   *     id: 'input_2',\n   *     inputDefinition: myUpdatedInputDefinition,\n   * });\n   * ```\n   * @method updateInput\n   * @param {Object} options\n   * @param {String} options.id The ID of the input to be updated\n   * @param {Object} options.inputDefinition New input definition to be applied\n   * @public\n   */\n  updateInput({\n    id,\n    inputDefinition\n  }) {\n    this.store.dispatch(\n      (0, dashboard_state_exports.updateInput)({\n        id,\n        inputDefinition\n      })\n    );\n  }\n  /**\n   * Update the layout.globalInputs section in the definition\n   * ```js\n   * dashboardCoreApi.updateInputStructure(['input_2', 'input_1']);\n   * ```\n   * @method updateInputStructure\n   * @param {String[]} inputStructure input ids\n   * @public\n   */\n  updateInputStructure(inputStructure) {\n    this.store.dispatch((0, dashboard_state_exports.updateInputStructure)(inputStructure));\n  }\n  /**\n   * Fetch the complete SPL search query and query parameters of a data source, including its ancestors\n   * ```js\n   * dashboardCoreApi.getCompleteSearchQueryAndParameters('ds_search1');\n   * ```\n   * @method getCompleteSearchQueryAndParameters\n   * @param {String} dataSourceId ID of the data source to fetch\n   * @returns {Object} Search options including the query and query parameters\n   * @public\n   */\n  getCompleteSearchQueryAndParameters(dataSourceId) {\n    const state = this.store.getState();\n    const definition = dashboard_definition_exports.DashboardDefinition.fromJSON(\n      (0, dashboard_state_exports.selectDefinition)(state)\n    );\n    return (0, datasource_utils_exports.getCompleteSearchQueryAndParameters)({\n      definition,\n      dataSourceId,\n      getMetaData: this.getDataSourceMetaData.bind(this),\n      submittedTokens: (0, dashboard_state_exports.selectSubmittedTokens)(state)\n    });\n  }\n  /**\n   * Update the structure section for the provided layoutId, defaults to active tab's layout\n   * ```js\n   * dashboardCoreApi.updateLayoutStructure([\n   *     {\n   *         \"item\": \"viz_2\",\n   *         \"type\": \"block\",\n   *         \"position\": {\n   *             \"x\": 20,\n   *             \"y\": 20,\n   *             \"w\": 500,\n   *             \"h\": 200\n   *         }\n   *     },\n   *     {\n   *         \"item\": \"viz_1\",\n   *         \"type\": \"block\",\n   *         \"position\": {\n   *             \"x\": 550,\n   *             \"y\": 20,\n   *             \"w\": 500,\n   *             \"h\": 200\n   *         }\n   *     },\n   * ], 'layout_1');\n   * ```\n   * @method updateLayoutStructure\n   * @param {Object} layoutStructure layout structure to be used\n   * @param {String} [layoutId=<activeTab>] layout to be updated\n   * @public\n   */\n  updateLayoutStructure(layoutStructure, layoutId) {\n    this.store.dispatch((0, dashboard_state_exports.updateLayoutStructure)(layoutStructure, layoutId));\n  }\n  /**\n   * Update the .layout.options section of the current dashboard definition\n   * ```js\n   * dashboardCoreApi.updateGlobalLayoutOptions({\n   *     submitButton: true,\n   *     submitOnDashboardLoad: true,\n   * });\n   * ```\n   * @method updateGlobalLayoutOptions\n   * @param {Object} options layout options to be used\n   * @public\n   */\n  updateGlobalLayoutOptions(options) {\n    this.store.dispatch((0, dashboard_state_exports.updateGlobalLayoutOptions)(options));\n  }\n  /**\n   * Update the options for a specific layout in the current dashboard definition\n   * ```js\n   * dashboardCoreApi.updateLayoutOptions({\n   *     width: 1000,\n   * });\n   * ```\n   * @method updateLayoutOptions\n   * @param {Object} options layout options to be used\n   * @param {String} [layoutId=<activeTab>] layout to update\n   * @public\n   */\n  updateLayoutOptions(options, layoutId) {\n    this.store.dispatch((0, dashboard_state_exports.updateLayoutOptions)(options, layoutId));\n  }\n  /**\n   * Moves an input from the global input container to the dashboard canvas\n   * ```js\n   * dashboardCoreApi.moveInputToCanvas('input_2');\n   * ```\n   * @method moveInputToCanvas\n   * @param {string} inputId The ID of the input to be moved to the dashboard canvas\n   * @param {String} [layoutId=<activeTab>] layout to update\n   * @public\n   */\n  moveInputToCanvas(inputId, layoutId) {\n    const activeLayout = layoutId != null ? layoutId : this.activeLayoutId;\n    this.store.dispatch((0, dashboard_state_exports.moveInputToCanvas)(inputId, activeLayout));\n  }\n  /**\n   * Moves an input from the dashboard canvas to the global input container\n   * ```js\n   * dashboardCoreApi.moveInputToGlobalInputs('input_2');\n   * ```\n   * @method moveInputToGlobalInputs\n   * @param {string} inputId The ID of the input to be moved to the global input container\n   * @param {String} [layoutId=<activeTab>] layout to update\n   * @public\n   */\n  moveInputToGlobalInputs(inputId, layoutId) {\n    const activeLayout = layoutId != null ? layoutId : this.activeLayoutId;\n    this.store.dispatch(\n      (0, dashboard_state_exports.moveInputToGlobalInputs)(inputId, activeLayout)\n    );\n  }\n  /**\n   * Switch between view and edit modes\n   * ```\n   * dashboardCoreApi.switchMode('edit');\n   * ```\n   * @method switchMode\n   * @param {String} mode New mode, either `edit` or `view`\n   * @public\n   */\n  switchMode(mode) {\n    this.store.dispatch((0, dashboard_state_exports.switchMode)(mode));\n  }\n  /**\n   * Select items on the dashboard.\n   *\n   * If one or more items to select exist in `globalInputs` any in-canvas items will not be selected.\n   * @param {SelectedItem[]} [selectedItems=[]] The items to select\n   * @public\n   * ```js\n   * dashboardCoreApi.updateSelectedItems([{ item: 'viz_1', type: 'block' }, { item: 'input_1', type: 'input' }]);\n   * ```\n   */\n  updateSelectedItems(selectedItems = []) {\n    var _a;\n    this.store.dispatch((0, dashboard_state_exports.updateSelectedItems)(selectedItems));\n    if (selectedItems.length === 0) {\n      this.store.dispatch((0, dashboard_state_exports.updateSelectedGlobalItems)([]));\n    } else {\n      const globals = (_a = (0, dashboard_state_exports.selectGlobalInputs)(this.store.getState())) != null ? _a : [];\n      const globalsToSelect = selectedItems.filter(\n        ({ id, type }) => type === \"input\" && globals.includes(id)\n      );\n      this.store.dispatch((0, dashboard_state_exports.updateSelectedGlobalItems)(globalsToSelect));\n    }\n  }\n  /**\n   * Fetch the current active tab\n   * @method getActiveTab\n   * @returns {String} The current active tab\n   * @public\n   */\n  getActiveTab() {\n    return (0, dashboard_state_exports.selectActiveTab)(this.store.getState());\n  }\n  /**\n   * Set the active tab if tab id is in definition\n   * If tabId is not defined or active tab is already tabId, it does nothing.\n   * @param {tab} LayoutId The tab to select\n   * @public\n   */\n  setActiveTab(tabId) {\n    const activeTab = this.getActiveTab();\n    if (tabId === activeTab) {\n      return;\n    }\n    const itemIds = (0, dashboard_state_exports.selectTabs)(this.store.getState()).map(\n      (item) => item.layoutId\n    );\n    if (itemIds.includes(tabId)) {\n      this.store.dispatch((0, dashboard_state_exports.setActiveTab)(tabId));\n    }\n  }\n  /**\n   * Replace the applicationProperties' definition.\n   * ```js\n   * dashboardCoreApi.updateApplicationProperties({\n   *     foo: 'bar'\n   * });\n   * ```\n   * @method updateApplicationProperties\n   * @param {Object} applicationProperties A new application properties to be applied.\n   * @public\n   */\n  updateApplicationProperties(applicationProperties) {\n    this.store.dispatch((0, dashboard_state_exports.updateApplicationProperties)(applicationProperties));\n  }\n  /**\n   * Get the applicationProperties' definition or undefined if none exist.\n   * ```js\n   * dashboardCoreApi.getApplicationProperties();\n   * ```\n   * @method getApplicationProperties\n   * @returns {Object | undefined} The application properties or undefined if none exist.\n   * @public\n   */\n  getApplicationProperties() {\n    return (0, dashboard_state_exports.selectApplicationProperties)(this.store.getState());\n  }\n};\nvar createDashboardApi = (options) => new DashboardCoreApi(options);\n\n// src/DashboardCoreApiContext/DashboardCoreApiContext.tsx\nvar DashboardCoreApiContext = react_default.createContext(null);\nvar DashboardCoreApiProvider = DashboardCoreApiContext.Provider;\nvar DashboardCoreApiConsumer = DashboardCoreApiContext.Consumer;\nvar DashboardCoreApiContextWrapper = ({\n  children\n}) => {\n  const store = (0, dashboard_state_exports.useStore)();\n  const dataSourceRegistry = useDataSourceRegistry();\n  const apiRegistry = useApiRegistry();\n  const apiRef = (0, react_exports.useRef)(null);\n  if (apiRef.current === null) {\n    apiRef.current = createDashboardApi({\n      store,\n      apiRegistry,\n      dataSourceRegistry\n    });\n  }\n  return /* @__PURE__ */ react_default.createElement(DashboardCoreApiProvider, { value: apiRef.current }, children);\n};\nvar useDashboardCoreApi = () => {\n  const ctx = (0, react_exports.useContext)(DashboardCoreApiContext);\n  if (ctx === null) {\n    throw new Error(\n      \"useDashboardCoreApi can only be used in a component that is a child of a DashboardCoreApiProvider\"\n    );\n  }\n  return ctx;\n};\n\n// src/ElementRefContext/ElementRefContext.ts\nvar DefaultElementRefs = {\n  header: {\n    container: (0, react_exports.createRef)(),\n    title: (0, react_exports.createRef)(),\n    description: (0, react_exports.createRef)(),\n    collapseHandle: (0, react_exports.createRef)()\n  },\n  tabs: {\n    container: (0, react_exports.createRef)(),\n    addTab: (0, react_exports.createRef)(),\n    importTab: (0, react_exports.createRef)()\n  }\n};\nvar ElementRefContext = (0, react_exports.createContext)(DefaultElementRefs);\nvar ElementRefContextProvider = ElementRefContext.Provider;\nvar useElementRefs = () => (0, react_exports.useContext)(ElementRefContext);\nvar useHeaderRef = (key) => {\n  const refs = (0, react_exports.useContext)(ElementRefContext);\n  return refs.header[key];\n};\nvar useTabsRef = (key) => {\n  const refs = (0, react_exports.useContext)(ElementRefContext);\n  return refs.tabs[key];\n};\n\n// src/DashboardContext.tsx\nvar DocumentationLinksContext = (0, react_exports.createContext)({});\nvar tuple = (arg0, arg1) => [arg0, arg1];\nvar contextComposer = (prev, next) => {\n  const [Context, props = {}] = next;\n  return react_default.createElement(Context, props, prev);\n};\nvar DashboardContext = (0, react_exports.createContext)({});\nvar EMPTY_FEATURE_FLAGS = Object.freeze({});\nvar createFeatureFlags = memoize_one_default(\n  (flags = EMPTY_FEATURE_FLAGS) => __spreadValues(__spreadValues({}, FeatureFlags_default2), flags),\n  (newArgs, oldArgs) => newArgs === oldArgs || JSON.stringify(newArgs) === JSON.stringify(oldArgs)\n);\nvar defaultMapTileConfig = { defaultTileConfig: MapContext_exports.testTileConfig };\nvar defaultEventsConfig = {\n  eventActions: [],\n  fieldActions: {},\n  isSplunkWebAvailable: false\n};\nvar defaultDashboardPlugin = Object.freeze({});\nvar emptyDocsLinks = {};\nvar ContextProvider = ({\n  children,\n  contentExportClient,\n  dataSourceContext = defaultDataSourceContextValue,\n  featureFlags,\n  geoRegistry,\n  iconRegistry,\n  imageRegistry,\n  keyboardListener,\n  logger,\n  userMessage,\n  metricsCollectors,\n  timezone,\n  documentationLinks: docLinks = emptyDocsLinks,\n  mapTileConfig,\n  eventsConfig,\n  preset: presetDefinition,\n  initialDefinition,\n  initialTokenBinding,\n  initialReadOnlyTokenNamespaces,\n  initialMode = \"view\",\n  initialTab,\n  initialSelectedItems,\n  dashboardPlugin,\n  onTokenBindingChange,\n  onDefinitionChange,\n  onActiveTabChange,\n  onModeChange,\n  onItemsSelect\n}) => {\n  const initialDefinitionRef = (0, react_exports.useRef)(initialDefinition);\n  const initialTokenBindingRef = (0, react_exports.useRef)(initialTokenBinding);\n  const initialReadOnlyTokenNamespacesRef = (0, react_exports.useRef)(\n    initialReadOnlyTokenNamespaces\n  );\n  const initialModeRef = (0, react_exports.useRef)(initialMode);\n  const initialTabRef = (0, react_exports.useRef)(initialTab);\n  const initialSelectedItemsRef = (0, react_exports.useRef)(initialSelectedItems);\n  (0, react_exports.useEffect)(() => {\n    if (!keyboardListener) {\n      return void 0;\n    }\n    keyboardListener.setup();\n    return () => keyboardListener.teardown();\n  }, [keyboardListener]);\n  const coalescedEventsConfig = (0, react_exports.useMemo)(\n    () => eventsConfig != null ? eventsConfig : defaultEventsConfig,\n    [eventsConfig]\n  );\n  const coalescedMapTileConfig = (0, react_exports.useMemo)(\n    () => mapTileConfig != null ? mapTileConfig : defaultMapTileConfig,\n    [mapTileConfig]\n  );\n  const featureFlagList = createFeatureFlags(featureFlags);\n  const vizMessages = (0, react_exports.useMemo)(\n    () => ({ cspMessageLink: docLinks.cspMessageLink }),\n    [docLinks]\n  );\n  const preset = (0, react_exports.useMemo)(\n    () => new Preset({\n      presetDefinition: updatePreset(presetDefinition),\n      featureFlags: featureFlagList,\n      SnapshotDataSource: datasources_exports.SnapshotDataSource\n    }),\n    [presetDefinition, featureFlagList]\n  );\n  const value = (0, react_exports.useMemo)(\n    () => ({\n      contentExportClient,\n      featureFlags: featureFlagList,\n      geoRegistry,\n      iconRegistry,\n      imageRegistry,\n      keyboardListener,\n      logger,\n      userMessage\n    }),\n    [\n      contentExportClient,\n      featureFlagList,\n      geoRegistry,\n      iconRegistry,\n      imageRegistry,\n      keyboardListener,\n      logger,\n      userMessage\n    ]\n  );\n  const collector = (0, react_exports.useMemo)(\n    () => createCollector({\n      initialDefinition: initialDefinitionRef.current\n    }),\n    []\n  );\n  const pluginRef = (0, react_exports.useRef)(defaultDashboardPlugin);\n  pluginRef.current = dashboardPlugin != null ? dashboardPlugin : defaultDashboardPlugin;\n  const wrappedPlugin = (0, react_exports.useMemo)(\n    () => createPlugin({\n      plugin: pluginRef,\n      collector\n    }),\n    [collector]\n  );\n  const dashboardPluginContextValue = (0, react_exports.useMemo)(\n    () => [wrappedPlugin, collector],\n    [wrappedPlugin, collector]\n  );\n  const stateProviderValue = (0, react_exports.useMemo)(\n    () => ({\n      preset,\n      featureFlags: featureFlagList,\n      initialDefinition: initialDefinitionRef.current,\n      initialTokenBinding: initialTokenBindingRef.current,\n      initialReadOnlyTokenNamespaces: initialReadOnlyTokenNamespacesRef.current,\n      initialMode: initialModeRef.current,\n      initialTab: initialTabRef.current,\n      initialSelectedItems: initialSelectedItemsRef.current,\n      dashboardPlugin: wrappedPlugin\n    }),\n    [preset, featureFlagList, wrappedPlugin]\n  );\n  const contexts = (0, react_exports.useMemo)(\n    () => [\n      // Highest in the tree\n      tuple(DashboardContext.Provider, { value }),\n      tuple(DataSourceContextProvider, { value: dataSourceContext }),\n      tuple(dashboard_telemetry_exports.TelemetryContextProvider, { metricsCollectors }),\n      tuple(DashboardPluginContextProvider, {\n        value: dashboardPluginContextValue\n      }),\n      tuple(FeatureFlagContext_exports.FeatureFlagContextProvider, { value: featureFlagList }),\n      tuple(GeoContext_exports.GeoContextProvider, { value: geoRegistry }),\n      tuple(ImageContext_exports.ImageContextProvider, { value: imageRegistry }),\n      tuple(IconContext_exports.IconContextProvider, { value: iconRegistry }),\n      tuple(TimezoneContext_exports.TimezoneContextProvider, { value: timezone }),\n      tuple(MapContext_exports.MapContextProvider, { value: coalescedMapTileConfig }),\n      tuple(EventsContext_exports.EventsContextProvider, { value: coalescedEventsConfig }),\n      tuple(DocumentationLinksContext.Provider, {\n        value: docLinks\n      }),\n      tuple(MessageContext_exports.MessageContextProvider, { value: vizMessages }),\n      tuple(dashboard_state_exports.StateProvider, stateProviderValue),\n      tuple(LayoutLayersContextProvider),\n      tuple(RegistryContext_default, { dataSourceContext, preset }),\n      // DashboardCoreApiContextWrapper must be rendered below StateProvider and RegistryContextProvider\n      tuple(DashboardCoreApiContextWrapper),\n      // ** Parent of DragAndDropContextProvider must have type `children: React.ReactFragment`\n      tuple(DragAndDropContextProvider),\n      tuple(SidebarContextProvider),\n      tuple(SearchContextProvider),\n      tuple(ElementRefContextProvider, { value: DefaultElementRefs })\n      // Lowest in the tree\n    ],\n    [\n      value,\n      dataSourceContext,\n      docLinks,\n      featureFlagList,\n      geoRegistry,\n      iconRegistry,\n      imageRegistry,\n      coalescedMapTileConfig,\n      coalescedEventsConfig,\n      metricsCollectors,\n      preset,\n      stateProviderValue,\n      timezone,\n      vizMessages,\n      dashboardPluginContextValue\n    ]\n  );\n  return contexts.reduceRight(\n    contextComposer,\n    /* @__PURE__ */ react_default.createElement(\n      OnChangeCallbacks,\n      {\n        initialTokenBinding: initialTokenBindingRef.current,\n        onTokenBindingChange,\n        onDefinitionChange,\n        onActiveTabChange,\n        onModeChange,\n        onItemsSelect\n      },\n      children\n    )\n  );\n};\nvar DashboardContextProvider = (props) => /* @__PURE__ */ react_default.createElement(DashboardContextErrorBoundary_default, null, /* @__PURE__ */ react_default.createElement(ContextProvider, __spreadValues({}, props)));\nDashboardContextProvider.propTypes = {\n  /**\n   * an icon registry instance\n   */\n  iconRegistry: prop_types_default.object,\n  /**\n   * an image registry instance\n   */\n  imageRegistry: prop_types_default.object,\n  /**\n   * a geo registry instance\n   */\n  geoRegistry: prop_types_default.object,\n  /**\n   * global keyboard listener\n   */\n  keyboardListener: prop_types_default.instanceOf(KeyboardListener_default),\n  /**\n   * global datasource context object\n   */\n  dataSourceContext: prop_types_default.object,\n  /**\n   * Client implementation of API workflow with Content Export service\n   */\n  contentExportClient: prop_types_default.object,\n  /**\n   * Collection of feature flags to override/introduce\n   */\n  featureFlags: prop_types_default.object,\n  /**\n   * children node\n   */\n  children: prop_types_default.any,\n  /**\n   * logger for error, warning, and info level events\n   */\n  logger: prop_types_default.object,\n  /**\n   * Callback for messages to display to user.\n   *\n   * Callback function parameters can expect this object interface as a first parameter:\n   * {\n   *     level: 'error' | 'warning' | 'info'\n   *     message: String\n   *     sender?: String\n   *     stackTrace?: String\n   * }\n   *\n   * For example, the callback could expect this object to contain these parameters:\n   * {\n   *     level: 'error',\n   *     message: 'Example message to deliver to user.',\n   *     sender: 'GridLayout', // optional parameter.\n   *     stackTrace: 'Example stack trace' // optional parameter.\n   * }\n   */\n  userMessage: prop_types_default.func,\n  /**\n   * list of user defined metrics collectors that send telemetry data to their backend API\n   */\n  metricsCollectors: prop_types_default.oneOfType([prop_types_default.object, prop_types_default.array]),\n  /**\n   * Pass timezone data in at least one format to have time data formatted in charts\n   */\n  timezone: prop_types_default.shape({\n    ianaTimezone: prop_types_default.string,\n    serializedTimezone: prop_types_default.string,\n    utcOffset: prop_types_default.number\n  }),\n  /**\n   * Initial dashboard definition\n   */\n  initialDefinition: prop_types_default.object,\n  /**\n   * Initial token binding\n   */\n  initialTokenBinding: prop_types_default.object,\n  /**\n   * Initial mode\n   */\n  initialMode: prop_types_default.oneOf([\"view\", \"edit\"]),\n  /**\n   * Items to be initially selected\n   */\n  initialSelectedItems: prop_types_default.array,\n  /**\n   * A callback for when the tokenBinding change\n   */\n  onTokenBindingChange: prop_types_default.func,\n  /**\n   * A callback for when the definition changes\n   */\n  onDefinitionChange: prop_types_default.func,\n  /**\n   * A callback for when the active tab changes\n   */\n  onActiveTabChange: prop_types_default.func,\n  /**\n   * A callback for when the mode changes\n   */\n  onModeChange: prop_types_default.func,\n  /**\n   * A callback for when the selected items change\n   */\n  onItemsSelect: prop_types_default.func,\n  /**\n   * Documentation links\n   */\n  documentationLinks: prop_types_default.object,\n  /**\n   * preset\n   */\n  preset: prop_types_default.object\n};\nDashboardContextProvider.defaultProps = {\n  keyboardListener: new KeyboardListener_default(),\n  userMessage: ({ message }) => dashboard_utils_exports.console.log(message),\n  timezone: {},\n  initialDefinition: dashboard_definition_exports.DEFAULT_DEFINITION,\n  preset: {}\n};\nvar DashboardContextConsumer = DashboardContext.Consumer;\nvar useFeatureFlags = () => {\n  const { featureFlags = FeatureFlags_default2 } = (0, react_exports.useContext)(DashboardContext);\n  return featureFlags;\n};\nvar useImageRegistry = () => {\n  const { imageRegistry } = (0, react_exports.useContext)(DashboardContext);\n  return imageRegistry;\n};\nvar useIconRegistry = () => {\n  const { iconRegistry } = (0, react_exports.useContext)(DashboardContext);\n  return iconRegistry;\n};\nvar useUserMessageAPI = () => {\n  const { userMessage } = (0, react_exports.useContext)(DashboardContext);\n  return userMessage;\n};\nvar useDocumentationLinks = () => (0, react_exports.useContext)(DocumentationLinksContext);\nvar useKeyboardListener = () => {\n  const { keyboardListener } = (0, react_exports.useContext)(DashboardContext);\n  return keyboardListener;\n};\nvar useLogger = () => {\n  const { logger } = (0, react_exports.useContext)(DashboardContext);\n  return logger;\n};\n\n// src/DashboardApiContext.ts\nvar DashboardApiContext = react_default.createContext(\n  null\n);\nvar DashboardApiProvider = DashboardApiContext.Provider;\nvar DashboardApiConsumer = DashboardApiContext.Consumer;\nvar useDashboardApi = () => {\n  const ctx = (0, react_exports.useContext)(DashboardApiContext);\n  if (ctx === null) {\n    throw new Error(\n      \"useDashboardApi can only be used in a component that is a child of a DashboardApiProvider\"\n    );\n  }\n  return ctx;\n};\n\n// src/CanvasContext.ts\nvar defaultRef = react_default.createRef();\nvar CanvasContext = (0, react_exports.createContext)(defaultRef);\nvar useCanvas = () => (0, react_exports.useContext)(CanvasContext);\nvar CanvasContext_default = CanvasContext;\n\n// src/BaseContentExportClient.ts\nvar BaseContentExportClient = class {\n  initiateExport() {\n    return __async(this, null, function* () {\n      throw new Error((0, i18n_exports._)(\"initiateExport() not implemented.\"));\n    });\n  }\n};\nvar BaseContentExportClient_default = BaseContentExportClient;\n\n// esm-externals:@splunk/visualization-context/GeoJsonProvider\nvar GeoJsonProvider_exports = {};\n__export(GeoJsonProvider_exports, {\n  default: () => GeoJsonProvider_default\n});\nvar defaultImport31 = __toESM(require(\"@splunk/visualization-context/GeoJsonProvider\"));\n__reExport(GeoJsonProvider_exports, require(\"@splunk/visualization-context/GeoJsonProvider\"));\nvar GeoJsonProvider_default = \"default\" in defaultImport31 ? defaultImport31.default : defaultImport31;\n\n// esm-externals:@splunk/visualization-context/GeoRegistry\nvar GeoRegistry_exports = {};\n__export(GeoRegistry_exports, {\n  default: () => GeoRegistry_default\n});\nvar defaultImport32 = __toESM(require(\"@splunk/visualization-context/GeoRegistry\"));\n__reExport(GeoRegistry_exports, require(\"@splunk/visualization-context/GeoRegistry\"));\nvar GeoRegistry_default = \"default\" in defaultImport32 ? defaultImport32.default : defaultImport32;\n\n// esm-externals:@splunk/visualization-context/IconRegistry\nvar IconRegistry_exports = {};\n__export(IconRegistry_exports, {\n  default: () => IconRegistry_default\n});\nvar defaultImport33 = __toESM(require(\"@splunk/visualization-context/IconRegistry\"));\n__reExport(IconRegistry_exports, require(\"@splunk/visualization-context/IconRegistry\"));\nvar IconRegistry_default = \"default\" in defaultImport33 ? defaultImport33.default : defaultImport33;\n\n// esm-externals:@splunk/visualization-context/ImageRegistry\nvar ImageRegistry_exports = {};\n__export(ImageRegistry_exports, {\n  default: () => ImageRegistry_default\n});\nvar defaultImport34 = __toESM(require(\"@splunk/visualization-context/ImageRegistry\"));\n__reExport(ImageRegistry_exports, require(\"@splunk/visualization-context/ImageRegistry\"));\nvar ImageRegistry_default = \"default\" in defaultImport34 ? defaultImport34.default : defaultImport34;\n\n// esm-externals:@splunk/visualization-context/LocalIconProvider\nvar LocalIconProvider_exports = {};\n__export(LocalIconProvider_exports, {\n  default: () => LocalIconProvider_default\n});\nvar defaultImport35 = __toESM(require(\"@splunk/visualization-context/LocalIconProvider\"));\n__reExport(LocalIconProvider_exports, require(\"@splunk/visualization-context/LocalIconProvider\"));\nvar LocalIconProvider_default = \"default\" in defaultImport35 ? defaultImport35.default : defaultImport35;\n\n// esm-externals:@splunk/visualization-context/LocalImageProvider\nvar LocalImageProvider_exports = {};\n__export(LocalImageProvider_exports, {\n  default: () => LocalImageProvider_default\n});\nvar defaultImport36 = __toESM(require(\"@splunk/visualization-context/LocalImageProvider\"));\n__reExport(LocalImageProvider_exports, require(\"@splunk/visualization-context/LocalImageProvider\"));\nvar LocalImageProvider_default = \"default\" in defaultImport36 ? defaultImport36.default : defaultImport36;\n\n// esm-externals:@splunk/visualization-context/MockedProvider\nvar MockedProvider_exports = {};\n__export(MockedProvider_exports, {\n  default: () => MockedProvider_default\n});\nvar defaultImport37 = __toESM(require(\"@splunk/visualization-context/MockedProvider\"));\n__reExport(MockedProvider_exports, require(\"@splunk/visualization-context/MockedProvider\"));\nvar MockedProvider_default = \"default\" in defaultImport37 ? defaultImport37.default : defaultImport37;\n\n// esm-externals:@splunk/visualization-context/Provider\nvar Provider_exports = {};\n__export(Provider_exports, {\n  default: () => Provider_default\n});\nvar defaultImport38 = __toESM(require(\"@splunk/visualization-context/Provider\"));\n__reExport(Provider_exports, require(\"@splunk/visualization-context/Provider\"));\nvar Provider_default = \"default\" in defaultImport38 ? defaultImport38.default : defaultImport38;\n\n// esm-externals:react-dom/server\nvar server_exports = {};\n__export(server_exports, {\n  default: () => server_default\n});\nvar defaultImport39 = __toESM(require(\"react-dom/server\"));\n__reExport(server_exports, require(\"react-dom/server\"));\nvar server_default = \"default\" in defaultImport39 ? defaultImport39.default : defaultImport39;\n\n// esm-externals:@splunk/dashboard-icons\nvar dashboard_icons_exports = {};\n__export(dashboard_icons_exports, {\n  default: () => dashboard_icons_default\n});\nvar defaultImport40 = __toESM(require(\"@splunk/dashboard-icons\"));\n__reExport(dashboard_icons_exports, require(\"@splunk/dashboard-icons\"));\nvar dashboard_icons_default = \"default\" in defaultImport40 ? defaultImport40.default : defaultImport40;\n\n// src/StandardIconProvider.tsx\nvar toDataURI = (SVG) => `data:image/svg+xml;base64,${btoa((0, server_exports.renderToStaticMarkup)(/* @__PURE__ */ react_default.createElement(SVG, null)))}`;\nvar defaultIconList = {\n  activeDirectory: {\n    dataURI: toDataURI(dashboard_icons_exports.ActiveDirectory),\n    metaData: {\n      name: \"Active Directory\"\n    }\n  },\n  check: {\n    dataURI: toDataURI(dashboard_icons_exports.Check),\n    metaData: {\n      name: \"Check\"\n    }\n  },\n  cloud: {\n    dataURI: toDataURI(dashboard_icons_exports.Cloud),\n    metaData: {\n      name: \"Cloud\"\n    }\n  },\n  datacenter: {\n    dataURI: toDataURI(dashboard_icons_exports.Datacenter),\n    metaData: {\n      name: \"Datacenter\"\n    }\n  },\n  datacenters: {\n    dataURI: toDataURI(dashboard_icons_exports.Datacenters),\n    metaData: {\n      name: \"Datacenters\"\n    }\n  },\n  datastore: {\n    dataURI: toDataURI(dashboard_icons_exports.Datastore),\n    metaData: {\n      name: \"Datastore\"\n    }\n  },\n  datastores: {\n    dataURI: toDataURI(dashboard_icons_exports.Datastores),\n    metaData: {\n      name: \"Datastores\"\n    }\n  },\n  desktop: {\n    dataURI: toDataURI(dashboard_icons_exports.Desktop),\n    metaData: {\n      name: \"Desktop\"\n    }\n  },\n  firewall: {\n    dataURI: toDataURI(dashboard_icons_exports.Firewall),\n    metaData: {\n      name: \"Firewall\"\n    }\n  },\n  gear: {\n    dataURI: toDataURI(dashboard_icons_exports.Gear),\n    metaData: {\n      name: \"Gear\"\n    }\n  },\n  laptop: {\n    dataURI: toDataURI(dashboard_icons_exports.Laptop),\n    metaData: {\n      name: \"Laptop\"\n    }\n  },\n  loadBalancer: {\n    dataURI: toDataURI(dashboard_icons_exports.LoadBalancer),\n    metaData: {\n      name: \"Load Balancer\"\n    }\n  },\n  mobile: {\n    dataURI: toDataURI(dashboard_icons_exports.Mobile),\n    metaData: {\n      name: \"Mobile\"\n    }\n  },\n  profile: {\n    dataURI: toDataURI(dashboard_icons_exports.Profile),\n    metaData: {\n      name: \"Profile\"\n    }\n  },\n  server: {\n    dataURI: toDataURI(dashboard_icons_exports.Server),\n    metaData: {\n      name: \"Server\"\n    }\n  },\n  users: {\n    dataURI: toDataURI(dashboard_icons_exports.Users),\n    metaData: {\n      name: \"Users\"\n    }\n  }\n};\nvar StandardIconProvider = class extends Provider_default {\n  constructor({ iconList } = {}) {\n    super();\n    this.iconList = __spreadValues(__spreadValues({}, iconList), defaultIconList);\n  }\n  /**\n   * return provider type\n   * @return {String} 'splunk-default'\n   */\n  getType() {\n    return \"splunk-default\";\n  }\n  /**\n   * upload one new icon\n   */\n  upload() {\n    return __async(this, null, function* () {\n      throw new Error(\n        (0, i18n_exports._)(\"Can not upload icons to the standard icon provider.\")\n      );\n    });\n  }\n  /**\n   * get one icon by icon id\n   */\n  getById(id) {\n    return __async(this, null, function* () {\n      if (this.iconList[id]) {\n        return this.iconList[id];\n      }\n      throw new Error((0, i18n_exports._)(\"The icon is not found.\"));\n    });\n  }\n  /**\n   * get all icon ids\n   * @params options\n   * @params options.meta   a list of meta data attribute that would be returned with each id\n   * @params options.search  a search string to filter the returned icons\n   */\n  listIds() {\n    return __async(this, arguments, function* ({\n      offset = 0,\n      count = 100,\n      meta = [],\n      search = null\n    } = {}) {\n      try {\n        const icons = this.iconList;\n        const results = [];\n        Object.keys(icons).sort().slice(offset, count).forEach((id) => {\n          const icon = { id };\n          const iconMeta = icons[id].metaData || {};\n          const isSearchedIcon = search != null && Object.keys(iconMeta).some((attr) => {\n            const iconMetaValue = iconMeta[attr].toLowerCase();\n            return iconMetaValue.indexOf(search.toLowerCase()) > -1;\n          });\n          if (search == null || isSearchedIcon) {\n            if (meta && meta.length) {\n              icon.metaData = {};\n              meta.forEach((attr) => {\n                if (iconMeta[attr] != null && icon.metaData) {\n                  icon.metaData[attr] = iconMeta[attr];\n                }\n              });\n            }\n            results.push(icon);\n          }\n        });\n        return results;\n      } catch (error) {\n        throw new Error((0, i18n_exports._)(\"The icon ids cannot be listed.\"));\n      }\n    });\n  }\n  /**\n   * delete an icon by icon id\n   */\n  deleteById() {\n    return __async(this, null, function* () {\n      throw new Error((0, i18n_exports._)(\"The icon cannot be deleted.\"));\n    });\n  }\n};\nvar StandardIconProvider_default = StandardIconProvider;\n\n// src/CoreOverridesContext.tsx\nvar CoreOverridesContext = react_default.createContext({});\nvar useCoreOverrides = () => {\n  return (0, react_exports.useContext)(CoreOverridesContext);\n};\n//# sourceMappingURL=index.js.map\n","/* Copyright © 2020 Splunk Inc.\nSPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or\nin part without a valid written license from Splunk Inc. is PROHIBITED. */\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  DashboardCore: () => DashboardCore2,\n  default: () => src_default\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// esm-externals:lodash\nvar lodash_exports = {};\n__export(lodash_exports, {\n  default: () => lodash_default\n});\nvar defaultImport = __toESM(require(\"lodash\"));\n__reExport(lodash_exports, require(\"lodash\"));\nvar lodash_default = \"default\" in defaultImport ? defaultImport.default : defaultImport;\n\n// esm-externals:react\nvar react_exports = {};\n__export(react_exports, {\n  default: () => react_default\n});\nvar defaultImport2 = __toESM(require(\"react\"));\n__reExport(react_exports, require(\"react\"));\nvar react_default = \"default\" in defaultImport2 ? defaultImport2.default : defaultImport2;\n\n// esm-externals:@splunk/dashboard-context\nvar dashboard_context_exports = {};\n__export(dashboard_context_exports, {\n  default: () => dashboard_context_default\n});\nvar defaultImport3 = __toESM(require(\"@splunk/dashboard-context\"));\n__reExport(dashboard_context_exports, require(\"@splunk/dashboard-context\"));\nvar dashboard_context_default = \"default\" in defaultImport3 ? defaultImport3.default : defaultImport3;\n\n// esm-externals:@splunk/dashboard-telemetry\nvar dashboard_telemetry_exports = {};\n__export(dashboard_telemetry_exports, {\n  default: () => dashboard_telemetry_default\n});\nvar defaultImport4 = __toESM(require(\"@splunk/dashboard-telemetry\"));\n__reExport(dashboard_telemetry_exports, require(\"@splunk/dashboard-telemetry\"));\nvar dashboard_telemetry_default = \"default\" in defaultImport4 ? defaultImport4.default : defaultImport4;\n\n// esm-externals:@splunk/dashboard-utils\nvar dashboard_utils_exports = {};\n__export(dashboard_utils_exports, {\n  default: () => dashboard_utils_default\n});\nvar defaultImport5 = __toESM(require(\"@splunk/dashboard-utils\"));\n__reExport(dashboard_utils_exports, require(\"@splunk/dashboard-utils\"));\nvar dashboard_utils_default = \"default\" in defaultImport5 ? defaultImport5.default : defaultImport5;\n\n// esm-externals:@splunk/dashboard-state\nvar dashboard_state_exports = {};\n__export(dashboard_state_exports, {\n  default: () => dashboard_state_default\n});\nvar defaultImport6 = __toESM(require(\"@splunk/dashboard-state\"));\n__reExport(dashboard_state_exports, require(\"@splunk/dashboard-state\"));\nvar dashboard_state_default = \"default\" in defaultImport6 ? defaultImport6.default : defaultImport6;\n\n// esm-externals:@splunk/dashboard-validation\nvar dashboard_validation_exports = {};\n__export(dashboard_validation_exports, {\n  default: () => dashboard_validation_default\n});\nvar defaultImport7 = __toESM(require(\"@splunk/dashboard-validation\"));\n__reExport(dashboard_validation_exports, require(\"@splunk/dashboard-validation\"));\nvar dashboard_validation_default = \"default\" in defaultImport7 ? defaultImport7.default : defaultImport7;\n\n// esm-externals:@splunk/dashboard-ui\nvar dashboard_ui_exports = {};\n__export(dashboard_ui_exports, {\n  default: () => dashboard_ui_default\n});\nvar defaultImport8 = __toESM(require(\"@splunk/dashboard-ui\"));\n__reExport(dashboard_ui_exports, require(\"@splunk/dashboard-ui\"));\nvar dashboard_ui_default = \"default\" in defaultImport8 ? defaultImport8.default : defaultImport8;\n\n// esm-externals:styled-components\nvar styled_components_exports = {};\n__export(styled_components_exports, {\n  default: () => styled_components_default\n});\nvar defaultImport9 = __toESM(require(\"styled-components\"));\n__reExport(styled_components_exports, require(\"styled-components\"));\nvar styled_components_default = \"default\" in defaultImport9 ? defaultImport9.default : defaultImport9;\n\n// esm-externals:@dnd-kit/sortable\nvar sortable_exports = {};\n__export(sortable_exports, {\n  default: () => sortable_default\n});\nvar defaultImport10 = __toESM(require(\"@dnd-kit/sortable\"));\n__reExport(sortable_exports, require(\"@dnd-kit/sortable\"));\nvar sortable_default = \"default\" in defaultImport10 ? defaultImport10.default : defaultImport10;\n\n// esm-externals:@splunk/themes/mixins\nvar mixins_exports = {};\n__export(mixins_exports, {\n  default: () => mixins_default\n});\nvar defaultImport11 = __toESM(require(\"@splunk/themes/mixins\"));\n__reExport(mixins_exports, require(\"@splunk/themes/mixins\"));\nvar mixins_default = \"default\" in defaultImport11 ? defaultImport11.default : defaultImport11;\n\n// esm-externals:@dnd-kit/core\nvar core_exports = {};\n__export(core_exports, {\n  default: () => core_default\n});\nvar defaultImport12 = __toESM(require(\"@dnd-kit/core\"));\n__reExport(core_exports, require(\"@dnd-kit/core\"));\nvar core_default = \"default\" in defaultImport12 ? defaultImport12.default : defaultImport12;\n\n// src/hooks/useDashboardDragMonitor.ts\nvar EMPTY_GLOBAL_INPUTS = Object.freeze([]);\nvar useDashboardDragMonitor = () => {\n  const dashboardCoreApi = (0, dashboard_context_exports.useDashboardCoreApi)();\n  const globalInputs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectGlobalInputs);\n  const activeDragId = (0, react_exports.useRef)();\n  (0, react_exports.useEffect)(() => {\n    activeDragId.current = void 0;\n  }, [globalInputs]);\n  const onDragStart = (0, react_exports.useCallback)(({ active }) => {\n    activeDragId.current = !(active == null ? void 0 : active.id) ? void 0 : active.id;\n  }, []);\n  const onDragCancel = (0, react_exports.useCallback)(() => {\n    activeDragId.current = void 0;\n  }, []);\n  const onDragEnd = (0, react_exports.useCallback)(\n    ({ active, over }) => {\n      if (!activeDragId.current || (active == null ? void 0 : active.id) === (over == null ? void 0 : over.id)) {\n        return;\n      }\n      if (!globalInputs || globalInputs.length < 2) {\n        return;\n      }\n      dashboardCoreApi.updateInputStructure(\n        (0, sortable_exports.arrayMove)(\n          globalInputs,\n          globalInputs.indexOf(active.id),\n          globalInputs.indexOf(over.id)\n        )\n      );\n      activeDragId.current = void 0;\n    },\n    [dashboardCoreApi, globalInputs]\n  );\n  (0, core_exports.useDndMonitor)({ onDragStart, onDragCancel, onDragEnd });\n  return globalInputs != null ? globalInputs : EMPTY_GLOBAL_INPUTS;\n};\n\n// esm-externals:@splunk/react-ui/Button\nvar Button_exports = {};\n__export(Button_exports, {\n  default: () => Button_default\n});\nvar defaultImport13 = __toESM(require(\"@splunk/react-ui/Button\"));\n__reExport(Button_exports, require(\"@splunk/react-ui/Button\"));\nvar Button_default = \"default\" in defaultImport13 ? defaultImport13.default : defaultImport13;\n\n// esm-externals:@splunk/react-ui/Modal\nvar Modal_exports = {};\n__export(Modal_exports, {\n  default: () => Modal_default\n});\nvar defaultImport14 = __toESM(require(\"@splunk/react-ui/Modal\"));\n__reExport(Modal_exports, require(\"@splunk/react-ui/Modal\"));\nvar Modal_default = \"default\" in defaultImport14 ? defaultImport14.default : defaultImport14;\n\n// esm-externals:@splunk/themes\nvar themes_exports = {};\n__export(themes_exports, {\n  default: () => themes_default\n});\nvar defaultImport15 = __toESM(require(\"@splunk/themes\"));\n__reExport(themes_exports, require(\"@splunk/themes\"));\nvar themes_default = \"default\" in defaultImport15 ? defaultImport15.default : defaultImport15;\n\n// esm-externals:@splunk/ui-utils/i18n\nvar i18n_exports = {};\n__export(i18n_exports, {\n  default: () => i18n_default\n});\nvar defaultImport16 = __toESM(require(\"@splunk/ui-utils/i18n\"));\n__reExport(i18n_exports, require(\"@splunk/ui-utils/i18n\"));\nvar i18n_default = \"default\" in defaultImport16 ? defaultImport16.default : defaultImport16;\n\n// esm-externals:@splunk/react-ui/Paragraph\nvar Paragraph_exports = {};\n__export(Paragraph_exports, {\n  default: () => Paragraph_default\n});\nvar defaultImport17 = __toESM(require(\"@splunk/react-ui/Paragraph\"));\n__reExport(Paragraph_exports, require(\"@splunk/react-ui/Paragraph\"));\nvar Paragraph_default = \"default\" in defaultImport17 ? defaultImport17.default : defaultImport17;\n\n// esm-externals:@splunk/ui-utils/format\nvar format_exports = {};\n__export(format_exports, {\n  default: () => format_default\n});\nvar defaultImport18 = __toESM(require(\"@splunk/ui-utils/format\"));\n__reExport(format_exports, require(\"@splunk/ui-utils/format\"));\nvar format_default = \"default\" in defaultImport18 ? defaultImport18.default : defaultImport18;\n\n// src/components/ConfirmDeletionModal/useDynamicModalBody.tsx\nvar formatTokenName = ({\n  token,\n  tokenNamespace = dashboard_utils_exports.DEFAULT_TOKEN_NAMESPACE\n}) => {\n  if (!token) {\n    return void 0;\n  }\n  if (tokenNamespace && tokenNamespace !== dashboard_utils_exports.DEFAULT_TOKEN_NAMESPACE) {\n    return `${tokenNamespace}:${token}`;\n  }\n  return token;\n};\nvar EmptyInput = {};\nvar EmptyInputOptions = {};\nvar useDynamicModalBody = ({\n  id,\n  itemDef,\n  template\n}) => {\n  const { title, options: { token, tokenNamespace } = EmptyInputOptions } = itemDef != null ? itemDef : EmptyInput;\n  return (0, react_exports.useMemo)(\n    () => /* @__PURE__ */ react_default.createElement(Paragraph_default, null, (0, format_exports.sprintf)(\n      template,\n      // Ignore sonarqube for the next line. We want empty strings to be coalesced.\n      title || formatTokenName({ token, tokenNamespace }) || id\n      // NOSONAR\n    )),\n    [id, title, token, tokenNamespace, template]\n  );\n};\n\n// src/components/ConfirmDeletionModal/HideOneBody.tsx\nvar DynamicContentTemplate = (0, i18n_exports._)(\n  'Deleting the time range picker \"%s\" might prevent search execution. Instead, you can hide it in View mode.'\n);\nvar StaticContent = /* @__PURE__ */ react_default.createElement(Paragraph_default, null, (0, i18n_exports._)(\"Do you want to continue deleting the time range picker?\"));\nvar HideOneBody = ({\n  id,\n  itemDef\n}) => {\n  const dynamicContent = useDynamicModalBody({\n    id,\n    itemDef,\n    template: DynamicContentTemplate\n  });\n  if (!itemDef) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(react_default.Fragment, null, dynamicContent, StaticContent);\n};\n\n// src/components/ConfirmDeletionModal/DeleteOneBody.tsx\nvar DynamicContentTemplate2 = (0, i18n_exports._)(\n  'You are about to delete the time range picker \"%s\".'\n);\nvar StaticContent2 = /* @__PURE__ */ react_default.createElement(Paragraph_default, null, (0, i18n_exports._)(\"Are you sure?\"));\nvar DeleteOneBody = ({\n  id,\n  itemDef\n}) => {\n  const dynamicContent = useDynamicModalBody({\n    id,\n    itemDef,\n    template: DynamicContentTemplate2\n  });\n  if (!itemDef) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(react_default.Fragment, null, dynamicContent, StaticContent2);\n};\n\n// esm-externals:@splunk/react-ui/List\nvar List_exports = {};\n__export(List_exports, {\n  default: () => List_default\n});\nvar defaultImport19 = __toESM(require(\"@splunk/react-ui/List\"));\n__reExport(List_exports, require(\"@splunk/react-ui/List\"));\nvar List_default = \"default\" in defaultImport19 ? defaultImport19.default : defaultImport19;\n\n// src/components/ConfirmDeletionModal/DeleteMultipleBody.tsx\nvar ContentTemplate = (0, i18n_exports._)(\n  \"You are about to delete %d time range pickers. Are you sure?\"\n);\nvar ListContent = ({\n  id,\n  itemDef\n}) => {\n  const content = useDynamicModalBody({ id, itemDef, template: \"%s\" });\n  return itemDef ? content : null;\n};\nvar DeleteMultipleBody = ({\n  ids,\n  inputs\n}) => /* @__PURE__ */ react_default.createElement(react_default.Fragment, null, /* @__PURE__ */ react_default.createElement(Paragraph_default, null, (0, format_exports.sprintf)(ContentTemplate, ids.length)), /* @__PURE__ */ react_default.createElement(List_default, null, ids.map(\n  (id) => !!(inputs == null ? void 0 : inputs[id]) && /* @__PURE__ */ react_default.createElement(List_default.Item, { key: id }, /* @__PURE__ */ react_default.createElement(ListContent, { id, itemDef: inputs[id] }))\n)));\n\n// src/components/ConfirmDeletionModal/ConfirmationModal.tsx\nvar StyledModal = styled_components_default(Modal_default)`\n    width: 600px;\n    max-width: 90%;\n`;\nvar SecondaryActionButton = styled_components_default(Button_default)`\n    float: left;\n\n    /* More specificity is required else this color declaration is overridden */\n    ${StyledModal} & {\n        color: ${themes_exports.variables.accentColorNegative};\n    }\n`;\nvar DeleteOneInputTitle = (0, i18n_exports._)(\"Delete time range picker\");\nvar DeleteMultipleInputsTitle = (0, i18n_exports._)(\"Delete time range pickers\");\nvar Labels = {\n  cancel: (0, i18n_exports._)(\"Cancel\"),\n  hide: (0, i18n_exports._)(\"Hide\"),\n  yesDelete: (0, i18n_exports._)(\"Yes, delete\")\n};\nvar NoGlobalInputs = [];\nvar ConfirmInputRemovalModal = ({\n  deletionConfirmation: { modalIds, additionalIds }\n}) => {\n  var _a, _b, _c, _d, _e;\n  const { enableShowHide, confirmGlobalTimeRangeDeletion } = (0, dashboard_context_exports.useFeatureFlags)();\n  const dashboardApi = (0, dashboard_context_exports.useDashboardCoreApi)();\n  const dispatch = (0, dashboard_state_exports.useDispatch)();\n  const globalInputIds = (_a = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectGlobalInputs)) != null ? _a : NoGlobalInputs;\n  const canSuggestHide = enableShowHide && modalIds.length === 1 && !(additionalIds == null ? void 0 : additionalIds.length) && globalInputIds.includes(modalIds[0]) && !((_e = (_d = (_c = (_b = dashboardApi.getDefinition().inputs) == null ? void 0 : _b[modalIds[0]]) == null ? void 0 : _c.containerOptions) == null ? void 0 : _d.visibility) == null ? void 0 : _e.hideInViewMode);\n  const { isPrisma } = (0, themes_exports.useSplunkTheme)();\n  const secondaryAppearance = isPrisma ? \"secondary\" : \"pill\";\n  const handleCancel = (0, react_exports.useCallback)(() => {\n    dispatch((0, dashboard_state_exports.setConfirmDeletionIds)());\n  }, [dispatch]);\n  const handleHide = (0, react_exports.useCallback)(() => {\n    (0, dashboard_state_exports.batch)(() => {\n      dispatch(\n        (0, dashboard_state_exports.setItemVisibility)({\n          itemId: modalIds[0],\n          itemType: \"input\",\n          property: \"hideInViewMode\",\n          value: true\n        })\n      );\n      dispatch((0, dashboard_state_exports.setConfirmDeletionIds)());\n    });\n  }, [dispatch, modalIds]);\n  const handleDelete = (0, react_exports.useCallback)(() => {\n    (0, dashboard_state_exports.batch)(() => {\n      dashboardApi.removeDashboardItems([\n        ...modalIds,\n        ...additionalIds != null ? additionalIds : []\n      ]);\n      dispatch((0, dashboard_state_exports.setConfirmDeletionIds)());\n    });\n  }, [additionalIds, modalIds, dashboardApi, dispatch]);\n  (0, react_exports.useEffect)(() => {\n    if (!confirmGlobalTimeRangeDeletion) {\n      handleDelete();\n    }\n  }, [handleDelete, confirmGlobalTimeRangeDeletion]);\n  const modalBody = (0, react_exports.useMemo)(() => {\n    var _a2;\n    const inputs = (_a2 = dashboardApi.getDefinition().inputs) != null ? _a2 : {};\n    if (canSuggestHide) {\n      const [id] = modalIds;\n      return /* @__PURE__ */ react_default.createElement(HideOneBody, { id, itemDef: inputs[id] });\n    }\n    return modalIds.length === 1 ? /* @__PURE__ */ react_default.createElement(DeleteOneBody, { id: modalIds[0], itemDef: inputs[modalIds[0]] }) : /* @__PURE__ */ react_default.createElement(DeleteMultipleBody, { ids: modalIds, inputs });\n  }, [canSuggestHide, dashboardApi, modalIds]);\n  const modalTitle = modalIds.length === 1 ? DeleteOneInputTitle : DeleteMultipleInputsTitle;\n  if (!confirmGlobalTimeRangeDeletion) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(\n    StyledModal,\n    {\n      \"data-test\": \"confirm-trp-deletion-modal\",\n      onRequestClose: handleCancel,\n      open: true\n    },\n    /* @__PURE__ */ react_default.createElement(Modal_default.Header, { title: modalTitle, onRequestClose: handleCancel }),\n    /* @__PURE__ */ react_default.createElement(Modal_default.Body, null, modalBody),\n    /* @__PURE__ */ react_default.createElement(Modal_default.Footer, null, canSuggestHide && /* @__PURE__ */ react_default.createElement(\n      SecondaryActionButton,\n      {\n        \"data-test\": \"delete-input-button\",\n        appearance: secondaryAppearance,\n        onClick: handleDelete,\n        label: Labels.yesDelete\n      }\n    ), /* @__PURE__ */ react_default.createElement(\n      Button_default,\n      {\n        \"data-test\": \"cancel-button\",\n        appearance: secondaryAppearance,\n        onClick: handleCancel,\n        label: Labels.cancel\n      }\n    ), canSuggestHide ? /* @__PURE__ */ react_default.createElement(\n      Button_default,\n      {\n        \"data-test\": \"hide-input-button\",\n        appearance: \"primary\",\n        onClick: handleHide,\n        label: Labels.hide\n      }\n    ) : /* @__PURE__ */ react_default.createElement(\n      Button_default,\n      {\n        \"data-test\": \"delete-input-button\",\n        appearance: \"destructive\",\n        onClick: handleDelete,\n        label: Labels.yesDelete\n      }\n    ))\n  );\n};\nvar ConfirmationModal = (0, dashboard_state_exports.withSelectorValue)(ConfirmInputRemovalModal, {\n  selector: dashboard_state_exports.selectDeletionConfirmation,\n  selectorResultProp: \"deletionConfirmation\",\n  validationFn: (value) => {\n    var _a;\n    return !!((_a = value == null ? void 0 : value.modalIds) == null ? void 0 : _a.length);\n  }\n});\n\n// esm-externals:@splunk/react-ui/Menu\nvar Menu_exports = {};\n__export(Menu_exports, {\n  default: () => Menu_default\n});\nvar defaultImport20 = __toESM(require(\"@splunk/react-ui/Menu\"));\n__reExport(Menu_exports, require(\"@splunk/react-ui/Menu\"));\nvar Menu_default = \"default\" in defaultImport20 ? defaultImport20.default : defaultImport20;\n\n// esm-externals:@splunk/react-ui/ScreenReaderContent\nvar ScreenReaderContent_exports = {};\n__export(ScreenReaderContent_exports, {\n  default: () => ScreenReaderContent_default\n});\nvar defaultImport21 = __toESM(require(\"@splunk/react-ui/ScreenReaderContent\"));\n__reExport(ScreenReaderContent_exports, require(\"@splunk/react-ui/ScreenReaderContent\"));\nvar ScreenReaderContent_default = \"default\" in defaultImport21 ? defaultImport21.default : defaultImport21;\n\n// esm-externals:@splunk/react-ui/TabBar\nvar TabBar_exports = {};\n__export(TabBar_exports, {\n  default: () => TabBar_default\n});\nvar defaultImport22 = __toESM(require(\"@splunk/react-ui/TabBar\"));\n__reExport(TabBar_exports, require(\"@splunk/react-ui/TabBar\"));\nvar TabBar_default = \"default\" in defaultImport22 ? defaultImport22.default : defaultImport22;\n\n// src/components/TabBar/TabMenuItems/createReorderMenuItems.tsx\nvar createReorderMenuItems = ({\n  index,\n  length,\n  onTabReorder\n}) => {\n  if (length < 2 || index < 0 || index >= length) {\n    return [];\n  }\n  const canMoveLeft = index > 0;\n  const canMoveRight = index < length - 1;\n  const canMoveCompletelyLeft = canMoveLeft && index !== 1;\n  const canMoveCompletelyRight = canMoveRight && index !== length - 2;\n  const onClickGenerator = ({ from, to }) => () => onTabReorder({ from, to });\n  return [\n    canMoveLeft && /* @__PURE__ */ react_default.createElement(\n      Menu_default.Item,\n      {\n        key: \"move-left\",\n        \"data-test\": \"move-left\",\n        onClick: onClickGenerator({ from: index, to: index - 1 })\n      },\n      (0, i18n_exports._)(\"Move left\")\n    ),\n    canMoveRight && /* @__PURE__ */ react_default.createElement(\n      Menu_default.Item,\n      {\n        key: \"move-right\",\n        \"data-test\": \"move-right\",\n        onClick: onClickGenerator({ from: index, to: index + 1 })\n      },\n      (0, i18n_exports._)(\"Move right\")\n    ),\n    canMoveCompletelyLeft && /* @__PURE__ */ react_default.createElement(\n      Menu_default.Item,\n      {\n        key: \"move-completely-left\",\n        \"data-test\": \"move-completely-left\",\n        onClick: onClickGenerator({ from: index, to: 0 })\n      },\n      (0, i18n_exports._)(\"Move completely left\")\n    ),\n    canMoveCompletelyRight && /* @__PURE__ */ react_default.createElement(\n      Menu_default.Item,\n      {\n        key: \"move-completely-right\",\n        \"data-test\": \"move-completely-right\",\n        onClick: onClickGenerator({ from: index, to: length - 1 })\n      },\n      (0, i18n_exports._)(\"Move completely right\")\n    )\n  ];\n};\n\n// src/components/TabBar/TabMenuItems/RemoveTab.tsx\nvar StyledMenuItem = styled_components_default(Menu_default.Item)`\n    color: ${themes_exports.variables.accentColorNegative};\n`;\nvar RemoveTab = react_default.forwardRef(\n  ({ layoutId }, ref) => {\n    const dispatch = (0, dashboard_state_exports.useDispatch)();\n    const handleOnClick = (0, react_exports.useCallback)(() => {\n      dispatch((0, dashboard_state_exports.removeTab)(layoutId));\n    }, [dispatch, layoutId]);\n    return /* @__PURE__ */ react_default.createElement(\n      StyledMenuItem,\n      {\n        ref,\n        \"data-test\": \"remove-tab-menu-item\",\n        onClick: handleOnClick\n      },\n      (0, i18n_exports._)(\"Remove tab\")\n    );\n  }\n);\n\n// src/hooks/useDeselectOnActiveTabPress.ts\nvar useDeselectOnActiveTabPress = ({\n  tabId,\n  isDragging = false\n}) => {\n  const dispatch = (0, dashboard_state_exports.useDispatch)();\n  const activeTabId = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectActiveTab);\n  const activeTabIdRef = (0, react_exports.useRef)(activeTabId);\n  activeTabIdRef.current = activeTabId;\n  const isDraggingRef = (0, react_exports.useRef)(isDragging);\n  isDraggingRef.current = isDragging;\n  return (0, react_exports.useCallback)(\n    (event) => {\n      var _a;\n      if (\n        // if the clicked tab is currently active\n        tabId === activeTabIdRef.current && // and the tab isn't being dragged\n        !isDraggingRef.current && // and the user didn't click the kebab menu\n        !((_a = event.target) == null ? void 0 : _a.hasAttribute(\"aria-haspopup\"))\n      ) {\n        (0, dashboard_state_exports.batch)(() => {\n          dispatch((0, dashboard_state_exports.updateSelectedItems)([]));\n          dispatch((0, dashboard_state_exports.updateSelectedGlobalItems)([]));\n        });\n      }\n    },\n    [tabId, dispatch]\n  );\n};\n\n// src/components/TabBar/ConnectedTab.tsx\nvar updateReactRef = (ref, current) => {\n  if (!ref) {\n    return;\n  }\n  if (typeof ref === \"function\") {\n    ref(current);\n  } else {\n    ref.current = current;\n  }\n};\nvar ConnectedTab = react_default.forwardRef((_a, ref) => {\n  var _b = _a, { tabId, elementRef, isDragging = false } = _b, rest = __objRest(_b, [\"tabId\", \"elementRef\", \"isDragging\"]);\n  const handleTabClick = useDeselectOnActiveTabPress({ tabId, isDragging });\n  const handleRef = (0, react_exports.useMemo)(() => {\n    let prevNode = null;\n    let prevHandler;\n    return (el) => {\n      if (prevNode && prevHandler) {\n        prevNode.removeEventListener(\"click\", prevHandler);\n      }\n      prevNode = el;\n      prevHandler = handleTabClick;\n      el == null ? void 0 : el.addEventListener(\"click\", handleTabClick);\n      updateReactRef(elementRef, el);\n    };\n  }, [elementRef, handleTabClick]);\n  return /* @__PURE__ */ react_default.createElement(\n    TabBar_default.Tab,\n    __spreadProps(__spreadValues({}, rest), {\n      ref,\n      tabId,\n      elementRef: handleRef\n    })\n  );\n});\n\n// esm-externals:@dnd-kit/utilities\nvar utilities_exports = {};\n__export(utilities_exports, {\n  default: () => utilities_default\n});\nvar defaultImport23 = __toESM(require(\"@dnd-kit/utilities\"));\n__reExport(utilities_exports, require(\"@dnd-kit/utilities\"));\nvar utilities_default = \"default\" in defaultImport23 ? defaultImport23.default : defaultImport23;\n\n// src/components/TabBar/SortableTab.tsx\nvar Tab = react_default.forwardRef((_a, ref) => {\n  var _b = _a, { tabId } = _b, rest = __objRest(_b, [\"tabId\"]);\n  const { listeners, setNodeRef, transform, transition, isDragging } = (0, sortable_exports.useSortable)({\n    id: tabId != null ? tabId : \"\"\n  });\n  const style = (0, react_exports.useMemo)(\n    () => ({\n      // CSS.Translate is needed instead of CSS.Transform because we don't want `scale` applied\n      //  due to our tab sizes differing.\n      transform: utilities_exports.CSS.Translate.toString(transform),\n      transition\n    }),\n    [transform, transition]\n  );\n  const handleRef = (0, react_exports.useCallback)(\n    (el) => {\n      setNodeRef(el);\n    },\n    [setNodeRef]\n  );\n  return /* @__PURE__ */ react_default.createElement(\n    ConnectedTab,\n    __spreadValues(__spreadValues({\n      elementRef: handleRef,\n      style,\n      tabId,\n      isDragging,\n      ref\n    }, rest), listeners)\n  );\n});\n\n// src/components/TabBar/TabBar.tsx\nvar menuStyle = { width: 180 };\nvar TabsContainer = styled_components_default.div.attrs({\n  \"data-test\": \"TabsContainer\"\n})`\n    ${({ mode }) => mode === \"view\" && \"width: 100%\"}\n`;\nvar TabBar = () => {\n  const tabs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectTabs);\n  const tabIds = (0, react_exports.useMemo)(() => tabs.map((tab) => tab.layoutId), [tabs]);\n  const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);\n  const tabContainerRef = (0, dashboard_context_exports.useTabsRef)(\"container\");\n  const dispatch = (0, dashboard_state_exports.useDispatch)();\n  const handleTabChange = (0, react_exports.useCallback)(\n    (e, { selectedTabId }) => {\n      if (selectedTabId) {\n        dispatch((0, dashboard_state_exports.setActiveTab)(selectedTabId));\n      }\n    },\n    [dispatch]\n  );\n  const handleTabReorder = (0, react_exports.useCallback)(\n    ({ from, to }) => {\n      const newOrder = (0, sortable_exports.arrayMove)(tabs, from, to);\n      dispatch((0, dashboard_state_exports.updateTabsStructure)(newOrder));\n    },\n    [dispatch, tabs]\n  );\n  const activeTabId = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectActiveTab);\n  const activeTab = tabs.find((tab) => tab.layoutId === activeTabId);\n  const tabElements = (0, react_exports.useMemo)(() => {\n    const TabComponent = mode === \"view\" ? ConnectedTab : Tab;\n    return tabs.map((tab, idx) => {\n      var _a;\n      const tabLabel = ((_a = tab.label) == null ? void 0 : _a.trim()) || (0, i18n_exports._)(`Unnamed tab`);\n      const reorderMenuItems = createReorderMenuItems({\n        index: idx,\n        length: tabs.length,\n        onTabReorder: handleTabReorder\n      });\n      const shouldRenderMenu = mode === \"edit\" && tabs.length > 1;\n      return /* @__PURE__ */ react_default.createElement(\n        TabComponent,\n        {\n          key: tab.layoutId,\n          label: tabLabel,\n          tabId: tab.layoutId,\n          menu: shouldRenderMenu && /* @__PURE__ */ react_default.createElement(Menu_default, { style: menuStyle }, reorderMenuItems, /* @__PURE__ */ react_default.createElement(RemoveTab, { layoutId: tab.layoutId }))\n        }\n      );\n    });\n  }, [handleTabReorder, mode, tabs]);\n  const onDragEnd = (0, react_exports.useCallback)(\n    ({ active, over }) => {\n      if (!over || active.id === over.id) {\n        return;\n      }\n      if (!tabs || tabs.length < 2) {\n        return;\n      }\n      const from = tabs.findIndex((tab) => tab.layoutId === active.id);\n      const to = tabs.findIndex((tab) => tab.layoutId === over.id);\n      handleTabReorder({ from, to });\n    },\n    [handleTabReorder, tabs]\n  );\n  (0, core_exports.useDndMonitor)({ onDragEnd });\n  if (mode === \"view\" && tabs.length <= 1) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(\n    sortable_exports.SortableContext,\n    {\n      id: \"sortable-tab-bar\",\n      items: tabIds,\n      strategy: sortable_exports.horizontalListSortingStrategy\n    },\n    /* @__PURE__ */ react_default.createElement(TabsContainer, { mode }, /* @__PURE__ */ react_default.createElement(\n      TabBar_default,\n      {\n        activeTabId,\n        onChange: handleTabChange,\n        elementRef: tabContainerRef\n      },\n      tabElements\n    ), activeTab && /* @__PURE__ */ react_default.createElement(ScreenReaderContent_default, { \"aria-live\": \"polite\" }, `${(0, i18n_exports._)(\"Active tab\")}: ${activeTab.label} `))\n  );\n};\n\n// esm-externals:@splunk/react-ui/Tooltip\nvar Tooltip_exports = {};\n__export(Tooltip_exports, {\n  default: () => Tooltip_default\n});\nvar defaultImport24 = __toESM(require(\"@splunk/react-ui/Tooltip\"));\n__reExport(Tooltip_exports, require(\"@splunk/react-ui/Tooltip\"));\nvar Tooltip_default = \"default\" in defaultImport24 ? defaultImport24.default : defaultImport24;\n\n// esm-externals:@splunk/react-icons/PlusCircle\nvar PlusCircle_exports = {};\n__export(PlusCircle_exports, {\n  default: () => PlusCircle_default\n});\nvar defaultImport25 = __toESM(require(\"@splunk/react-icons/PlusCircle\"));\n__reExport(PlusCircle_exports, require(\"@splunk/react-icons/PlusCircle\"));\nvar PlusCircle_default = \"default\" in defaultImport25 ? defaultImport25.default : defaultImport25;\n\n// src/components/AddTabButton/AddTabButton.tsx\nvar icon = /* @__PURE__ */ react_default.createElement(PlusCircle_default, { width: 24, height: 24 });\nvar tooltipStyle = { margin: \"0 10px\" };\nvar addTabLabel = (0, i18n_exports._)(\"Add tab\");\nvar AddTabButton = ({ label = addTabLabel }) => {\n  const dispatch = (0, dashboard_state_exports.useDispatch)();\n  const { family } = (0, themes_exports.useSplunkTheme)();\n  const buttonRef = (0, dashboard_context_exports.useTabsRef)(\"addTab\");\n  const appearance = family === \"prisma\" ? \"secondary\" : \"pill\";\n  const handleClick = (0, react_exports.useCallback)(() => {\n    dispatch((0, dashboard_state_exports.addEmptyTab)());\n  }, [dispatch]);\n  return /* @__PURE__ */ react_default.createElement(\n    Tooltip_default,\n    {\n      contentRelationship: \"label\",\n      content: label,\n      style: tooltipStyle\n    },\n    /* @__PURE__ */ react_default.createElement(\n      Button_default,\n      {\n        \"data-test\": \"add-tab-button\",\n        appearance,\n        icon,\n        onClick: handleClick,\n        elementRef: buttonRef\n      }\n    )\n  );\n};\n\n// esm-externals:@splunk/react-icons/ArrowSquareHalfDown\nvar ArrowSquareHalfDown_exports = {};\n__export(ArrowSquareHalfDown_exports, {\n  default: () => ArrowSquareHalfDown_default\n});\nvar defaultImport26 = __toESM(require(\"@splunk/react-icons/ArrowSquareHalfDown\"));\n__reExport(ArrowSquareHalfDown_exports, require(\"@splunk/react-icons/ArrowSquareHalfDown\"));\nvar ArrowSquareHalfDown_default = \"default\" in defaultImport26 ? defaultImport26.default : defaultImport26;\n\n// src/components/ImportTabButton/ImportTabButton.tsx\nvar icon2 = /* @__PURE__ */ react_default.createElement(ArrowSquareHalfDown_default, { width: 24, height: 24 });\nvar tooltipStyle2 = { margin: \"0 10px\" };\nvar IMPORT_TAB_LABEL = (0, i18n_exports._)(\"Import dashboard as tab\");\nvar ImportTabButton = ({\n  label = IMPORT_TAB_LABEL\n}) => {\n  const { family } = (0, themes_exports.useSplunkTheme)();\n  const { allowImportTab } = (0, dashboard_context_exports.useFeatureFlags)();\n  const buttonRef = (0, dashboard_context_exports.useTabsRef)(\"importTab\");\n  const appearance = family === \"prisma\" ? \"secondary\" : \"pill\";\n  if (!allowImportTab) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(\n    Tooltip_default,\n    {\n      contentRelationship: \"label\",\n      content: label,\n      style: tooltipStyle2\n    },\n    /* @__PURE__ */ react_default.createElement(\n      Button_default,\n      {\n        \"data-test\": \"import-tab-button\",\n        appearance,\n        icon: icon2,\n        elementRef: buttonRef\n      }\n    )\n  );\n};\n\n// src/components/TabActionBar/TabActionBar.tsx\nvar ActionBar = styled_components_default.div.attrs({\n  \"data-test\": \"tab-action-bar\"\n})`\n    display: flex;\n    flex-direction: row;\n    justify-content: left;\n    flex-grow: 1;\n    align-items: center;\n`;\nvar TabActionBar = () => {\n  const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);\n  if (mode !== \"edit\") {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(ActionBar, null, /* @__PURE__ */ react_default.createElement(AddTabButton, null), /* @__PURE__ */ react_default.createElement(ImportTabButton, null));\n};\n\n// src/components/TabContainer/TabContainer.tsx\nvar TabsContainer2 = styled_components_default.div.attrs({\n  \"data-test\": \"tabs-container\"\n})`\n    display: flex;\n    flex-direction: row;\n    width: 100%;\n    overflow-x: auto;\n    flex-shrink: 0;\n`;\nvar TabContainer = () => {\n  const sensors = (0, core_exports.useSensors)(\n    (0, core_exports.useSensor)(core_exports.MouseSensor, { activationConstraint: { distance: 5 } })\n  );\n  return /* @__PURE__ */ react_default.createElement(TabsContainer2, null, /* @__PURE__ */ react_default.createElement(core_exports.DndContext, { sensors }, /* @__PURE__ */ react_default.createElement(TabBar, null)), /* @__PURE__ */ react_default.createElement(TabActionBar, null));\n};\n\n// src/components/DashboardLayout.tsx\nvar DashboardLayoutContainer = styled_components_default.div.attrs({\n  \"data-test\": \"DashboardLayoutContainer\"\n})`\n    ${(0, mixins_exports.reset)(\"flex\")};\n    position: relative;\n    overflow: hidden;\n    flex-direction: column;\n    padding-bottom: 8px;\n    ${(props) => (0, dashboard_utils_exports.toDimension)((0, lodash_exports.pick)(props, [\"width\", \"height\"]))};\n`;\nvar GlobalInputsContainer = styled_components_default.div.attrs({\n  \"data-test\": \"GlobalInputsContainer\"\n})`\n    flex-basis: auto;\n    z-index: 100;\n`;\nvar LayoutContainer = styled_components_default.div.attrs({\n  \"data-test\": \"LayoutContainer\"\n})`\n    flex-grow: 1;\n    min-height: 0px;\n    overflow: auto;\n    position: relative;\n`;\nvar DashboardLayout = ({\n  height,\n  width,\n  renderGlobalInput: renderGlobalInput2,\n  renderLayout,\n  showGlobalInputs\n}) => {\n  const tabs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectTabs);\n  const canvasRef = (0, react_exports.useRef)(null);\n  const globalInputsOrder = useDashboardDragMonitor();\n  const renderGlobalInputsContainer = (0, react_exports.useMemo)(\n    () => showGlobalInputs && /* @__PURE__ */ react_default.createElement(GlobalInputsContainer, null, renderGlobalInput2()),\n    [showGlobalInputs, renderGlobalInput2]\n  );\n  return /* @__PURE__ */ react_default.createElement(\n    DashboardLayoutContainer,\n    {\n      height,\n      width,\n      \"data-udf-core-version\": \"27.3.1\"\n    },\n    /* @__PURE__ */ react_default.createElement(\n      sortable_exports.SortableContext,\n      {\n        id: \"sortable-global-inputs\",\n        items: globalInputsOrder\n      },\n      renderGlobalInputsContainer\n    ),\n    /* @__PURE__ */ react_default.createElement(TabContainer, null),\n    /* @__PURE__ */ react_default.createElement(\n      LayoutContainer,\n      {\n        ref: canvasRef,\n        role: tabs.length > 1 ? \"tabpanel\" : void 0\n      },\n      /* @__PURE__ */ react_default.createElement(dashboard_context_exports.CanvasContext.Provider, { value: canvasRef }, /* @__PURE__ */ react_default.createElement(dashboard_ui_exports.SizeWrapper, null, (containerDimensions) => renderLayout(containerDimensions)))\n    ),\n    /* @__PURE__ */ react_default.createElement(ConfirmationModal, null)\n  );\n};\nvar DashboardLayout_default = DashboardLayout;\n\n// src/utils/visualization.ts\nvar getHasDrilldown = (eventHandlers) => {\n  if (!Array.isArray(eventHandlers)) {\n    return false;\n  }\n  return !!eventHandlers.find((eventHandler) => {\n    return /^drilldown/.test(eventHandler.type);\n  });\n};\n\n// esm-externals:react-dom\nvar react_dom_exports = {};\n__export(react_dom_exports, {\n  default: () => react_dom_default\n});\nvar defaultImport27 = __toESM(require(\"react-dom\"));\n__reExport(react_dom_exports, require(\"react-dom\"));\nvar react_dom_default = \"default\" in defaultImport27 ? defaultImport27.default : defaultImport27;\n\n// src/contexts/ActionMenusContext.tsx\nvar ActionMenusContext = (0, react_exports.createContext)(null);\nvar ActionMenusContextProvider = ActionMenusContext.Provider;\nvar useActionMenus = () => {\n  const ctx = (0, react_exports.useContext)(ActionMenusContext);\n  if (ctx === null) {\n    throw new Error(\n      \"useActionMenus can only be used in a component that is a child of a ActionMenusContextProvider\"\n    );\n  }\n  return ctx;\n};\n\n// src/containers/ActionMenu.tsx\nvar ActionMenuWrapper = styled_components_default.div.attrs(\n  ({ top }) => {\n    return {\n      \"data-test\": \"action-menu-wrapper\",\n      style: __spreadValues({}, top ? { top: `${top - 1}px` } : { bottom: 0 })\n    };\n  }\n)`\n    visibility: ${({ isSelected }) => isSelected ? \"visible\" : \"hidden\"};\n    transition: visibility 0.2s ease-in 0;\n\n    position: absolute;\n    right: 0;\n    width: fit-content;\n    height: fit-content;\n    pointer-events: ${({ isSelected }) => isSelected ? \"all\" : \"none\"};\n    z-index: ${({ renderActionMenuInPortal }) => renderActionMenuInPortal ? \"undefined\" : \"9999\"};\n\n    /* On hover of absolute-item (or menu portal) make the action menu visible */\n    div[data-test='absolute-item']:hover\n        + div[data-test='action-menu-portal']\n        > &,\n    & div[data-test='action-menus']:hover,\n    ${dashboard_ui_exports.SelectableContainer}:hover & {\n        transition: visibility 0.2s ease-in 0.3s;\n        visibility: visible;\n        pointer-events: all;\n    }\n\n    // The :hover pseudo selector cannot be mocked during visual testing, so also\n    // support a data-test selector to trigger this state in storybook test cases\n    // but DO NOT add a transition duration for visual tests (reduces flakiness)\n    div[data-test='absolute-item'][data-test-hovered]\n        + div[data-test='action-menu-portal']\n        > &,\n    & div[data-test='action-menus'][data-test-hovered],\n    ${dashboard_ui_exports.SelectableContainer}[data-test-hovered] & {\n        transition: visibility 0s;\n        visibility: visible;\n        pointer-events: all;\n    }\n`;\nvar useActionMenusWithData = ({\n  type,\n  itemId,\n  itemDefinition,\n  dataSourceDefinitions\n}) => {\n  const actionMenus = useActionMenus();\n  return (0, react_exports.useMemo)(() => {\n    return actionMenus.map(\n      (item) => react_default.cloneElement(item, {\n        type,\n        itemId,\n        itemDefinition,\n        visualization: itemDefinition,\n        dataSources: dataSourceDefinitions\n      })\n    );\n  }, [type, itemId, actionMenus, dataSourceDefinitions, itemDefinition]);\n};\nvar ActionMenu = ({\n  top,\n  itemId,\n  isSelected,\n  dataSourceMeta,\n  dataSourceDefinitions,\n  type,\n  itemDefinition,\n  showLastUpdated,\n  actionMenuPortal,\n  renderActionMenuInPortal\n}) => {\n  const useActionMenusWithDataProps = (0, react_exports.useMemo)(\n    () => ({\n      type,\n      itemId,\n      itemDefinition,\n      dataSourceDefinitions\n    }),\n    [type, itemId, itemDefinition, dataSourceDefinitions]\n  );\n  const buttonsWithData = useActionMenusWithData(useActionMenusWithDataProps);\n  const ActionMenuComponent = (0, react_exports.useMemo)(() => {\n    return /* @__PURE__ */ react_default.createElement(\n      ActionMenuWrapper,\n      {\n        isSelected,\n        top,\n        renderActionMenuInPortal\n      },\n      /* @__PURE__ */ react_default.createElement(\n        dashboard_ui_exports.ActionMenuContainer,\n        {\n          actionButtons: buttonsWithData,\n          lastUpdated: dataSourceMeta == null ? void 0 : dataSourceMeta.lastUpdated,\n          status: dataSourceMeta == null ? void 0 : dataSourceMeta.status,\n          isRealTimeSearch: dataSourceMeta == null ? void 0 : dataSourceMeta.isRealTimeSearch,\n          showLastUpdated,\n          itemId\n        }\n      )\n    );\n  }, [\n    buttonsWithData,\n    dataSourceMeta == null ? void 0 : dataSourceMeta.isRealTimeSearch,\n    dataSourceMeta == null ? void 0 : dataSourceMeta.lastUpdated,\n    dataSourceMeta == null ? void 0 : dataSourceMeta.status,\n    itemId,\n    isSelected,\n    showLastUpdated,\n    top,\n    renderActionMenuInPortal\n  ]);\n  return (actionMenuPortal == null ? void 0 : actionMenuPortal.current) && renderActionMenuInPortal ? (0, react_dom_exports.createPortal)(ActionMenuComponent, actionMenuPortal.current) : ActionMenuComponent;\n};\n\n// src/hooks/useActionMenu.tsx\nvar minDistanceFromBottomCanvasForActionMenus = 40;\nvar getActionMenuPosition = ({\n  height,\n  y,\n  canvasHeight,\n  shouldUsePortal\n}) => {\n  if (typeof height !== \"number\") {\n    return void 0;\n  }\n  const menuBottom = height + y;\n  const canvasBottom = canvasHeight - minDistanceFromBottomCanvasForActionMenus;\n  if (menuBottom <= canvasBottom) {\n    return shouldUsePortal ? 1 : height + 1;\n  }\n  return void 0;\n};\nvar useActionMenu = ({\n  itemId,\n  itemDefinition,\n  layoutItemType,\n  portalRef,\n  shouldUsePortal,\n  dataSourceMeta,\n  dataSourceDefinitions,\n  isSelected,\n  menuPosition,\n  mode = \"view\"\n}) => {\n  const preset = (0, dashboard_context_exports.usePreset)();\n  const { showLastUpdated: lastUpdatedFeatureFlag } = (0, dashboard_context_exports.useFeatureFlags)();\n  const useLastUpdated = (0, react_exports.useMemo)(() => {\n    const presetFlags = preset.shouldDisplaySiblingContent(\n      itemDefinition.type,\n      layoutItemType\n    );\n    return lastUpdatedFeatureFlag && (presetFlags == null ? void 0 : presetFlags.showLastUpdated) && itemDefinition.showLastUpdated;\n  }, [\n    preset,\n    layoutItemType,\n    itemDefinition.type,\n    itemDefinition.showLastUpdated,\n    lastUpdatedFeatureFlag\n  ]);\n  const shouldShowActionMenu = (0, react_exports.useMemo)(\n    () => preset.shouldShowActionMenu({ mode, layoutItemType }),\n    [preset, mode, layoutItemType]\n  );\n  return (0, react_exports.useMemo)(\n    () => shouldShowActionMenu ? /* @__PURE__ */ react_default.createElement(\n      ActionMenu,\n      {\n        itemId,\n        type: layoutItemType,\n        top: menuPosition,\n        isSelected,\n        showLastUpdated: useLastUpdated,\n        dataSourceMeta,\n        dataSourceDefinitions,\n        itemDefinition,\n        actionMenuPortal: portalRef,\n        renderActionMenuInPortal: shouldUsePortal\n      }\n    ) : null,\n    [\n      shouldShowActionMenu,\n      portalRef,\n      shouldUsePortal,\n      dataSourceDefinitions,\n      dataSourceMeta,\n      itemId,\n      layoutItemType,\n      isSelected,\n      useLastUpdated,\n      itemDefinition,\n      menuPosition\n    ]\n  );\n};\n\n// src/hooks/useCanItemBeHidden.ts\nvar useCanItemBeHidden = ({\n  itemDefinition\n}) => {\n  var _a, _b, _c, _d;\n  const { enableShowHide } = (0, dashboard_context_exports.useFeatureFlags)();\n  if (!enableShowHide) {\n    return false;\n  }\n  if (((_a = itemDefinition.containerOptions) == null ? void 0 : _a.visibility) && \"hideInViewMode\" in itemDefinition.containerOptions.visibility && !!((_b = itemDefinition.containerOptions.visibility) == null ? void 0 : _b.hideInViewMode)) {\n    return true;\n  }\n  return !!itemDefinition.hideWhenNoData || !!((_d = (_c = itemDefinition.containerOptions) == null ? void 0 : _c.visibility) == null ? void 0 : _d.hideWhenNoData);\n};\n\n// esm-externals:react-full-screen\nvar react_full_screen_exports = {};\n__export(react_full_screen_exports, {\n  default: () => react_full_screen_default\n});\nvar defaultImport28 = __toESM(require(\"react-full-screen\"));\n__reExport(react_full_screen_exports, require(\"react-full-screen\"));\nvar react_full_screen_default = \"default\" in defaultImport28 ? defaultImport28.default : defaultImport28;\n\n// src/hooks/useVizTelemetry.tsx\nvar useVizTelemetry = ({\n  width,\n  height,\n  id,\n  type,\n  loading\n}) => {\n  const profiler = (0, dashboard_telemetry_exports.useDashboardProfiler)();\n  const [timerCreated, setTimerCreated] = (0, react_exports.useState)(false);\n  const telemetry = (0, dashboard_telemetry_exports.useTelemetryApi)();\n  (0, react_exports.useLayoutEffect)(() => {\n    if (width && height && (profiler == null ? void 0 : profiler.hasPartialMeasurement(dashboard_telemetry_exports.VIZ_RESIZE_EVENT))) {\n      profiler == null ? void 0 : profiler.endMeasurement(dashboard_telemetry_exports.VIZ_RESIZE_EVENT, {\n        vizType: type\n      });\n    }\n  }, [height, profiler, type, width]);\n  const timerId = `Visualization - ${type} - ${(0, dashboard_utils_exports.hashString)(\n    id\n  )} - Time to Interactive`;\n  (0, react_exports.useEffect)(() => {\n    const initialPayload = {\n      pageAction: \"performance.createTimer\",\n      metadata: {\n        timerId,\n        sourceElement: \"TimeRangePicker\",\n        heroElement: timerId,\n        currentTime: performance.now()\n      }\n    };\n    if (!timerCreated) {\n      telemetry.emit(initialPayload);\n      setTimerCreated(true);\n    }\n  }, [telemetry, timerCreated, timerId]);\n  (0, react_exports.useEffect)(() => {\n    const actionPayload = {\n      pageAction: \"performance.mark\",\n      metadata: {\n        timerId,\n        markInformation: timerId,\n        currentTime: performance.now()\n      }\n    };\n    const initialPayload = {\n      pageAction: \"performance.createTimer\",\n      metadata: {\n        timerId,\n        sourceElement: \"TimeRangePicker\",\n        heroElement: timerId,\n        currentTime: performance.now()\n      }\n    };\n    if (!loading && timerCreated) {\n      telemetry.emit(actionPayload);\n      telemetry.emit(initialPayload);\n    }\n  }, [telemetry, loading, timerCreated, timerId]);\n  (0, react_exports.useEffect)(() => {\n    profiler == null ? void 0 : profiler.emitAndClearTimer({\n      timerName: dashboard_telemetry_exports.VIZ_ADD_EVENT,\n      metadata: {\n        vizType: type\n      }\n    });\n  }, []);\n  const firstVizEmit = (0, react_exports.useRef)(\n    (0, lodash_exports.once)(\n      (currentProfiler) => currentProfiler == null ? void 0 : currentProfiler.emitAndClearTimer({\n        timerName: dashboard_telemetry_exports.DASHBOARD_MOUNT_TO_FIRST_VIZ_EVENT\n      })\n    )\n  );\n  (0, react_exports.useEffect)(() => {\n    if (!loading) {\n      firstVizEmit.current(profiler);\n    }\n  }, [loading, profiler]);\n};\n\n// src/hooks/useStatusMessage.tsx\nvar useStatusMessage = ({\n  dataSource\n}) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n  const errorMessage = (_a = dataSource == null ? void 0 : dataSource.error) == null ? void 0 : _a.message;\n  const warningMessage = (_d = (_c = (_b = dataSource == null ? void 0 : dataSource.meta) == null ? void 0 : _b.serverLog) == null ? void 0 : _c[0]) == null ? void 0 : _d.message;\n  let message = errorMessage || warningMessage || \"\";\n  const status = (_f = (_e = dataSource == null ? void 0 : dataSource.meta) == null ? void 0 : _e.status) != null ? _f : \"\";\n  const noData = ((_h = (_g = dataSource == null ? void 0 : dataSource.data) == null ? void 0 : _g.columns) == null ? void 0 : _h.length) === 0;\n  const noSearchResults = status === \"done\" && noData;\n  if (noSearchResults) {\n    message = dashboard_state_exports.NO_RESULTS_MSG;\n  }\n  const showWaitingForInputPlaceholder = !!(noSearchResults || errorMessage || noData && warningMessage);\n  return (0, react_exports.useMemo)(\n    () => ({ message, showWaitingForInputPlaceholder }),\n    [message, showWaitingForInputPlaceholder]\n  );\n};\n\n// src/containers/VisualizationContainer.tsx\nvar StyledFullScreen = styled_components_default(react_full_screen_exports.FullScreen)`\n    height: ${(props) => (0, dashboard_utils_exports.toPx)(props.height)};\n    width: ${(props) => (0, dashboard_utils_exports.toPx)(props.width)};\n`;\nvar empty = {};\nvar VisualizationContainer = ({\n  id,\n  mode,\n  itemDefinition,\n  height,\n  width,\n  loading,\n  refresh,\n  control,\n  dataSources,\n  updateRequestParams,\n  onSelected,\n  isFullscreen\n}) => {\n  const dispatch = (0, dashboard_state_exports.useDispatch)();\n  const onExitFullscreen = (0, react_exports.useCallback)(\n    () => dispatch((0, dashboard_state_exports.setFullscreenItem)(null)),\n    [dispatch]\n  );\n  const eventRegistry = (0, dashboard_context_exports.useEventRegistry)();\n  const onEventTrigger = (0, react_exports.useCallback)(\n    ({ type: eventType, originalEvent, payload }) => {\n      const eventId = eventRegistry.registerEvent(originalEvent);\n      dispatch((0, dashboard_state_exports.triggerEvent)(id, eventType, payload, eventId));\n    },\n    [dispatch, eventRegistry, id]\n  );\n  const onOptionsChange = (0, react_exports.useCallback)(\n    (newOptions) => dispatch((0, dashboard_state_exports.updateVizOptions)(id, newOptions)),\n    [dispatch, id]\n  );\n  const onTitleChange = (0, react_exports.useCallback)(\n    (newTitle) => dispatch((0, dashboard_state_exports.updateVizTitle)(id, newTitle)),\n    [dispatch, id]\n  );\n  const onDescriptionChange = (0, react_exports.useCallback)(\n    (newDescription) => dispatch((0, dashboard_state_exports.updateVizDescription)(id, newDescription)),\n    [dispatch, id]\n  );\n  const apiRegistry = (0, dashboard_context_exports.useApiRegistry)();\n  const fullscreenHandle = (0, react_full_screen_exports.useFullScreenHandle)();\n  const { enter: enterFullscreen, node: vizRef } = fullscreenHandle;\n  const vizApi = (0, react_exports.useMemo)(\n    () => ({\n      getDomElement: () => vizRef.current\n    }),\n    [vizRef]\n  );\n  (0, react_exports.useEffect)(() => {\n    if (!apiRegistry.getVisualizationApi(id)) {\n      apiRegistry.registerVisualizationApi(id, vizApi);\n    }\n    return () => {\n      apiRegistry.removeVisualizationApi(id);\n    };\n  }, [apiRegistry, id, vizApi]);\n  (0, react_exports.useEffect)(() => {\n    apiRegistry.registerVisualizationActionsApi(id, { refresh, control });\n    return () => {\n      apiRegistry.removeVisualizationActionsApi(id);\n    };\n  }, [apiRegistry, id, refresh, control]);\n  const registerApi = (0, react_exports.useCallback)(\n    (ref) => {\n      apiRegistry.registerVisualizationApi(id, __spreadValues(__spreadValues({}, ref), vizApi));\n    },\n    [apiRegistry, id, vizApi]\n  );\n  const handleToggleFullscreen = (0, react_exports.useCallback)(\n    (isFull) => {\n      if (isFullscreen && !isFull) {\n        onExitFullscreen();\n      }\n    },\n    [isFullscreen, onExitFullscreen]\n  );\n  (0, react_exports.useEffect)(() => {\n    if (isFullscreen) {\n      enterFullscreen();\n    }\n  }, []);\n  const preset = (0, dashboard_context_exports.usePreset)();\n  const { message, showWaitingForInputPlaceholder } = useStatusMessage({\n    dataSource: dataSources == null ? void 0 : dataSources.primary\n  });\n  const { showProgressBar: progressFeatureFlag } = (0, dashboard_context_exports.useFeatureFlags)();\n  const visualizationDefinition = (0, react_exports.useMemo)(() => {\n    const presetFlags = preset == null ? void 0 : preset.shouldDisplayVisualizationSiblingContent(\n      itemDefinition.type\n    );\n    return __spreadProps(__spreadValues({}, itemDefinition), {\n      showProgressBar: !!itemDefinition.showProgressBar && progressFeatureFlag && (presetFlags == null ? void 0 : presetFlags.showProgressBar) && !showWaitingForInputPlaceholder,\n      title: presetFlags.showTitleAndDescription ? itemDefinition.title : void 0,\n      description: presetFlags.showTitleAndDescription ? itemDefinition.description : void 0\n    });\n  }, [\n    itemDefinition,\n    preset,\n    progressFeatureFlag,\n    showWaitingForInputPlaceholder\n  ]);\n  const { waitingForInput: WaitingForInput = dashboard_ui_exports.VisualizationWaitingForInput } = (0, dashboard_context_exports.useCoreOverrides)();\n  useVizTelemetry({ width, height, id, loading, type: itemDefinition.type });\n  (0, dashboard_ui_exports.useRiskySearchToast)({ dataSource: dataSources == null ? void 0 : dataSources.primary });\n  const [computedProps, setComputedProps] = (0, react_exports.useState)({});\n  (0, react_exports.useEffect)(() => {\n    setComputedProps({});\n  }, [visualizationDefinition.type]);\n  const GraphicalChart = (0, react_exports.useMemo)(() => {\n    const { eventHandlers } = visualizationDefinition;\n    const props = __spreadProps(__spreadValues({}, visualizationDefinition), {\n      // height and width props will be set by VisualizationContent\n      width: \"inherit\",\n      hasEventHandlers: eventHandlers && eventHandlers.length > 0,\n      dataSources,\n      loading,\n      onRequestParamsChange: updateRequestParams,\n      onComputedProps: setComputedProps,\n      id,\n      mode,\n      onEventTrigger,\n      vizActionHandlerRef: registerApi,\n      visualizationApiRef: registerApi,\n      onOptionsChange,\n      // need to convert the array of string to an array of objects.\n      onSelected: (e, visualizationIds) => onSelected(\n        e,\n        visualizationIds.map((vizId) => ({\n          id: vizId,\n          type: \"block\"\n        }))\n      ),\n      onTitleChange,\n      onDescriptionChange,\n      isFullscreen\n    });\n    return preset.createVisualization(visualizationDefinition.type, props);\n  }, [\n    visualizationDefinition,\n    dataSources,\n    loading,\n    updateRequestParams,\n    id,\n    mode,\n    onEventTrigger,\n    registerApi,\n    onOptionsChange,\n    onTitleChange,\n    onDescriptionChange,\n    isFullscreen,\n    preset,\n    onSelected\n  ]);\n  const Placeholder = (0, react_exports.useMemo)(() => {\n    const { type, options = empty } = visualizationDefinition;\n    const { backgroundColor } = options;\n    let bgColor = computedProps.backgroundColor || backgroundColor || null;\n    if (bgColor) {\n      bgColor = (0, dashboard_ui_exports.sanitizeColor)(bgColor);\n    }\n    const PlaceholderIcon = preset.getPlaceholderIcon(type);\n    return /* @__PURE__ */ react_default.createElement(\n      WaitingForInput,\n      {\n        width: \"initial\",\n        dataSource: dataSources.primary,\n        message,\n        backgroundColor: bgColor,\n        PlaceholderIcon\n      }\n    );\n  }, [\n    visualizationDefinition,\n    computedProps.backgroundColor,\n    preset,\n    WaitingForInput,\n    dataSources.primary,\n    message\n  ]);\n  return /* @__PURE__ */ react_default.createElement(\n    StyledFullScreen,\n    {\n      handle: fullscreenHandle,\n      onChange: handleToggleFullscreen,\n      width,\n      height,\n      className: \"styled-fullscreen\"\n    },\n    /* @__PURE__ */ react_default.createElement(\n      dashboard_ui_exports.VisualizationContent,\n      {\n        id,\n        visualizationDefinition,\n        height,\n        width,\n        isFullscreen,\n        dataSources,\n        computedProps\n      },\n      showWaitingForInputPlaceholder ? Placeholder : GraphicalChart\n    )\n  );\n};\nvar VisualizationContainer_default = VisualizationContainer;\n\n// src/containers/InputContent.tsx\nvar AlignmentToJustifyMap = {\n  top: \"start\",\n  center: \"center\",\n  bottom: \"end\"\n};\nvar OnCanvasWrapper = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"input-canvas-wrapper\"\n}))`\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n    justify-content: ${(props) => AlignmentToJustifyMap[props.alignment]};\n    background-color: ${(props) => props.backgroundColor};\n`;\nvar empty2 = {};\nvar getErrorDisabledStates = ({\n  dataSources\n}) => {\n  var _a, _b, _c, _d;\n  const errorLevel = (_b = (_a = dataSources == null ? void 0 : dataSources.primary) == null ? void 0 : _a.error) == null ? void 0 : _b.level;\n  const message = ((_d = (_c = dataSources == null ? void 0 : dataSources.primary) == null ? void 0 : _c.error) == null ? void 0 : _d.message) || \"\";\n  if (errorLevel === dashboard_state_exports.ERROR_LEVEL_INFO) {\n    return {\n      isDisabled: true,\n      disabledMessage: message || dashboard_state_exports.WAITING_FOR_INPUT_MSG\n    };\n  }\n  if (errorLevel === dashboard_state_exports.ERROR_LEVEL_ERROR) {\n    return { isError: true, errorMessage: message };\n  }\n  return {};\n};\nvar InputContent_default = ({\n  itemDefinition,\n  loading = false,\n  dataSources = {},\n  id,\n  isSelected,\n  refresh,\n  control,\n  mode,\n  onRemove,\n  width,\n  height,\n  attributes,\n  listeners,\n  isOnCanvas = false\n}) => {\n  var _a, _b;\n  const apiRegistry = (0, dashboard_context_exports.useApiRegistry)();\n  const preset = (0, dashboard_context_exports.usePreset)();\n  const eventRegistry = (0, dashboard_context_exports.useEventRegistry)();\n  const dispatch = (0, dashboard_state_exports.useDispatch)();\n  const {\n    type,\n    title,\n    options = empty2,\n    encoding = empty2,\n    context = empty2,\n    containerOptions = empty2\n  } = itemDefinition;\n  const input = preset.findInput(type);\n  const inputStaticDef = (0, react_exports.useMemo)(\n    () => ({\n      options,\n      context\n    }),\n    [context, options]\n  );\n  const handleValueChange = (0, react_exports.useCallback)(\n    (e, newValue) => {\n      const eventId = eventRegistry.registerEvent(e);\n      dispatch((0, dashboard_state_exports.inputValueChanged)({ id, newValue, eventId, isOnCanvas }));\n    },\n    [dispatch, eventRegistry, id, isOnCanvas]\n  );\n  const registerApi = (0, react_exports.useCallback)(\n    (ref) => {\n      apiRegistry.registerInputApi(id, ref);\n    },\n    [apiRegistry, id]\n  );\n  (0, react_exports.useEffect)(() => {\n    return () => {\n      apiRegistry.removeInputApi(id);\n    };\n  }, [apiRegistry, id]);\n  (0, react_exports.useEffect)(() => {\n    apiRegistry.registerInputActionsApi(id, { refresh, control });\n    return () => {\n      apiRegistry.removeInputActionsApi(id);\n    };\n  }, [apiRegistry, id, refresh, control]);\n  const {\n    isError: dsError = false,\n    errorMessage: dsErrorMessage = \"\",\n    isDisabled = false,\n    disabledMessage = \"\"\n  } = (0, react_exports.useMemo)(\n    () => getErrorDisabledStates({\n      dataSources\n    }),\n    [dataSources]\n  );\n  const { errorMessages: inputErrorMessages } = (0, react_exports.useMemo)(() => {\n    const validate = input == null ? void 0 : input.validate;\n    return typeof validate === \"function\" ? validate(inputStaticDef) : { errorMessages: [] };\n  }, [inputStaticDef, input]);\n  const value = (0, dashboard_state_exports.useSelector)((state) => (0, dashboard_state_exports.selectInputValue)(state, id));\n  const canBeHidden = useCanItemBeHidden({ itemDefinition });\n  const props = (0, react_exports.useMemo)(\n    () => ({\n      id,\n      key: id,\n      loading,\n      title,\n      dataSources,\n      encoding,\n      context,\n      options,\n      isError: dsError || !(0, lodash_exports.isEmpty)(inputErrorMessages),\n      // dataSource error take precedence over input options error\n      errorMessage: dsErrorMessage || inputErrorMessages.join(\" \"),\n      // TODO: refactor tooltip to display multiline errors\n      isDisabled,\n      disabledMessage,\n      value,\n      isSelected,\n      inputApiRef: registerApi,\n      onRemove,\n      onValueChange: handleValueChange,\n      mode,\n      width,\n      height,\n      isOnCanvas,\n      canBeHidden,\n      attributes,\n      listeners,\n      containerOptions\n    }),\n    [\n      attributes,\n      listeners,\n      id,\n      loading,\n      title,\n      dataSources,\n      encoding,\n      context,\n      options,\n      dsError,\n      inputErrorMessages,\n      dsErrorMessage,\n      isDisabled,\n      disabledMessage,\n      value,\n      isSelected,\n      registerApi,\n      onRemove,\n      handleValueChange,\n      mode,\n      width,\n      height,\n      isOnCanvas,\n      canBeHidden,\n      containerOptions\n    ]\n  );\n  const Input = (0, react_exports.useMemo)(\n    () => preset.createInput(type, props),\n    [preset, type, props]\n  );\n  const alignment = (_a = itemDefinition == null ? void 0 : itemDefinition.canvasAlignment) != null ? _a : \"top\";\n  const backgroundColor = ((_b = itemDefinition == null ? void 0 : itemDefinition.options) == null ? void 0 : _b.backgroundColor) ? (0, dashboard_ui_exports.sanitizeColor)(itemDefinition.options.backgroundColor) : null;\n  const bgColor = backgroundColor || \"transparent\";\n  return isOnCanvas ? /* @__PURE__ */ react_default.createElement(OnCanvasWrapper, { alignment, backgroundColor: bgColor }, Input) : Input;\n};\n\n// src/components/CornerRadiusContainer.tsx\nvar CornerRadiusContainer = styled_components_default.div`\n    height: 100%;\n    width: 100%;\n    // If border radius is unset, then visualizations can render content outside of the container.\n    // If border radius is set, overflow:hidden allows for rounded corners\n    overflow: ${({ cornerRadius }) => cornerRadius === void 0 ? null : \"hidden\"};\n    border-radius: ${({ cornerRadius }) => cornerRadius === void 0 ? null : `${(0, dashboard_utils_exports.toPx)(cornerRadius[0])}\n              ${(0, dashboard_utils_exports.toPx)(cornerRadius[1])}\n              ${(0, dashboard_utils_exports.toPx)(cornerRadius[2])}\n              ${(0, dashboard_utils_exports.toPx)(cornerRadius[3])}`};\n`;\nvar CornerRadiusContainer_default = CornerRadiusContainer;\n\n// src/containers/BaseItemContainer.tsx\nvar empty3 = {};\nvar toAttrs = ({\n  itemId,\n  $itemType,\n  layoutItemType,\n  width,\n  height\n}) => {\n  let base;\n  if (layoutItemType === \"input\") {\n    base = {\n      \"data-test\": \"input-item\",\n      \"data-input-type\": $itemType,\n      \"data-input-id\": itemId\n    };\n  } else {\n    base = {\n      \"data-test\": \"viz-item\",\n      \"data-viz-type\": $itemType,\n      \"data-id\": itemId\n    };\n  }\n  base.style = height ? { width, height } : { width };\n  return base;\n};\nvar Item = styled_components_default.div.attrs((props) => toAttrs(props))`\n    position: relative;\n    pointer-events: auto;\n`;\nvar FixSizeItem = styled_components_default.div.attrs(\n  (props) => toAttrs(props)\n)`\n    flex-direction: column;\n    pointer-events: auto;\n`;\nvar ItemWrapper = react_default.memo(\n  ({\n    width,\n    height,\n    children,\n    itemId,\n    $itemType,\n    layoutItemType\n  }) => {\n    if (!height) {\n      return /* @__PURE__ */ react_default.createElement(\n        Item,\n        {\n          width,\n          itemId,\n          $itemType,\n          layoutItemType\n        },\n        children\n      );\n    }\n    return /* @__PURE__ */ react_default.createElement(\n      FixSizeItem,\n      {\n        width,\n        height,\n        itemId,\n        $itemType,\n        layoutItemType\n      },\n      children\n    );\n  }\n);\nvar ItemLayer = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"item-layer\"\n}))`\n    z-index: ${(props) => props.zIndex};\n    height: 100%;\n`;\nvar BaseItemContainer = ({\n  id,\n  width,\n  height,\n  layoutItemType = \"block\",\n  y,\n  canvasHeight,\n  renderActionMenuInPortal,\n  actionMenuPortal,\n  dragHandlePortal,\n  onSelected\n}) => {\n  var _a, _b;\n  const preset = (0, dashboard_context_exports.usePreset)();\n  const selectIsSelected = (0, react_exports.useMemo)(dashboard_state_exports.makeSelectIsSelected, []);\n  const isSelected = (0, dashboard_state_exports.useSelector)((state) => selectIsSelected(state, id));\n  const isMultiSelect = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectAreMultipleVizSelected);\n  const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);\n  const isFullscreen = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectFullscreenElement) === id;\n  const containerWidth = isFullscreen ? \"100vw\" : width;\n  const containerHeight = isFullscreen ? \"100vh\" : height;\n  const layerData = (0, dashboard_context_exports.useLayoutLayers)();\n  const { layer: itemLayer, selection: selectionLayer } = (0, react_exports.useMemo)(() => {\n    var _a2;\n    return (_a2 = layerData == null ? void 0 : layerData[id]) != null ? _a2 : empty3;\n  }, [layerData, id]);\n  const selectItemDefinition = (0, react_exports.useMemo)(\n    () => (0, dashboard_state_exports.selectItemDefinitionFactory)(layoutItemType)(),\n    [layoutItemType]\n  );\n  const selectDSDef = (0, react_exports.useMemo)(\n    () => (0, dashboard_state_exports.selectDataSourceDefinitionFactory)(layoutItemType)(),\n    [layoutItemType]\n  );\n  const itemDefinition = (0, dashboard_state_exports.useSelector)(\n    (state) => selectItemDefinition(state, id)\n  );\n  const dataSourceDefinitions = (0, dashboard_state_exports.useSelector)(\n    (state) => selectDSDef(state, id)\n  );\n  const itemType = itemDefinition.type;\n  const dataSourceBindings = (_a = itemDefinition.dataSources) != null ? _a : empty3;\n  const canBeHidden = useCanItemBeHidden({ itemDefinition });\n  const radius = isFullscreen ? void 0 : itemDefinition.cornerRadius;\n  const hasDrilldown = getHasDrilldown(itemDefinition.eventHandlers);\n  const outlineStyle = (0, dashboard_ui_exports.getBorderStyle)({\n    isSelected,\n    mode,\n    hasDrilldown,\n    canBeHidden,\n    layoutItemType\n  });\n  const { loading, dataSources, refresh, control, updateRequestParams } = (0, dashboard_ui_exports.useSubscribeToSearches)({\n    consumerId: id,\n    bindings: dataSourceBindings\n  });\n  const actionMenuPosition = getActionMenuPosition({\n    height,\n    y,\n    canvasHeight,\n    shouldUsePortal: renderActionMenuInPortal\n  });\n  const actionMenu = useActionMenu({\n    itemId: id,\n    itemDefinition,\n    layoutItemType,\n    portalRef: actionMenuPortal,\n    shouldUsePortal: renderActionMenuInPortal,\n    dataSourceMeta: (_b = dataSources == null ? void 0 : dataSources.primary) == null ? void 0 : _b.meta,\n    dataSourceDefinitions,\n    isSelected,\n    menuPosition: actionMenuPosition,\n    mode\n  });\n  const handleError = (0, react_exports.useCallback)(\n    (message) => /* @__PURE__ */ react_default.createElement(dashboard_ui_exports.Message, { level: \"error\", message }),\n    []\n  );\n  const shouldShowDragHandle = mode === \"edit\" && preset.shouldShowDragHandle(itemType);\n  const DragHandle = (0, dashboard_ui_exports.useDragHandleComponent)({\n    id,\n    shouldShowDragHandle,\n    type: layoutItemType,\n    portalRef: dragHandlePortal\n  });\n  const handleMouseDown = (0, react_exports.useCallback)(\n    (event) => {\n      if (shouldShowDragHandle) {\n        event.stopPropagation();\n        const newEvent = new CustomEvent(\n          dashboard_ui_exports.EVENT_MOUSE_DOWN_ON_VIZ_WITH_HANDLE,\n          {\n            detail: {\n              vizId: id,\n              initialEvent: event,\n              type: layoutItemType\n            }\n          }\n        );\n        document.dispatchEvent(newEvent);\n      }\n    },\n    [shouldShowDragHandle, id, layoutItemType]\n  );\n  const ItemContainer = (0, react_exports.useMemo)(() => {\n    const commonProps = {\n      id,\n      width,\n      height,\n      mode,\n      itemDefinition,\n      loading,\n      refresh,\n      control,\n      updateRequestParams,\n      dataSources\n    };\n    if (layoutItemType === \"block\") {\n      return /* @__PURE__ */ react_default.createElement(\n        VisualizationContainer_default,\n        __spreadProps(__spreadValues({}, commonProps), {\n          isFullscreen,\n          onSelected\n        })\n      );\n    }\n    return /* @__PURE__ */ react_default.createElement(\n      InputContent_default,\n      __spreadProps(__spreadValues({}, commonProps), {\n        isSelected: isSelected && !isMultiSelect,\n        isOnCanvas: true\n      })\n    );\n  }, [\n    dataSources,\n    height,\n    id,\n    isFullscreen,\n    isSelected,\n    itemDefinition,\n    layoutItemType,\n    loading,\n    mode,\n    onSelected,\n    refresh,\n    control,\n    updateRequestParams,\n    width,\n    isMultiSelect\n  ]);\n  return /* @__PURE__ */ react_default.createElement(dashboard_ui_exports.ErrorBoundary, { render: handleError }, /* @__PURE__ */ react_default.createElement(\n    ItemWrapper,\n    {\n      width,\n      height,\n      layoutItemType,\n      $itemType: itemType,\n      itemId: id\n    },\n    /* @__PURE__ */ react_default.createElement(\n      dashboard_ui_exports.SelectableContainer,\n      {\n        itemId: id,\n        width: containerWidth,\n        height: containerHeight,\n        outlineStyle,\n        onMouseDown: handleMouseDown,\n        zIndex: selectionLayer,\n        canBeHidden: mode === \"edit\" && canBeHidden,\n        tabIndex: 0\n      },\n      /* @__PURE__ */ react_default.createElement(ItemLayer, { zIndex: itemLayer }, DragHandle, /* @__PURE__ */ react_default.createElement(\n        CornerRadiusContainer_default,\n        {\n          cornerRadius: radius,\n          \"data-test\": \"corner-radius-container\"\n        },\n        ItemContainer\n      )),\n      !isMultiSelect && actionMenu\n    )\n  ));\n};\n\n// src/containers/LineContainer.tsx\nvar LineContainerWithDataSource = (props) => {\n  const _a = props, { dataSourceId, vizType } = _a, lineProps = __objRest(_a, [\"dataSourceId\", \"vizType\"]);\n  const dataSourceBindings = (0, react_exports.useMemo)(\n    () => ({ primary: dataSourceId }),\n    [dataSourceId]\n  );\n  const preset = (0, dashboard_context_exports.usePreset)();\n  const { loading, dataSources, updateRequestParams } = (0, dashboard_ui_exports.useSubscribeToSearches)({\n    consumerId: lineProps.id,\n    bindings: dataSourceBindings\n  });\n  return preset.createVisualization(vizType, __spreadProps(__spreadValues({}, lineProps), {\n    loading,\n    dataSources,\n    onRequestParamsChange: updateRequestParams\n  }));\n};\nvar LineContainer = (props) => {\n  const {\n    id,\n    mode,\n    from,\n    to,\n    vizDef: {\n      type,\n      options = {},\n      dataSources: dataSourceBindings = {},\n      context\n    } = {},\n    onLineSelect,\n    onOptionsChange,\n    dataSourceDefs,\n    handleEvent\n  } = props;\n  const preset = (0, dashboard_context_exports.usePreset)();\n  const eventRegistry = (0, dashboard_context_exports.useEventRegistry)();\n  const onEventTrigger = (0, react_exports.useCallback)(\n    ({\n      type: eventType,\n      originalEvent,\n      payload\n    }) => {\n      const eventId = eventRegistry.registerEvent(originalEvent);\n      handleEvent == null ? void 0 : handleEvent(eventType, payload, eventId);\n    },\n    [handleEvent, eventRegistry]\n  );\n  if (!type) {\n    return null;\n  }\n  const lineProps = {\n    id,\n    mode,\n    from,\n    to,\n    options,\n    context,\n    onLineSelect,\n    onOptionsChange,\n    onEventTrigger\n  };\n  const primaryDataSourceId = dataSourceBindings.primary;\n  if (primaryDataSourceId && (dataSourceDefs == null ? void 0 : dataSourceDefs[primaryDataSourceId])) {\n    return /* @__PURE__ */ react_default.createElement(\n      LineContainerWithDataSource,\n      __spreadProps(__spreadValues({}, lineProps), {\n        vizType: type,\n        dataSourceId: primaryDataSourceId\n      })\n    );\n  }\n  return preset.createVisualization(type, __spreadProps(__spreadValues({}, lineProps), {\n    loading: false,\n    dataSources: {},\n    onRequestParamsChange: dashboard_utils_exports.noop\n  }));\n};\nvar LineContainer_default = react_default.memo(LineContainer);\n\n// src/containers/connected/ConnectedLineContainer.tsx\nvar ConnectedLineContainer = (props) => {\n  const selectVizDef = (0, react_exports.useMemo)(dashboard_state_exports.selectVisualizationDefinitionFactory, []);\n  const selectDSDef = (0, react_exports.useMemo)(dashboard_state_exports.selectDataSourceDefinitionForVizFactory, []);\n  const dispatch = (0, dashboard_state_exports.useDispatch)();\n  const handleEvent = (0, react_exports.useCallback)(\n    (eventType, payload, eventId) => dispatch((0, dashboard_state_exports.triggerEvent)(props.id, eventType, payload, eventId)),\n    [dispatch, props.id]\n  );\n  const onOptionsChange = (0, react_exports.useCallback)(\n    (newOptions) => dispatch((0, dashboard_state_exports.updateVizOptions)(props.id, newOptions)),\n    [dispatch, props.id]\n  );\n  const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);\n  const vizDef = (0, dashboard_state_exports.useSelector)((state) => selectVizDef(state, props.id));\n  const dataSourceDefs = (0, dashboard_state_exports.useSelector)((state) => selectDSDef(state, props.id));\n  return /* @__PURE__ */ react_default.createElement(\n    LineContainer_default,\n    __spreadProps(__spreadValues({}, props), {\n      handleEvent,\n      onOptionsChange,\n      mode,\n      vizDef,\n      dataSourceDefs\n    })\n  );\n};\nvar ConnectedLineContainer_default = ConnectedLineContainer;\n\n// src/containers/layouts/LayoutContainer.tsx\nvar renderLayoutItem = (id, props, layoutItemType, onSelected) => {\n  if (layoutItemType === \"line\") {\n    return /* @__PURE__ */ react_default.createElement(\n      ConnectedLineContainer_default,\n      __spreadValues({\n        key: id,\n        id\n      }, props)\n    );\n  }\n  return /* @__PURE__ */ react_default.createElement(\n    BaseItemContainer,\n    __spreadProps(__spreadValues({\n      key: id,\n      id\n    }, props), {\n      layoutItemType,\n      onSelected\n    })\n  );\n};\nvar LayoutContainer2 = ({\n  handleEvent,\n  height,\n  // container height in pixel\n  layout,\n  mode,\n  onLayoutItemsSelect,\n  onLayoutStructureChange,\n  selectedItems,\n  showGrid,\n  width,\n  // container width in pixel\n  isDashboardFullscreen,\n  layoutId\n}) => {\n  const apiRegistry = (0, dashboard_context_exports.useApiRegistry)();\n  const eventRegistry = (0, dashboard_context_exports.useEventRegistry)();\n  const preset = (0, dashboard_context_exports.usePreset)();\n  const handleLayoutMount = (0, react_exports.useCallback)(\n    (layoutApi) => {\n      if (!layoutId) {\n        return;\n      }\n      if (layoutApi) {\n        apiRegistry.registerLayoutApi({ layoutId, layoutApi });\n      } else {\n        apiRegistry.removeLayoutApi(layoutId);\n      }\n    },\n    [layoutId, apiRegistry]\n  );\n  const onEventTrigger = (0, react_exports.useCallback)(\n    ({ type: eventType, originalEvent, payload }) => {\n      const eventId = eventRegistry.registerEvent(originalEvent);\n      handleEvent == null ? void 0 : handleEvent(eventType, payload, eventId);\n    },\n    [handleEvent, eventRegistry]\n  );\n  return (0, react_exports.useMemo)(() => {\n    const { type, options, structure: layoutStructure } = layout;\n    if (!preset.findLayout(type)) {\n      return /* @__PURE__ */ react_default.createElement(\n        dashboard_ui_exports.Message,\n        {\n          level: \"error\",\n          message: (0, i18n_exports._)(`Layout ${type} is not defined`)\n        }\n      );\n    }\n    const layoutProps = {\n      key: layoutId,\n      // we send down the actual width/height of dashboard-core container\n      containerHeight: height,\n      containerWidth: width,\n      layoutApiRef: handleLayoutMount,\n      layoutStructure,\n      mode,\n      onEventTrigger,\n      onLayoutItemsSelect,\n      onLayoutStructureChange,\n      options: isDashboardFullscreen && type === \"absolute\" && (options == null ? void 0 : options.display) !== \"fit-to-width\" ? __spreadProps(__spreadValues({}, options), { display: \"fit-to-width\" }) : options,\n      renderLayoutItem,\n      selectedItems,\n      showGrid\n    };\n    return preset.createLayout(type, layoutProps);\n  }, [\n    layout,\n    preset,\n    layoutId,\n    height,\n    width,\n    handleLayoutMount,\n    mode,\n    onEventTrigger,\n    onLayoutItemsSelect,\n    onLayoutStructureChange,\n    isDashboardFullscreen,\n    selectedItems,\n    showGrid\n  ]);\n};\nvar LayoutContainer_default = LayoutContainer2;\n\n// src/containers/connected/ConnectedLayoutContainer.tsx\nvar ConnectedLayoutContainer_default = (_a) => {\n  var _b = _a, { layoutId } = _b, rest = __objRest(_b, [\"layoutId\"]);\n  const dispatch = (0, dashboard_state_exports.useDispatch)();\n  const { enableTokensInBackgroundImage } = (0, dashboard_context_exports.useFeatureFlags)();\n  const handleEvent = (0, react_exports.useCallback)(\n    (eventType, payload, eventId) => dispatch((0, dashboard_state_exports.triggerEvent)(null, eventType, payload, eventId)),\n    [dispatch]\n  );\n  const onLayoutItemsSelect = (0, react_exports.useCallback)(\n    (newSelectedItems) => {\n      (0, dashboard_state_exports.batch)(() => {\n        dispatch((0, dashboard_state_exports.updateSelectedGlobalItems)([]));\n        dispatch((0, dashboard_state_exports.updateSelectedItems)(newSelectedItems));\n      });\n    },\n    [dispatch]\n  );\n  const onLayoutStructureChange = (0, react_exports.useCallback)(\n    (layoutStructure) => dispatch((0, dashboard_state_exports.updateLayoutStructure)(layoutStructure, layoutId)),\n    [dispatch, layoutId]\n  );\n  const layout = (0, dashboard_state_exports.useSelector)(\n    enableTokensInBackgroundImage ? dashboard_state_exports.selectResolvedLayoutIncludingBackgroundImage : dashboard_state_exports.selectResolvedLayout\n  );\n  const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);\n  const selectedItems = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectSelectedItems);\n  const isDashboardFullscreen = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectIsDashboardFullscreen);\n  return /* @__PURE__ */ react_default.createElement(\n    LayoutContainer_default,\n    __spreadProps(__spreadValues({}, rest), {\n      layoutId,\n      handleEvent,\n      onLayoutItemsSelect,\n      onLayoutStructureChange,\n      layout,\n      mode,\n      selectedItems,\n      isDashboardFullscreen\n    })\n  );\n};\n\n// esm-externals:@splunk/dashboard-layouts\nvar dashboard_layouts_exports = {};\n__export(dashboard_layouts_exports, {\n  default: () => dashboard_layouts_default\n});\nvar defaultImport29 = __toESM(require(\"@splunk/dashboard-layouts\"));\n__reExport(dashboard_layouts_exports, require(\"@splunk/dashboard-layouts\"));\nvar dashboard_layouts_default = \"default\" in defaultImport29 ? defaultImport29.default : defaultImport29;\n\n// esm-externals:prop-types\nvar prop_types_exports = {};\n__export(prop_types_exports, {\n  default: () => prop_types_default\n});\nvar defaultImport30 = __toESM(require(\"prop-types\"));\n__reExport(prop_types_exports, require(\"prop-types\"));\nvar prop_types_default = \"default\" in defaultImport30 ? defaultImport30.default : defaultImport30;\n\n// src/containers/connected/ConnectedInputContainer.jsx\nvar wrapperAttributes = ({ $transform, $transition, isDragging } = {}) => ({\n  \"data-test\": \"input-item\",\n  tabIndex: 0,\n  style: {\n    transform: utilities_exports.CSS.Translate.toString($transform),\n    transition: isDragging ? $transition : void 0\n  }\n});\nvar Wrapper = styled_components_default.div.attrs(wrapperAttributes)`\n    display: inline-block;\n    z-index: ${({ isDragging }) => isDragging ? 1 : void 0};\n    opacity: ${({ isDragging }) => isDragging ? 0.4 : 1};\n`;\nvar ConnectedInputContainer = (_a) => {\n  var _b = _a, {\n    setNodeRef,\n    transform,\n    transition,\n    isDragging,\n    attributes,\n    listeners,\n    mode,\n    isSelected\n  } = _b, props = __objRest(_b, [\n    \"setNodeRef\",\n    \"transform\",\n    \"transition\",\n    \"isDragging\",\n    \"attributes\",\n    \"listeners\",\n    \"mode\",\n    \"isSelected\"\n  ]);\n  var _a2, _b2;\n  const selectInputDef = (0, react_exports.useMemo)(dashboard_state_exports.selectInputDefinitionFactory, []);\n  const dispatch = (0, dashboard_state_exports.useDispatch)();\n  const onRemove = (0, react_exports.useCallback)(\n    (inputId) => dispatch(\n      (0, dashboard_state_exports.removeDashboardItems)(\n        { itemIds: [inputId] },\n        { confirmDeletion: true }\n      )\n    ),\n    [dispatch]\n  );\n  const onSelect = (0, react_exports.useCallback)(\n    () => dispatch(\n      (0, dashboard_state_exports.updateSelectedGlobalItems)([{ id: props.id, type: \"input\" }])\n    ),\n    [dispatch, props.id]\n  );\n  const inputDef = (0, dashboard_state_exports.useSelector)((state) => selectInputDef(state, props.id));\n  const { type, dataSources: dataSourceBindings = {} } = inputDef;\n  const primaryDataSourceId = dataSourceBindings.primary;\n  const commonProps = {\n    onRemove,\n    itemDefinition: inputDef,\n    mode,\n    isSelected: isSelected && !isDragging,\n    attributes,\n    listeners\n  };\n  const { loading, dataSources, refresh, updateRequestParams } = (0, dashboard_ui_exports.useSubscribeToSearches)({\n    consumerId: props.id,\n    bindings: dataSourceBindings\n  });\n  const canBeHidden = useCanItemBeHidden({\n    itemDefinition: inputDef,\n    itemId: props.id\n  });\n  if (mode === \"view\" && canBeHidden && !((_b2 = (_a2 = dataSources == null ? void 0 : dataSources.primary) == null ? void 0 : _a2.meta) == null ? void 0 : _b2.totalCount)) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(\n    Wrapper,\n    {\n      ref: setNodeRef,\n      \"data-input-id\": props.id,\n      \"data-input-type\": type,\n      \"data-test-selected\": isSelected,\n      onFocus: onSelect,\n      $transform: transform,\n      $transition: transition,\n      isDragging\n    },\n    primaryDataSourceId ? /* @__PURE__ */ react_default.createElement(\n      InputContent_default,\n      __spreadProps(__spreadValues(__spreadValues({}, props), commonProps), {\n        loading,\n        dataSources,\n        refresh,\n        updateRequestParams\n      })\n    ) : /* @__PURE__ */ react_default.createElement(InputContent_default, __spreadValues(__spreadValues({}, props), commonProps))\n  );\n};\nConnectedInputContainer.propTypes = {\n  id: prop_types_default.string\n};\nvar withSortable = (Component) => (props) => {\n  var _a;\n  const { enableDragDropInputs } = (0, dashboard_context_exports.useFeatureFlags)();\n  const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);\n  const selectIsInputSelected = (0, react_exports.useMemo)(dashboard_state_exports.makeSelectIsSelected, []);\n  const isSelected = (0, dashboard_state_exports.useSelector)(\n    (state) => selectIsInputSelected(state, props.id)\n  );\n  const globalInputs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectGlobalInputs);\n  const isGlobalInput = (_a = globalInputs == null ? void 0 : globalInputs.includes(props.id)) != null ? _a : false;\n  const isDraggable = (0, react_exports.useMemo)(\n    () => enableDragDropInputs && mode === \"edit\" && isSelected && isGlobalInput,\n    [enableDragDropInputs, mode, isSelected, isGlobalInput]\n  );\n  const {\n    setNodeRef,\n    transform,\n    transition,\n    isDragging,\n    attributes,\n    listeners\n  } = (0, sortable_exports.useSortable)({\n    id: props.id,\n    disabled: !isDraggable,\n    data: { snapCenterToCursor: true }\n  });\n  const sortableProps = {\n    setNodeRef,\n    transform,\n    transition,\n    isDragging,\n    attributes,\n    listeners,\n    mode,\n    isSelected\n  };\n  return /* @__PURE__ */ react_default.createElement(Component, __spreadValues(__spreadValues({}, props), sortableProps));\n};\nvar ConnectedInputContainer_default = withSortable(react_default.memo(ConnectedInputContainer, lodash_exports.isEqual));\n\n// src/containers/layouts/GlobalInputContainer.tsx\nvar renderInput = ({\n  inputId,\n  index\n}) => /* @__PURE__ */ react_default.createElement(ConnectedInputContainer_default, { key: inputId, id: inputId, index });\nvar emptyGlobalInputs = [];\nvar GlobalInputContainer_default = () => {\n  var _a, _b;\n  const apiRegistry = (0, dashboard_context_exports.useApiRegistry)();\n  const dispatch = (0, dashboard_state_exports.useDispatch)();\n  const inputsRef = (0, react_exports.useRef)(null);\n  const globalInputsApi = (0, react_exports.useMemo)(() => {\n    return {\n      getInputsDomElement: () => {\n        return inputsRef.current;\n      }\n    };\n  }, [inputsRef]);\n  const onSubmitButtonClick = (0, react_exports.useCallback)(\n    () => dispatch((0, dashboard_state_exports.submitTokens)(dashboard_utils_exports.DEFAULT_TOKEN_NAMESPACE)),\n    [dispatch]\n  );\n  const submitButtonDisabled = !(0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectAreTokensReadyToSubmit);\n  (0, react_exports.useEffect)(() => {\n    apiRegistry.registerGlobalInputsApi(globalInputsApi);\n    return () => {\n      apiRegistry.removeGlobalInputsApi();\n    };\n  }, [apiRegistry, globalInputsApi]);\n  const submitButton = !!((_a = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectLayoutGlobalOptions)) == null ? void 0 : _a.submitButton);\n  const globalInputs = (_b = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectGlobalInputs)) != null ? _b : emptyGlobalInputs;\n  return /* @__PURE__ */ react_default.createElement(\n    dashboard_layouts_exports.InputLayout,\n    {\n      submitButtonDisabled,\n      onSubmitButtonClick,\n      submitButton,\n      inputStructure: globalInputs,\n      renderInput,\n      ref: inputsRef\n    }\n  );\n};\n\n// src/containers/DashboardContainer.tsx\nvar GlobalErrorMessage = ({ message }) => /* @__PURE__ */ react_default.createElement(dashboard_ui_exports.Message, { level: \"error\", message });\nvar renderErrorMessage = (errorMessage) => /* @__PURE__ */ react_default.createElement(GlobalErrorMessage, { message: errorMessage });\nvar renderGlobalInput = () => /* @__PURE__ */ react_default.createElement(GlobalInputContainer_default, null);\nvar DashboardContainer = ({\n  message,\n  height,\n  width,\n  globalInputs\n}) => {\n  const showGrid = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectAreGridLinesEnabled);\n  const layoutId = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectActiveTab);\n  const renderLayout = (0, react_exports.useCallback)(\n    (dimension) => /* @__PURE__ */ react_default.createElement(\n      ConnectedLayoutContainer_default,\n      {\n        width: dimension.width,\n        height: dimension.height,\n        showGrid,\n        layoutId\n      }\n    ),\n    [layoutId, showGrid]\n  );\n  if (message) {\n    return /* @__PURE__ */ react_default.createElement(GlobalErrorMessage, { message });\n  }\n  return /* @__PURE__ */ react_default.createElement(dashboard_ui_exports.ErrorBoundary, { render: renderErrorMessage }, /* @__PURE__ */ react_default.createElement(\n    DashboardLayout_default,\n    {\n      width: width != null ? width : 0,\n      height: height != null ? height : 0,\n      renderGlobalInput,\n      renderLayout,\n      showGlobalInputs: !!(Array.isArray(globalInputs) && globalInputs.length)\n    }\n  ));\n};\nDashboardContainer.defaultProps = {\n  globalInputs: [],\n  message: null\n};\nvar DashboardContainer_default = DashboardContainer;\n\n// src/containers/connected/ConnectedDashboardContainer.tsx\nvar ConnectedDashboardContainer_default = (props) => {\n  const message = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectGlobalMessage);\n  const globalInputs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectGlobalInputs);\n  return /* @__PURE__ */ react_default.createElement(\n    DashboardContainer_default,\n    __spreadProps(__spreadValues({}, props), {\n      message,\n      globalInputs\n    })\n  );\n};\n\n// src/utils/withDefinition.tsx\nvar withDefinition = (WrappedComponent) => (props) => {\n  const definition = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectDefinition);\n  return /* @__PURE__ */ react_default.createElement(WrappedComponent, __spreadProps(__spreadValues({}, props), { definition }));\n};\n\n// src/utils/withReadOnlyTokenNamespaces.tsx\nvar withReadOnlyTokenNamespaces = (WrappedComponent) => (props) => {\n  const namespaces = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectReadOnlyTokenNamespaces);\n  return /* @__PURE__ */ react_default.createElement(\n    WrappedComponent,\n    __spreadProps(__spreadValues({}, props), {\n      readOnlyTokenNamespaces: namespaces\n    })\n  );\n};\n\n// esm-externals:@splunk/dashboard-definition\nvar dashboard_definition_exports = {};\n__export(dashboard_definition_exports, {\n  default: () => dashboard_definition_default\n});\nvar defaultImport31 = __toESM(require(\"@splunk/dashboard-definition\"));\n__reExport(dashboard_definition_exports, require(\"@splunk/dashboard-definition\"));\nvar dashboard_definition_default = \"default\" in defaultImport31 ? defaultImport31.default : defaultImport31;\n\n// src/utils/withValidationSchema.tsx\nvar createSchema = (preset) => {\n  try {\n    return (0, dashboard_definition_exports.createSchemaBasedOnPresets)(preset);\n  } catch (e) {\n    dashboard_utils_exports.console.error(\"Schema Error:\", e);\n    return dashboard_definition_exports.defaultSchema;\n  }\n};\nvar withValidationSchema = (WrappedComponent) => (props) => {\n  const preset = (0, dashboard_context_exports.usePreset)();\n  const schema = (0, react_exports.useMemo)(\n    () => createSchema(preset.getPresetDefinition()),\n    [preset]\n  );\n  return /* @__PURE__ */ react_default.createElement(WrappedComponent, __spreadProps(__spreadValues({}, props), { schema }));\n};\n\n// src/hooks/useActiveTabWithUrl.ts\nvar useActiveTabWithUrl = () => {\n  const dispatch = (0, dashboard_state_exports.useDispatch)();\n  const activeTab = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectActiveTab);\n  const allTabs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectTabs);\n  const tabIds = (0, react_exports.useMemo)(() => allTabs.map((tab) => tab.layoutId), [allTabs]);\n  const handlePopState = (0, dashboard_ui_exports.useEventCallback)(() => {\n    const newActiveTab = (0, dashboard_utils_exports.mapURLToActiveTab)({\n      search: (0, dashboard_utils_exports.getWindowLocationSearch)(),\n      tabIds\n    });\n    if (newActiveTab && newActiveTab !== activeTab) {\n      dispatch((0, dashboard_state_exports.setActiveTab)(newActiveTab));\n    }\n  });\n  (0, react_exports.useEffect)(() => {\n    window.addEventListener(\"popstate\", handlePopState);\n    return () => {\n      window.removeEventListener(\"popstate\", handlePopState);\n    };\n  }, [handlePopState]);\n  (0, react_exports.useEffect)(() => {\n    const search = (0, dashboard_utils_exports.getWindowLocationSearch)();\n    const searchWithActiveTab = (0, dashboard_utils_exports.mapActiveTabToURL)({ search, activeTab });\n    if (search !== `?${searchWithActiveTab}`) {\n      const url = new URL(window.location.href);\n      url.search = searchWithActiveTab;\n      window.history.pushState({}, \"\", url.toString());\n    }\n  }, [activeTab]);\n};\n\n// src/utils/withActiveTabInUrl.tsx\nvar ActiveTabInUrl = () => {\n  useActiveTabWithUrl();\n  return null;\n};\nvar withActiveTabInUrl = (Component) => (props) => {\n  const { trackActiveTabInUrl } = (0, dashboard_context_exports.useFeatureFlags)();\n  return trackActiveTabInUrl ? /* @__PURE__ */ react_default.createElement(react_default.Fragment, null, /* @__PURE__ */ react_default.createElement(ActiveTabInUrl, null), /* @__PURE__ */ react_default.createElement(Component, __spreadValues({}, props))) : /* @__PURE__ */ react_default.createElement(Component, __spreadValues({}, props));\n};\n\n// src/hooks/useTokensWithUrl.ts\nvar useTokensWithUrl = () => {\n  const dispatch = (0, dashboard_state_exports.useDispatch)();\n  const inputDefs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectInputs);\n  const tokens = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectSubmittedTokens);\n  const preset = (0, dashboard_context_exports.usePreset)();\n  const handlePopState = (0, dashboard_ui_exports.useEventCallback)(() => {\n    const newTokens = (0, dashboard_utils_exports.mapURLToTokens)({\n      search: (0, dashboard_utils_exports.getWindowLocationSearch)()\n    });\n    if (!(0, lodash_exports.isEqual)(tokens.default, newTokens.default)) {\n      (0, dashboard_state_exports.batch)(() => {\n        dispatch(\n          (0, dashboard_state_exports.setInputState)({\n            currentInputState: {},\n            inputDefs,\n            tokens: newTokens,\n            preset\n          })\n        );\n        dispatch((0, dashboard_state_exports.setToken)(newTokens.default));\n      });\n    }\n  });\n  (0, react_exports.useEffect)(() => {\n    window.addEventListener(\"popstate\", handlePopState);\n    return () => {\n      window.removeEventListener(\"popstate\", handlePopState);\n    };\n  }, [handlePopState]);\n  (0, react_exports.useEffect)(() => {\n    if ((0, lodash_exports.isEmpty)(tokens == null ? void 0 : tokens[dashboard_utils_exports.DEFAULT_TOKEN_NAMESPACE])) {\n      return void 0;\n    }\n    const search = (0, dashboard_utils_exports.getWindowLocationSearch)();\n    const searchWithTokens = (0, dashboard_utils_exports.mapTokensToURL)({\n      search,\n      tokens\n    });\n    if (search !== `?${searchWithTokens}`) {\n      const url = new URL(window.location.href);\n      url.search = searchWithTokens;\n      window.history.pushState({}, \"\", url.toString());\n    }\n    return void 0;\n  }, [tokens]);\n};\n\n// src/utils/withTokensInUrl.tsx\nvar TokensInUrl = () => {\n  useTokensWithUrl();\n  return null;\n};\nvar withTokensInUrl = (Component) => (props) => {\n  const { enableTokensInUrl } = (0, dashboard_context_exports.useFeatureFlags)();\n  return enableTokensInUrl ? /* @__PURE__ */ react_default.createElement(react_default.Fragment, null, /* @__PURE__ */ react_default.createElement(TokensInUrl, null), /* @__PURE__ */ react_default.createElement(Component, __spreadValues({}, props))) : /* @__PURE__ */ react_default.createElement(Component, __spreadValues({}, props));\n};\n\n// src/utils/simplifySchemaErrorMessages.ts\nvar ErrorWithItemId = (0, i18n_exports._)(\n  'The property \"%(property)s\" for %(itemType)s \"%(itemId)s\" has an invalid configuration.'\n);\nvar StanzaErrorWithoutItemId = (0, i18n_exports._)(\n  'The property \"%(property)s\" in the %(stanza)s stanza has an invalid configuration.'\n);\nvar RootErrorWithoutItemId = (0, i18n_exports._)(\n  'The property \"%(property)s\" has an invalid configuration.'\n);\nvar ItemDefinitionError = (0, i18n_exports._)(\n  'The definition for %(itemType)s \"%(itemId)s\" has an invalid configuration.'\n);\nvar TypeDefaultError = (0, i18n_exports._)(\n  'The default for \"%(itemType)s\" %(itemClass)s has an invalid configuration.'\n);\nvar TypePropertyDefaultError = (0, i18n_exports._)(\n  'The \"%(property)s\" default for \"%(itemType)s\" %(itemClass)s has an invalid configuration.'\n);\nvar TokenNamespaceError = (0, i18n_exports._)(\n  'The default for token namespace \"%(namespace)s\" has an invalid configuration.'\n);\nvar TokenError = (0, i18n_exports._)(\n  'The default for token \"%(token)s\" in namespace \"%(namespace)s\" has an invalid configuration.'\n);\nvar isNumeric = (value) => typeof value === \"string\" && !Number.isNaN(value) && !Number.isNaN(parseFloat(value));\nvar simplifyLayoutError = (pathSegments) => {\n  if (pathSegments[1] === \"layoutDefinitions\" || pathSegments[1] === \"tabs\") {\n    const itemType = pathSegments[1] === \"layoutDefinitions\" ? (0, i18n_exports._)(\"layout\") : (0, i18n_exports._)(\"tab\");\n    if (pathSegments.length === 3) {\n      return (0, format_exports.sprintf)(ItemDefinitionError, {\n        itemType,\n        itemId: pathSegments[2]\n      });\n    }\n    const property = pathSegments.slice(3).join(\".\");\n    return (0, format_exports.sprintf)(ErrorWithItemId, {\n      property,\n      itemType,\n      itemId: pathSegments[2]\n    });\n  }\n  if (pathSegments[1] === \"options\") {\n    return (0, format_exports.sprintf)(StanzaErrorWithoutItemId, {\n      property: pathSegments.slice(1).join(\".\"),\n      stanza: (0, i18n_exports._)(\"layout\")\n    });\n  }\n  if (pathSegments[1] === \"globalInputs\") {\n    return (0, format_exports.sprintf)(StanzaErrorWithoutItemId, {\n      property: \"globalInputs\",\n      stanza: (0, i18n_exports._)(\"layout\")\n    });\n  }\n  return void 0;\n};\nvar simplifySchemaError = (pathSegments) => {\n  const itemType = pathSegments[0].slice(0, -1).toLowerCase();\n  if (pathSegments.length === 2) {\n    return (0, format_exports.sprintf)(ItemDefinitionError, {\n      itemType,\n      itemId: pathSegments[1]\n    });\n  }\n  if (isNumeric(pathSegments[pathSegments.length - 1])) {\n    return (0, format_exports.sprintf)(ErrorWithItemId, {\n      property: pathSegments.slice(2, -1).join(\".\"),\n      itemType,\n      itemId: pathSegments[1]\n    });\n  }\n  return (0, format_exports.sprintf)(ErrorWithItemId, {\n    property: pathSegments.slice(2).join(\".\"),\n    itemType,\n    itemId: pathSegments[1]\n  });\n};\nvar simplifyTokenDefaultsError = (pathSegments) => {\n  if (pathSegments.length === 3) {\n    return (0, format_exports.sprintf)(TokenNamespaceError, { namespace: pathSegments[2] });\n  }\n  const [, , namespace, token] = pathSegments;\n  return (0, format_exports.sprintf)(TokenError, { namespace, token });\n};\nvar simplifyDefaultsError = (pathSegments) => {\n  if (pathSegments.length === 2) {\n    return (0, format_exports.sprintf)(StanzaErrorWithoutItemId, {\n      stanza: pathSegments[0],\n      property: pathSegments[1]\n    });\n  }\n  if (pathSegments[1] === \"tokens\") {\n    return simplifyTokenDefaultsError(\n      pathSegments\n    );\n  }\n  if (pathSegments.length > 3) {\n    const [, itemClass, itemType, ...propertyPath] = pathSegments;\n    const property = propertyPath.join(\".\");\n    return (0, format_exports.sprintf)(TypePropertyDefaultError, {\n      itemClass,\n      itemType,\n      property\n    });\n  }\n  return (0, format_exports.sprintf)(TypeDefaultError, {\n    itemClass: pathSegments[1],\n    itemType: pathSegments[2]\n  });\n};\nvar simplifySchemaErrorMessages = (errors) => {\n  const messages = {};\n  const result = /* @__PURE__ */ new Set();\n  errors.forEach(({ instancePath, message }) => {\n    if (message === 'must match \"then\" schema') {\n      return;\n    }\n    if (!instancePath || instancePath[0] !== \"/\") {\n      if (message) {\n        result.add(message);\n      }\n      return;\n    }\n    if (messages[instancePath]) {\n      return;\n    }\n    const pathSegments = instancePath.slice(1).split(\"/\");\n    if (pathSegments.length === 1) {\n      messages[instancePath] = (0, format_exports.sprintf)(RootErrorWithoutItemId, {\n        property: pathSegments[0]\n      });\n      return;\n    }\n    if (pathSegments[0] === \"layout\") {\n      messages[instancePath] = simplifyLayoutError(pathSegments);\n    } else if (pathSegments[0] === \"visualizations\" || pathSegments[0] === \"inputs\" || pathSegments[0] === \"dataSources\") {\n      messages[instancePath] = simplifySchemaError(pathSegments);\n    } else if (pathSegments[0] === \"defaults\") {\n      messages[instancePath] = simplifyDefaultsError(\n        pathSegments\n      );\n    } else if (pathSegments[0] === \"expressions\") {\n    }\n  });\n  Object.values(messages).forEach((message) => {\n    if (message) {\n      result.add(message);\n    }\n  });\n  return Array.from(result);\n};\n\n// src/DashboardCore.tsx\nvar ValidatorComponent = withValidationSchema(\n  withReadOnlyTokenNamespaces(withDefinition(dashboard_validation_exports.Validator))\n);\nvar formatValidateError = ({\n  instancePath,\n  message\n}) => {\n  if (instancePath) {\n    return `${instancePath}: ${message}`;\n  }\n  return message;\n};\nvar emitDashboardRenderedEvent = (0, lodash_exports.once)(() => {\n  document.dispatchEvent(\n    new Event(\"dashboardCore.rendered\", { bubbles: true })\n  );\n});\nvar noop2 = () => void 0;\nvar defaultActionMenus = [];\nvar defaultMeta = Object.freeze({});\nvar defaultOverrides = Object.freeze({});\nvar DashboardCore = ({\n  dashboardCoreApiRef = noop2,\n  width = \"100%\",\n  height = 600,\n  actionMenus = defaultActionMenus,\n  metadata = defaultMeta,\n  onValidationError,\n  overrides = defaultOverrides\n}) => {\n  const store = (0, dashboard_state_exports.useStore)();\n  const apiRegistry = (0, dashboard_context_exports.useApiRegistry)();\n  const profiler = (0, dashboard_telemetry_exports.useDashboardProfiler)();\n  const dashboardPlugin = (0, dashboard_context_exports.useDashboardPlugin)();\n  const searchMetricsCollector = (0, dashboard_context_exports.useSearchMetricsCollector)();\n  const logger = (0, dashboard_context_exports.useLogger)();\n  const { simplifySchemaErrors = false } = (0, dashboard_context_exports.useFeatureFlags)();\n  const isFirstRender = (0, dashboard_context_exports.useIsFirstRender)();\n  const dashboardCoreApi = (0, dashboard_context_exports.useDashboardCoreApi)();\n  (0, react_exports.useEffect)(() => {\n    dashboardCoreApiRef(dashboardCoreApi);\n    return () => {\n      dashboardCoreApiRef(null);\n    };\n  }, [dashboardCoreApiRef, dashboardCoreApi]);\n  if (isFirstRender) {\n    profiler == null ? void 0 : profiler.startTimer({\n      timerName: dashboard_telemetry_exports.DASHBOARD_CORE_MOUNT_TO_RENDER_EVENT\n    });\n    const onAllDSResolved = () => {\n      const definition = (0, dashboard_state_exports.selectDefinition)(store.getState());\n      profiler == null ? void 0 : profiler.emitAndClearTimer({\n        timerName: dashboard_telemetry_exports.DASHBOARD_CORE_MOUNT_TO_RENDER_EVENT,\n        definition\n      });\n      emitDashboardRenderedEvent();\n    };\n    searchMetricsCollector.addMetricsCollectedCallback(onAllDSResolved);\n  }\n  (0, react_exports.useEffect)(() => {\n    return () => {\n      apiRegistry.cleanup();\n    };\n  }, [apiRegistry]);\n  if (isFirstRender) {\n    const dataSources = (0, dashboard_state_exports.selectDataSourceDefinitions)(store.getState());\n    dashboardPlugin.invokePluginCallback(\"onInitialize\", {\n      dataSourceCount: Object.keys(dataSources || {}).length\n    });\n  }\n  const clonedActionMenus = (0, react_exports.useMemo)(\n    () => actionMenus.map((item) => {\n      if (!item.props.dashboardApi) {\n        return (0, react_exports.cloneElement)(item, {\n          dashboardApi: dashboardCoreApi\n        });\n      }\n      return item;\n    }),\n    [actionMenus, dashboardCoreApi]\n  );\n  const handleValidationErrors = (0, react_exports.useCallback)(\n    (errs) => {\n      if (!errs) {\n        return;\n      }\n      const handleError = typeof onValidationError === \"function\" ? onValidationError : dashboard_utils_exports.console.error;\n      const log = typeof logger === \"function\" ? logger : noop2;\n      const errors = Array.isArray(errs) ? errs : [errs];\n      if (simplifySchemaErrors) {\n        simplifySchemaErrorMessages(errors).forEach((message) => {\n          handleError(message);\n          log({ message, metadata });\n        });\n      } else {\n        errors.forEach((error) => {\n          const message = formatValidateError(error);\n          handleError(message);\n          log({ message, metadata });\n        });\n      }\n    },\n    [onValidationError, metadata, logger, simplifySchemaErrors]\n  );\n  return /* @__PURE__ */ react_default.createElement(ActionMenusContextProvider, { value: clonedActionMenus }, /* @__PURE__ */ react_default.createElement(dashboard_context_exports.CoreOverridesContext.Provider, { value: overrides }, /* @__PURE__ */ react_default.createElement(ValidatorComponent, { onError: handleValidationErrors }), /* @__PURE__ */ react_default.createElement(ConnectedDashboardContainer_default, { width, height })));\n};\nvar DashboardCore_default = withTokensInUrl(withActiveTabInUrl(DashboardCore));\n\n// src/index.ts\nvar DashboardCore2 = DashboardCore_default;\nvar src_default = DashboardCore_default;\n//# sourceMappingURL=index.js.map\n","/* Copyright © 2020 Splunk Inc.\nSPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or\nin part without a valid written license from Splunk Inc. is PROHIBITED. */\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  BaseInput: () => BaseInput_default,\n  ButtonInput: () => Button_default2,\n  DropdownInput: () => Select_default2,\n  EnterpriseTimeRangeInput: () => EnterpriseTimeRangePicker_default,\n  MultiselectInput: () => Multiselect_default2,\n  NumberInput: () => Number_default2,\n  TextInput: () => Text_default2,\n  TimeRangeInput: () => TimeRangePicker_default,\n  withInputWrapper: () => withInputWrapper\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// esm-externals:react\nvar react_exports = {};\n__export(react_exports, {\n  default: () => react_default\n});\nvar defaultImport = __toESM(require(\"react\"));\n__reExport(react_exports, require(\"react\"));\nvar react_default = \"default\" in defaultImport ? defaultImport.default : defaultImport;\n\n// esm-externals:@splunk/ui-utils/i18n\nvar i18n_exports = {};\n__export(i18n_exports, {\n  default: () => i18n_default\n});\nvar defaultImport2 = __toESM(require(\"@splunk/ui-utils/i18n\"));\n__reExport(i18n_exports, require(\"@splunk/ui-utils/i18n\"));\nvar i18n_default = \"default\" in defaultImport2 ? defaultImport2.default : defaultImport2;\n\n// esm-externals:@splunk/react-ui/Text\nvar Text_exports = {};\n__export(Text_exports, {\n  default: () => Text_default\n});\nvar defaultImport3 = __toESM(require(\"@splunk/react-ui/Text\"));\n__reExport(Text_exports, require(\"@splunk/react-ui/Text\"));\nvar Text_default = \"default\" in defaultImport3 ? defaultImport3.default : defaultImport3;\n\n// esm-externals:@splunk/dashboard-icons\nvar dashboard_icons_exports = {};\n__export(dashboard_icons_exports, {\n  default: () => dashboard_icons_default\n});\nvar defaultImport4 = __toESM(require(\"@splunk/dashboard-icons\"));\n__reExport(dashboard_icons_exports, require(\"@splunk/dashboard-icons\"));\nvar dashboard_icons_default = \"default\" in defaultImport4 ? defaultImport4.default : defaultImport4;\n\n// esm-externals:@splunk/dashboard-ui\nvar dashboard_ui_exports = {};\n__export(dashboard_ui_exports, {\n  default: () => dashboard_ui_default\n});\nvar defaultImport5 = __toESM(require(\"@splunk/dashboard-ui\"));\n__reExport(dashboard_ui_exports, require(\"@splunk/dashboard-ui\"));\nvar dashboard_ui_default = \"default\" in defaultImport5 ? defaultImport5.default : defaultImport5;\n\n// esm-externals:@splunk/dashboard-utils\nvar dashboard_utils_exports = {};\n__export(dashboard_utils_exports, {\n  default: () => dashboard_utils_default\n});\nvar defaultImport6 = __toESM(require(\"@splunk/dashboard-utils\"));\n__reExport(dashboard_utils_exports, require(\"@splunk/dashboard-utils\"));\nvar dashboard_utils_default = \"default\" in defaultImport6 ? defaultImport6.default : defaultImport6;\n\n// esm-externals:styled-components\nvar styled_components_exports = {};\n__export(styled_components_exports, {\n  default: () => styled_components_default\n});\nvar defaultImport7 = __toESM(require(\"styled-components\"));\n__reExport(styled_components_exports, require(\"styled-components\"));\nvar styled_components_default = \"default\" in defaultImport7 ? defaultImport7.default : defaultImport7;\n\n// esm-externals:@splunk/dashboard-context\nvar dashboard_context_exports = {};\n__export(dashboard_context_exports, {\n  default: () => dashboard_context_default\n});\nvar defaultImport8 = __toESM(require(\"@splunk/dashboard-context\"));\n__reExport(dashboard_context_exports, require(\"@splunk/dashboard-context\"));\nvar dashboard_context_default = \"default\" in defaultImport8 ? defaultImport8.default : defaultImport8;\n\n// esm-externals:@splunk/themes\nvar themes_exports = {};\n__export(themes_exports, {\n  default: () => themes_default\n});\nvar defaultImport9 = __toESM(require(\"@splunk/themes\"));\n__reExport(themes_exports, require(\"@splunk/themes\"));\nvar themes_default = \"default\" in defaultImport9 ? defaultImport9.default : defaultImport9;\n\n// src/components/InputStatusIcon.tsx\nvar InputStatusIcon = ({\n  dataSource,\n  validationMessage,\n  warningMessage,\n  componentId\n}) => {\n  const anchor = (0, react_exports.useRef)(null);\n  const { open, onRequestOpen, onRequestClose } = (0, dashboard_ui_exports.usePopoverState)({\n    stopPropagation: true,\n    anchor\n  });\n  let iconStatus = (0, dashboard_ui_exports.getIconStatus)(dataSource);\n  if (warningMessage) {\n    iconStatus = \"warning\";\n  }\n  if (validationMessage) {\n    iconStatus = \"error\";\n  }\n  if (!iconStatus) {\n    return null;\n  }\n  const hasValidatorMessage = Boolean(validationMessage) || Boolean(warningMessage);\n  const hasStatusMessage = !!(0, dashboard_ui_exports.getStatusMessage)(dataSource);\n  const hasContent = hasValidatorMessage || hasStatusMessage;\n  return /* @__PURE__ */ react_default.createElement(\n    dashboard_ui_exports.PopoverStatusIcon,\n    {\n      height: 20,\n      iconSize: 13,\n      iconSizeOnHover: 15,\n      open,\n      onRequestOpen,\n      onRequestClose,\n      status: iconStatus,\n      anchor,\n      hasContent\n    },\n    /* @__PURE__ */ react_default.createElement(\n      dashboard_ui_exports.EnterprisePopoverContentFactory,\n      {\n        dataSource,\n        componentId,\n        onRequestClose,\n        message: validationMessage || warningMessage,\n        type: \"input\"\n      }\n    )\n  );\n};\n\n// src/utils/enhancer.tsx\nvar SHORT_WIDTH_DRAGGABLE = 198;\nvar LONG_WIDTH_DRAGGABLE = 198;\nvar selectedInputBackgroundColor = {\n  enterprise: {\n    light: themes_exports.variables.gray92,\n    dark: themes_exports.variables.gray30\n  },\n  prisma: themes_exports.variables.backgroundColorPopup\n};\nvar unselectedHoverColorTree = {\n  enterprise: {\n    dark: themes_exports.variables.borderLightColor,\n    light: themes_exports.variables.borderColor\n  },\n  prisma: themes_exports.variables.interactiveColorBorderHover\n};\nvar unselectedTranslucentColorTree = {\n  enterprise: {\n    dark: (0, dashboard_ui_exports.applyTranslucence)(themes_exports.variables.borderLightColor, 0.7),\n    light: (0, dashboard_ui_exports.applyTranslucence)(themes_exports.variables.borderColor, 0.7)\n  },\n  prisma: (0, dashboard_ui_exports.applyTranslucence)(themes_exports.variables.interactiveColorBorder, 0.7)\n};\nvar InputContainer = styled_components_default.div.attrs(\n  ({ width }) => ({\n    \"data-test\": \"input-container\",\n    style: {\n      width\n    }\n  })\n)`\n    padding: 8px;\n    border-radius: 4px;\n    box-sizing: border-box;\n    border: 1px solid;\n    position: relative;\n    background-color: ${(0, themes_exports.pickVariant)(\"showSelection\", {\n  true: selectedInputBackgroundColor,\n  false: \"transparent\"\n})};\n    border-style: ${(0, themes_exports.pickVariant)(\"canBeHidden\", {\n  true: \"dashed\",\n  false: \"solid\"\n})};\n    border-color: ${(0, themes_exports.pickVariant)(\"showBorder\", {\n  true: (0, themes_exports.pickVariant)(\"showSelection\", {\n    // selected:\n    true: {\n      enterprise: themes_exports.variables.focusColor,\n      prisma: themes_exports.variables.interactiveColorPrimary\n    },\n    // can be hidden but not selected:\n    false: unselectedTranslucentColorTree\n  }),\n  false: \"transparent\"\n})};\n    &:hover {\n        background-color: ${({ isOnCanvas, mode }) => isOnCanvas || mode === \"view\" ? \"transparent\" : (0, themes_exports.pick)(selectedInputBackgroundColor)};\n        border-color: ${(0, themes_exports.pickVariant)(\"showBorder\", {\n  true: (0, themes_exports.pickVariant)(\"showSelection\", {\n    false: unselectedHoverColorTree\n  }),\n  false: \"transparent\"\n})};\n    }\n`;\nvar InputDragHandle = styled_components_default.div.attrs({\n  \"data-test\": \"input-drag-handle\"\n})`\n    display: block;\n    position: absolute;\n    left: 0;\n    right: 0;\n    margin: 0 auto;\n    width: 0;\n    height: 0;\n    /* background gradient dots */\n    background: ${themes_exports.variables.draggableBackground};\n    /* blurred background */\n    background-color: ${(0, themes_exports.pick)({\n  enterprise: {\n    light: \"rgba(184, 184, 184, 0.3)\",\n    dark: \"rgba(35, 36, 43, 0.2)\"\n  },\n  prisma: {\n    light: \"rgba(184, 184, 184, 0.3)\",\n    dark: \"rgba(35, 36, 43, 0.8)\"\n  }\n})};\n    cursor: move;\n\n    :focus,\n    ${InputContainer}:hover & {\n        width: 30px;\n        height: 15px;\n    }\n`;\nvar empty = {};\nvar noopValidator = () => ({\n  errorMessages: []\n});\nvar UNSUPPORTED_TYPE_MSG = (0, i18n_exports._)(\n  \"This input does not support the received value type\"\n);\nvar withInputWrapper = (InputComponent) => {\n  const useValueTypeCheck = typeof InputComponent.canHandleValue === \"function\" ? InputComponent.canHandleValue : () => true;\n  const WrappedComponent = (_a) => {\n    var _b = _a, {\n      mode = \"view\",\n      title,\n      id,\n      attributes,\n      listeners,\n      options = empty,\n      isSelected = false,\n      width = SHORT_WIDTH_DRAGGABLE,\n      onRemove = dashboard_utils_exports.noop,\n      dataSources = empty,\n      isOnCanvas = false,\n      canBeHidden = false,\n      value,\n      containerOptions = empty\n    } = _b, rest = __objRest(_b, [\n      \"mode\",\n      \"title\",\n      \"id\",\n      \"attributes\",\n      \"listeners\",\n      \"options\",\n      \"isSelected\",\n      \"width\",\n      \"onRemove\",\n      \"dataSources\",\n      \"isOnCanvas\",\n      \"canBeHidden\",\n      \"value\",\n      \"containerOptions\"\n    ]);\n    var _a2, _b2;\n    const [currentWidth, setCurrentWidth] = (0, react_exports.useState)(width);\n    const { enableDragDropInputs } = (0, dashboard_context_exports.useFeatureFlags)();\n    const validator = (_a2 = InputComponent.validate) != null ? _a2 : noopValidator;\n    const isFirstRenderRef = (0, react_exports.useRef)(true);\n    const isValueTypeSupported = useValueTypeCheck(\n      value != null ? value : options.defaultValue\n    );\n    const inputValue = isValueTypeSupported ? value : void 0;\n    (0, react_exports.useEffect)(() => {\n      if (!isFirstRenderRef.current) {\n        setCurrentWidth(width);\n      }\n      isFirstRenderRef.current = false;\n    }, [width]);\n    const { validationMessage, warningMessage } = (0, react_exports.useMemo)(() => {\n      var _a3;\n      const messages = {};\n      const { errorMessages } = (_a3 = validator({ options })) != null ? _a3 : {};\n      if (Array.isArray(errorMessages)) {\n        messages.validationMessage = errorMessages.join(\", \");\n      } else {\n        messages.validationMessage = errorMessages;\n      }\n      if (!isValueTypeSupported) {\n        messages.warningMessage = UNSUPPORTED_TYPE_MSG;\n      }\n      return messages;\n    }, [validator, options, isValueTypeSupported]);\n    const handleRemove = (0, react_exports.useCallback)(\n      (e) => {\n        onRemove(id);\n        e.stopPropagation();\n      },\n      [onRemove, id]\n    );\n    const StatusIcon = (0, react_exports.useMemo)(\n      () => /* @__PURE__ */ react_default.createElement(\n        InputStatusIcon,\n        {\n          dataSource: dataSources == null ? void 0 : dataSources.primary,\n          componentId: id,\n          validationMessage,\n          warningMessage\n        }\n      ),\n      [dataSources == null ? void 0 : dataSources.primary, id, validationMessage, warningMessage]\n    );\n    const isDraggable = enableDragDropInputs && mode === \"edit\" && isSelected && !isOnCanvas;\n    const dragHandleEl = (0, react_exports.useMemo)(\n      () => isDraggable && /* @__PURE__ */ react_default.createElement(InputDragHandle, __spreadValues(__spreadValues({}, attributes), listeners)),\n      [attributes, isDraggable, listeners]\n    );\n    const isGlobalEditModeInput = mode === \"edit\" && !isOnCanvas;\n    const showSelection = isSelected && isGlobalEditModeInput;\n    const showBorder = isGlobalEditModeInput && (isSelected || canBeHidden);\n    const showTitle = (_b2 = InputComponent.config) == null ? void 0 : _b2.showTitle;\n    return /* @__PURE__ */ react_default.createElement(\n      InputContainer,\n      {\n        mode,\n        width: currentWidth,\n        showSelection,\n        showBorder,\n        isOnCanvas,\n        canBeHidden\n      },\n      dragHandleEl,\n      /* @__PURE__ */ react_default.createElement(\n        dashboard_ui_exports.InputTitle,\n        {\n          title: showTitle === false ? void 0 : title || \"\",\n          containerOptions,\n          isSelected,\n          StatusIcon,\n          handleRemove: isGlobalEditModeInput ? handleRemove : void 0\n        }\n      ),\n      /* @__PURE__ */ react_default.createElement(\n        InputComponent,\n        __spreadValues({\n          id,\n          isSelected,\n          options,\n          onUpdateWidth: isOnCanvas ? dashboard_utils_exports.noop : setCurrentWidth,\n          dataSources,\n          value: inputValue,\n          title\n        }, rest)\n      )\n    );\n  };\n  WrappedComponent.canHandleValue = InputComponent.canHandleValue;\n  WrappedComponent.valueToTokens = InputComponent.valueToTokens;\n  WrappedComponent.tokensToValue = InputComponent.tokensToValue;\n  WrappedComponent.validate = InputComponent.validate;\n  WrappedComponent.config = InputComponent.config;\n  return WrappedComponent;\n};\n\n// esm-externals:prop-types\nvar prop_types_exports = {};\n__export(prop_types_exports, {\n  default: () => prop_types_default\n});\nvar defaultImport10 = __toESM(require(\"prop-types\"));\n__reExport(prop_types_exports, require(\"prop-types\"));\nvar prop_types_default = \"default\" in defaultImport10 ? defaultImport10.default : defaultImport10;\n\n// esm-externals:@splunk/visualizations-shared/schemaUtils\nvar schemaUtils_exports = {};\n__export(schemaUtils_exports, {\n  default: () => schemaUtils_default\n});\nvar defaultImport11 = __toESM(require(\"@splunk/visualizations-shared/schemaUtils\"));\n__reExport(schemaUtils_exports, require(\"@splunk/visualizations-shared/schemaUtils\"));\nvar schemaUtils_default = \"default\" in defaultImport11 ? defaultImport11.default : defaultImport11;\n\n// src/components/BaseInput.jsx\nvar BaseInput = () => null;\nBaseInput.propTypes = {\n  // input id\n  id: prop_types_default.string,\n  // input title\n  title: prop_types_default.string,\n  // dynamic options context\n  context: prop_types_default.object,\n  // input format options\n  options: prop_types_default.object,\n  // current value, separate by comma input supports multiple value, for example 'foo,bar'\n  value: prop_types_default.string,\n  // datasource state which include data and request params, object key indicate the datasource type.\n  dataSources: prop_types_default.objectOf(\n    prop_types_default.shape({\n      /**\n       * current request params\n       */\n      requestParams: prop_types_default.object,\n      /**\n       * current dataset\n       */\n      data: prop_types_default.shape({\n        fields: prop_types_default.array,\n        columns: prop_types_default.array\n      }),\n      /**\n       * error\n       */\n      error: prop_types_default.shape({\n        level: prop_types_default.string,\n        message: prop_types_default.string\n      }),\n      /**\n       * meta data that came with the dataset\n       */\n      meta: prop_types_default.object\n    })\n  ),\n  /**\n   * DEPRECATED: Description the fields and properties of the datasource used when retrieving data\n   */\n  encoding: prop_types_default.object,\n  /**\n   * A callback to trigger event\n   */\n  onValueChange: prop_types_default.func,\n  /**\n   * Indicates whether the input is disabled\n   */\n  isDisabled: prop_types_default.bool,\n  /**\n   * Message to show in disabled state\n   */\n  disabledMessage: prop_types_default.string,\n  /**\n   * Indicates whether there is errors in the input\n   */\n  isError: prop_types_default.bool,\n  /**\n   * Message to show in error state\n   */\n  errorMessage: prop_types_default.string,\n  /**\n   * Indicates whether the input is selected\n   */\n  isSelected: prop_types_default.bool,\n  /**\n   * input container width in pixel\n   */\n  width: prop_types_default.number,\n  /**\n   * indicates whether datasource is still fetching data and hasn't had errors\n   */\n  loading: prop_types_default.bool,\n  /**\n   * dashboard mode - edit/view\n   */\n  mode: prop_types_default.string,\n  /**\n   * Dynamically update the width of the HOC\n   */\n  onUpdateWidth: prop_types_default.func,\n  /**\n   * A callback to trigger input removal from definition\n   */\n  onRemove: prop_types_default.func,\n  /**\n   * DEPRECATED: indicates whether the input should skip using encoding. This is useful when the input options contains dynamic options\n   */\n  skipEncoding: prop_types_default.bool\n};\nBaseInput.config = {\n  /**\n   * default data contract\n   */\n  dataContract: {\n    requiredDataSources: [\"primary\"],\n    initialRequestParams: {\n      primary: { offset: 0, count: 100 }\n    }\n  }\n};\nBaseInput.defaultProps = {\n  context: {},\n  options: {},\n  onValueChange: dashboard_utils_exports.noop,\n  isDisabled: false,\n  isError: false,\n  isSelected: false,\n  width: 180,\n  onUpdateWidth: dashboard_utils_exports.noop,\n  onRemove: dashboard_utils_exports.noop,\n  skipEncoding: false\n};\nvar baseInputSchema = {\n  token: {\n    description: \"Name of the token that will store the value\",\n    type: \"string\"\n  },\n  tokenNamespace: {\n    description: \"Scope in which the token exists\",\n    type: \"string\",\n    default: \"default\"\n  },\n  backgroundColor: {\n    description: \"The background color of the input field if it is on the canvas\",\n    type: \"string\",\n    default: \"transparent\",\n    pattern: schemaUtils_exports.COLOR_OR_TOKEN_PATTERN_WITH_RGBA\n  }\n};\nBaseInput.canHandleValue = () => true;\nBaseInput.valueToTokens = () => ({});\nvar BaseInput_default = BaseInput;\n\n// src/Text/TextSchema.ts\nvar TextSchema_default = __spreadProps(__spreadValues({}, baseInputSchema), {\n  placeholder: {\n    description: \"Placeholder text displayed when input is empty\",\n    type: \"string\"\n  },\n  prefix: {\n    description: \"Text that will be prepended to the text input value\",\n    type: \"string\"\n  },\n  suffix: {\n    description: \"Text that will be concatenated to the text input value\",\n    type: \"string\"\n  },\n  defaultValue: {\n    description: \"Default value of the input when no value is specified\",\n    type: \"string\"\n  }\n});\n\n// src/Text/Text.tsx\nvar TextInputIcon = (props) => /* @__PURE__ */ react_default.createElement(dashboard_icons_exports.Text, __spreadValues({ screenReaderText: (0, i18n_exports._)(\"Text Input\") }, props));\nvar defaultOptions = {};\nvar Text = ({\n  id,\n  options: { placeholder: customPlaceholder, defaultValue } = defaultOptions,\n  value: committedValue,\n  onValueChange = dashboard_utils_exports.noop,\n  isDisabled = false,\n  disabledMessage,\n  errorMessage,\n  isError = false,\n  isSelected = false,\n  title\n}) => {\n  const inputRef = (0, react_exports.useRef)(null);\n  const value = (committedValue == null ? void 0 : committedValue.toString()) || \"\";\n  const placeholder = errorMessage || disabledMessage || customPlaceholder || \"\";\n  const uniqKey = (0, react_exports.useMemo)(() => ({ id }), [id]);\n  const handleCommit = (0, react_exports.useCallback)(\n    (val) => onValueChange(null, val),\n    [onValueChange]\n  );\n  const {\n    onHandleBlur,\n    onHandleChange,\n    onHandleKeyDown,\n    value: inputValue\n  } = (0, dashboard_ui_exports.useTextInput)({\n    initialValue: value,\n    handleCommit,\n    uniqKey,\n    defaultValue,\n    controlledValue: value\n  });\n  (0, react_exports.useEffect)(() => {\n    if (isSelected && !isDisabled && !!inputRef.current) {\n      inputRef.current.focus({ preventScroll: true });\n    }\n  }, [isSelected, isDisabled]);\n  return /* @__PURE__ */ react_default.createElement(\n    Text_default,\n    {\n      canClear: true,\n      inputId: id,\n      placeholder,\n      disabled: isDisabled,\n      error: isError,\n      value: inputValue,\n      onChange: onHandleChange,\n      onKeyDown: onHandleKeyDown,\n      onBlur: onHandleBlur,\n      inputRef,\n      \"aria-label\": title\n    }\n  );\n};\nText.canHandleValue = dashboard_utils_exports.isPrimitive;\nText.valueToTokens = (value, { token, prefix = \"\", suffix = \"\" }) => {\n  if (!token) {\n    return {};\n  }\n  if (!value) {\n    return {\n      [token]: null\n    };\n  }\n  return {\n    [token]: `${prefix}${value}${suffix}`\n  };\n};\nvar editor = [\n  {\n    label: (0, i18n_exports._)(\"Token\"),\n    enableCollapsible: true,\n    enableSeparator: true,\n    layout: [\n      [\n        {\n          label: (0, i18n_exports._)(\"Token name\"),\n          option: \"token\",\n          editor: \"editor.text\"\n        }\n      ]\n    ]\n  },\n  {\n    label: (0, i18n_exports._)(\"Value\"),\n    enableCollapsible: true,\n    enableSeparator: true,\n    layout: [\n      [\n        {\n          label: (0, i18n_exports._)(\"Default value\"),\n          option: \"defaultValue\",\n          editor: \"editor.text\"\n        }\n      ]\n    ]\n  }\n];\nText.config = {\n  editorConfig: editor,\n  optionsSchema: TextSchema_default,\n  label: (0, i18n_exports._)(\"Text\"),\n  description: (0, i18n_exports._)(\"Field to enter text\"),\n  baseShape: {\n    options: {\n      defaultValue: (0, i18n_exports._)(\"Default Text\")\n    },\n    title: \"Text Input Title\"\n  },\n  tokenPrefix: \"text\",\n  icon: TextInputIcon\n};\nvar Text_default2 = withInputWrapper(Text);\n\n// esm-externals:lodash\nvar lodash_exports = {};\n__export(lodash_exports, {\n  default: () => lodash_default\n});\nvar defaultImport12 = __toESM(require(\"lodash\"));\n__reExport(lodash_exports, require(\"lodash\"));\nvar lodash_default = \"default\" in defaultImport12 ? defaultImport12.default : defaultImport12;\n\n// esm-externals:@splunk/react-ui/Multiselect\nvar Multiselect_exports = {};\n__export(Multiselect_exports, {\n  default: () => Multiselect_default\n});\nvar defaultImport13 = __toESM(require(\"@splunk/react-ui/Multiselect\"));\n__reExport(Multiselect_exports, require(\"@splunk/react-ui/Multiselect\"));\nvar Multiselect_default = \"default\" in defaultImport13 ? defaultImport13.default : defaultImport13;\n\n// esm-externals:@splunk/visualization-encoding-parsers/Base\nvar Base_exports = {};\n__export(Base_exports, {\n  default: () => Base_default\n});\nvar defaultImport14 = __toESM(require(\"@splunk/visualization-encoding-parsers/Base\"));\n__reExport(Base_exports, require(\"@splunk/visualization-encoding-parsers/Base\"));\nvar Base_default = \"default\" in defaultImport14 ? defaultImport14.default : defaultImport14;\n\n// esm-externals:@splunk/visualization-encoding/Options\nvar Options_exports = {};\n__export(Options_exports, {\n  default: () => Options_default\n});\nvar defaultImport15 = __toESM(require(\"@splunk/visualization-encoding/Options\"));\n__reExport(Options_exports, require(\"@splunk/visualization-encoding/Options\"));\nvar Options_default = \"default\" in defaultImport15 ? defaultImport15.default : defaultImport15;\n\n// src/utils/inputItem.js\nvar dataContract = {\n  requiredDataSources: [\"primary\"],\n  initialRequestParams: {\n    primary: { offset: 0, count: 1e3, progress: false }\n  },\n  encoding: {\n    value: {\n      isRequired: true,\n      type: [\"number\", \"string\"],\n      default: \"primary[0]\"\n    },\n    label: {\n      type: [\"number\", \"string\"],\n      default: \"primary[1]\"\n    }\n  }\n};\nvar parseEncoding = (dataSources, userDefinedEncoding) => {\n  return (0, Base_exports.parse)(\n    dataSources,\n    (0, Base_exports.mergeEncoding)(dataContract.encoding, userDefinedEncoding)\n  );\n};\nvar dataToItems = ({ label, value }) => {\n  if (!Array.isArray(value) || value.length === 0) {\n    return [];\n  }\n  if (Array.isArray(label)) {\n    return value.map((val, idx) => ({ label: label[idx], value: val }));\n  }\n  return value.map((val) => ({ label: val, value: val }));\n};\nvar hasNoData = (dataSources) => Object.values(dataSources).every(({ data }) => (0, lodash_exports.isEmpty)(data));\nvar getDynamicItems = (dataSources, encoding) => {\n  if ((0, lodash_exports.isEmpty)(dataSources) || hasNoData(dataSources)) {\n    return [];\n  }\n  const dataProps = parseEncoding(dataSources, encoding);\n  return dataToItems(dataProps);\n};\nvar formatItems = (items) => {\n  return items.map(({ label, value }) => ({\n    label: label || value,\n    value\n  }));\n};\nvar getFirstSearchResult = ({ staticItems, dynamicItems = [] }) => {\n  const formattedItems = formatItems([...dynamicItems, ...staticItems]);\n  return formattedItems.length > 0 ? formattedItems[0].value : null;\n};\nvar mergeItems = ({\n  defaultValues = [],\n  staticItems,\n  dynamicItems = []\n}) => {\n  const formattedDefaultValues = defaultValues.map((value) => ({\n    label: value,\n    value\n  }));\n  const formattedItems = formatItems([...staticItems, ...dynamicItems]);\n  const dedupedItems = (0, lodash_exports.uniqBy)(formattedItems, ({ value }) => {\n    return value;\n  });\n  const defaultValuesNotInItems = (0, lodash_exports.differenceBy)(\n    formattedDefaultValues,\n    dedupedItems,\n    \"value\"\n  );\n  return [...defaultValuesNotInItems, ...dedupedItems];\n};\nvar noItems = [];\nvar hasDynamicOptions = (arr) => {\n  if (!Array.isArray(arr)) {\n    throw new TypeError(\"hasDynamicOptions should receive an array\");\n  }\n  return arr.some((v) => typeof v === \"string\" && v.trim().startsWith(\">\"));\n};\nvar defaultEncoding = {\n  label: \"primary[0]\",\n  value: \"primary[0]\"\n};\nvar fetchDynamicContent = ({\n  context,\n  items,\n  dataSources,\n  encoding\n}) => {\n  const hasEncoding = !(0, lodash_exports.isEmpty)(encoding);\n  if (hasEncoding) {\n    (0, dashboard_utils_exports.deprecated)(\n      \"Encoding is deprecated, please use Dynamic Options instead.\"\n    );\n  }\n  if ((0, lodash_exports.isEmpty)(dataSources)) {\n    return noItems;\n  }\n  if (hasDynamicOptions([items])) {\n    const { items: resolvedItems } = Options_exports.Options.evaluate(\n      {\n        context,\n        options: { items }\n      },\n      dataSources\n    );\n    return resolvedItems;\n  }\n  if (hasEncoding) {\n    return getDynamicItems(dataSources, encoding);\n  }\n  return getDynamicItems(dataSources, defaultEncoding);\n};\nvar getSearchStatus = (dataSources) => {\n  var _a, _b, _c, _d;\n  return ((_b = (_a = dataSources.primary) == null ? void 0 : _a.meta) == null ? void 0 : _b.status) === \"done\" && ((_d = (_c = dataSources.primary) == null ? void 0 : _c.meta) == null ? void 0 : _d.totalCount) === 0;\n};\n\n// src/Multiselect/MultiselectSchema.js\nvar commonProperties = __spreadProps(__spreadValues({}, baseInputSchema), {\n  items: {\n    description: \"Specify the label text that appears below the value.\",\n    anyOf: [\n      {\n        type: \"array\",\n        items: {\n          type: \"object\",\n          properties: {\n            label: {\n              description: \"The text displayed in the dropdown menu\",\n              type: \"string\",\n              minLength: 1,\n              pattern: \".*\\\\S.*\"\n            },\n            value: {\n              description: \"The value used when the menu item is selected\",\n              type: \"string\",\n              minLength: 1,\n              pattern: \".*\\\\S.*\"\n            }\n          },\n          required: [\"value\"]\n        }\n      },\n      {\n        type: \"string\",\n        pattern: \"^>.*\"\n      }\n    ]\n  },\n  clearDefaultOnSelection: {\n    description: \"Clear the default value when selecting another value.\",\n    type: \"boolean\",\n    default: true\n  }\n});\nvar MultiselectSchema_default = {\n  // extend means we are defining not just the properties, but the entire option schema itself\n  extend: {\n    type: \"object\",\n    anyOf: [\n      {\n        properties: __spreadValues({\n          selectFirstSearchResult: {\n            description: \"Select the first result of an attached search as default.\",\n            type: \"boolean\",\n            default: false,\n            const: false\n          },\n          defaultValue: {\n            description: \"Default value of the input when no value is specified\",\n            anyOf: [\n              { type: \"string\" },\n              { type: \"array\", items: { type: \"string\" } }\n            ]\n          }\n        }, commonProperties),\n        additionalProperties: false\n      },\n      {\n        properties: __spreadValues({\n          selectFirstSearchResult: {\n            description: \"Select the first result of an attached search as default.\",\n            type: \"boolean\",\n            default: false,\n            const: true\n          },\n          // setting a property to false means it is disallowed\n          defaultValue: false\n        }, commonProperties),\n        additionalProperties: false\n      }\n    ]\n  }\n};\n\n// esm-externals:@splunk/react-ui/RadioBar\nvar RadioBar_exports = {};\n__export(RadioBar_exports, {\n  default: () => RadioBar_default\n});\nvar defaultImport16 = __toESM(require(\"@splunk/react-ui/RadioBar\"));\n__reExport(RadioBar_exports, require(\"@splunk/react-ui/RadioBar\"));\nvar RadioBar_default = \"default\" in defaultImport16 ? defaultImport16.default : defaultImport16;\n\n// src/components/MultiselectDefaultValueEditor.tsx\nvar MultiselectDefaultValueEditor = ({\n  value,\n  options,\n  placeholder,\n  onChange\n}) => {\n  const handleChange = (0, react_exports.useCallback)(\n    (evt, { values }) => {\n      onChange(evt, values);\n    },\n    [onChange]\n  );\n  const uniqueValues = (0, react_exports.useMemo)(() => {\n    if (!value) {\n      return [];\n    }\n    return Array.from(\n      new Set(Array.isArray(value) ? value : value.split(\",\"))\n    );\n  }, [value]);\n  const multiselectOptions = (0, react_exports.useMemo)(\n    () => options.map(({ value: v }) => /* @__PURE__ */ react_default.createElement(Multiselect_default.Option, { key: v, label: v, value: v })),\n    [options]\n  );\n  return /* @__PURE__ */ react_default.createElement(\n    Multiselect_default,\n    {\n      values: uniqueValues,\n      onChange: handleChange,\n      placeholder,\n      allowNewValues: true\n    },\n    multiselectOptions\n  );\n};\nvar MultiselectDefaultValueEditor_default = MultiselectDefaultValueEditor;\n\n// src/components/DefaultSelectedValueEditor.tsx\nvar DEFAULT_VALUE_TYPE_DESCRIPTION = {\n  defined: (0, i18n_exports._)(\"Assigns the user defined values as the default\"),\n  first: (0, i18n_exports._)(\n    \"Assigns the first value returned from the data source as the default\"\n  ),\n  none: (0, i18n_exports._)(\"No value will be assigned as the default\")\n};\nvar DefaultSelectedValueEditor = ({\n  options,\n  context,\n  onChange,\n  value: defaultValue,\n  isMultiselect\n}) => {\n  let valueType = \"none\";\n  if (options.selectFirstSearchResult) {\n    valueType = \"first\";\n  } else if (defaultValue !== void 0) {\n    valueType = \"defined\";\n  }\n  const staticItems = (0, react_exports.useMemo)(() => {\n    if (Array.isArray(options.items)) {\n      return options.items;\n    }\n    const { statics = [[], []] } = context;\n    return (0, lodash_exports.zipWith)(...statics, (_l, v) => ({\n      value: v\n    }));\n  }, [options, context]);\n  const handleValueTypeChange = (0, react_exports.useCallback)(\n    (event, { value: type }) => {\n      const newDefaultValue = type === \"defined\" ? \"\" : void 0;\n      const newSelectFirstSearchResult = type === \"first\" ? true : void 0;\n      onChange(event, {\n        options: {\n          defaultValue: newDefaultValue,\n          selectFirstSearchResult: newSelectFirstSearchResult\n        }\n      });\n    },\n    [onChange]\n  );\n  const handleDefaultValueChange = (0, react_exports.useCallback)(\n    (event, updatedValue) => {\n      onChange(event, {\n        options: {\n          defaultValue: updatedValue\n        }\n      });\n    },\n    [onChange]\n  );\n  const selectedValueInput = (0, react_exports.useMemo)(() => {\n    if (valueType !== \"defined\") {\n      return null;\n    }\n    const DefaultValueEditor = isMultiselect ? MultiselectDefaultValueEditor_default : dashboard_ui_exports.ComboBoxEditor;\n    return /* @__PURE__ */ react_default.createElement(\n      dashboard_ui_exports.ControlGroup,\n      {\n        label: (0, i18n_exports._)(\"Choose a Default Value\"),\n        labelPosition: \"top\",\n        hideLabel: true,\n        controlsLayout: \"none\"\n      },\n      /* @__PURE__ */ react_default.createElement(\n        DefaultValueEditor,\n        {\n          value: defaultValue,\n          onChange: handleDefaultValueChange,\n          options: staticItems,\n          placeholder: (0, i18n_exports._)(\"Choose or type a default value...\")\n        }\n      )\n    );\n  }, [\n    isMultiselect,\n    valueType,\n    defaultValue,\n    handleDefaultValueChange,\n    staticItems\n  ]);\n  return /* @__PURE__ */ react_default.createElement(react_default.Fragment, null, /* @__PURE__ */ react_default.createElement(\n    dashboard_ui_exports.ControlGroup,\n    {\n      label: (0, i18n_exports._)(\"Default selected value\"),\n      labelPosition: \"top\",\n      hideLabel: true,\n      help: DEFAULT_VALUE_TYPE_DESCRIPTION[valueType]\n    },\n    /* @__PURE__ */ react_default.createElement(\n      RadioBar_default,\n      {\n        \"data-test\": \"default-selected-value-type\",\n        onChange: handleValueTypeChange,\n        value: valueType\n      },\n      /* @__PURE__ */ react_default.createElement(\n        RadioBar_default.Option,\n        {\n          label: (0, i18n_exports._)(\"Choose default\"),\n          value: \"defined\"\n        }\n      ),\n      /* @__PURE__ */ react_default.createElement(RadioBar_default.Option, { label: (0, i18n_exports._)(\"First value\"), value: \"first\" }),\n      /* @__PURE__ */ react_default.createElement(RadioBar_default.Option, { label: (0, i18n_exports._)(\"None\"), value: \"none\" })\n    )\n  ), selectedValueInput);\n};\nvar DefaultSelectedValueEditor_default = DefaultSelectedValueEditor;\n\n// src/utils/validate.ts\nvar validateTokenName = ({\n  value\n}) => {\n  const error = (0, dashboard_utils_exports.getTokenNameError)(value);\n  return error ? { message: error } : null;\n};\n\n// src/components/DropdownEditorConfig.ts\nvar DynamicItemEditorConfig = {\n  label: (0, i18n_exports._)(\"Dynamic menu configuration\"),\n  option: \"items\",\n  context: \"statics\",\n  editor: \"editor.dynamicItem\",\n  showEditor: ({ options }) => Array.isArray(options.items) || typeof options.items === \"string\" && /^>/.test(options.items),\n  editorProps: {\n    help: (0, i18n_exports._)(\n      \"Advanced configuration options are being used by this input. Please edit in source mode.\"\n    ),\n    // return value of null means no error. This is to avoid Dynamic Editors's \"default\" validation\n    //  which does not allow the use of tokens $token$.\n    validate: () => null\n  }\n};\nvar BaseEditor = [\n  {\n    label: (0, i18n_exports._)(\"Token\"),\n    enableCollapsible: true,\n    enableSeparator: true,\n    layout: [\n      [\n        {\n          label: (0, i18n_exports._)(\"Token name\"),\n          option: \"token\",\n          editor: \"editor.text\",\n          editorProps: {\n            validate: validateTokenName\n          }\n        }\n      ]\n    ]\n  },\n  {\n    label: (0, i18n_exports._)(\"Menu configuration\"),\n    enableCollapsible: true,\n    enableSeparator: true,\n    layout: [[DynamicItemEditorConfig]]\n  }\n];\nvar DropdownEditorConfig_default = [\n  ...BaseEditor,\n  {\n    label: (0, i18n_exports._)(\"Default selected values\"),\n    enableCollapsible: true,\n    enableSeparator: true,\n    layout: [\n      [\n        {\n          label: (0, i18n_exports._)(\"Default value\"),\n          option: \"defaultValue\",\n          context: \"statics\",\n          editor: DefaultSelectedValueEditor_default,\n          editorProps: { isMultiselect: false }\n        }\n      ]\n    ]\n  }\n];\n\n// src/components/MultiselectEditorConfig.ts\nvar MultiselectEditorConfig_default = [\n  ...BaseEditor,\n  {\n    label: (0, i18n_exports._)(\"Default selected values\"),\n    enableSeparator: false,\n    layout: [\n      [\n        {\n          label: (0, i18n_exports._)(\"Default value\"),\n          option: \"defaultValue\",\n          context: \"statics\",\n          editor: DefaultSelectedValueEditor_default,\n          editorProps: { isMultiselect: true }\n        }\n      ]\n    ]\n  }\n];\n\n// src/Multiselect/Multiselect.tsx\nvar alphabeticSort = (a, b) => String.prototype.localeCompare.call(a, String(b));\nvar noItems2 = [];\nvar noMenuItems = [];\nvar canHandleValue = (value) => (0, dashboard_utils_exports.isPrimitive)(value) || (0, dashboard_utils_exports.isPrimitiveArray)(value);\nvar parseValue = (value) => {\n  if (value) {\n    return Array.isArray(value) ? value.map(String) : String(value).split(\",\");\n  }\n  return noItems2;\n};\nvar Multiselect = ({\n  value,\n  context = {},\n  options: {\n    items = [],\n    defaultValue,\n    clearDefaultOnSelection = true,\n    selectFirstSearchResult = false\n  } = {},\n  dataSources = {},\n  encoding,\n  onValueChange,\n  loading: isLoading,\n  isError,\n  errorMessage,\n  isDisabled: initialDisabledStatus,\n  disabledMessage: initialDisabledMessaged,\n  title\n}) => {\n  const searchHasNoResults = getSearchStatus(dataSources);\n  const defaultValueArray = (0, react_exports.useMemo)(\n    () => defaultValue ? parseValue(defaultValue) : noItems2,\n    [defaultValue]\n  );\n  const isDisabled = initialDisabledStatus || searchHasNoResults && defaultValue == null;\n  const disabledMessage = isDisabled && (initialDisabledMessaged || (0, i18n_exports._)(\"No search results\"));\n  const { menuItems, firstSearchResult } = (0, react_exports.useMemo)(() => {\n    if (isError || isLoading || isDisabled) {\n      return {\n        menuItems: noMenuItems,\n        firstSearchResult: noItems2\n      };\n    }\n    const hasDynamicItems = hasDynamicOptions([items]);\n    const dynamicItems = fetchDynamicContent({\n      context,\n      items,\n      dataSources,\n      encoding\n    });\n    const firstResult = selectFirstSearchResult && dynamicItems.length > 0 ? [dynamicItems[0].value] : noItems2;\n    const staticItems = hasDynamicItems ? noItems2 : items;\n    const mergedItems = mergeItems({\n      dynamicItems,\n      staticItems,\n      defaultValues: defaultValueArray\n    });\n    const validItems = mergedItems.filter((item) => !!item.value);\n    return { menuItems: validItems, firstSearchResult: firstResult };\n  }, [\n    isError,\n    isLoading,\n    isDisabled,\n    items,\n    defaultValueArray,\n    context,\n    dataSources,\n    encoding,\n    selectFirstSearchResult\n  ]);\n  (0, react_exports.useEffect)(() => {\n    if (!value && firstSearchResult.length > 0) {\n      onValueChange(null, firstSearchResult);\n    }\n  }, [firstSearchResult, onValueChange, value]);\n  const selectedValues = (0, react_exports.useMemo)(() => {\n    if (isDisabled || isError || isLoading) {\n      return noItems2;\n    }\n    if (!!value && canHandleValue(value)) {\n      return parseValue(value);\n    }\n    return selectFirstSearchResult ? firstSearchResult : noItems2;\n  }, [\n    isDisabled,\n    isError,\n    isLoading,\n    value,\n    selectFirstSearchResult,\n    firstSearchResult\n  ]);\n  const multiselectOptions = (0, react_exports.useMemo)(() => {\n    return menuItems.map(({ label, value: val }) => /* @__PURE__ */ react_default.createElement(Multiselect_default.Option, { label, value: val, key: val }));\n  }, [menuItems]);\n  const placeholder = (0, react_exports.useMemo)(() => {\n    return (0, i18n_exports._)(errorMessage || disabledMessage || \"Select a value\");\n  }, [disabledMessage, errorMessage]);\n  const loadingMessage2 = (0, i18n_exports._)(\"Loading menu items...\");\n  const handleValueChange = (0, react_exports.useCallback)(\n    (evt, { values }) => {\n      if (values.length === 0 && selectFirstSearchResult) {\n        onValueChange(evt, firstSearchResult);\n        return;\n      }\n      const isSelectAllClicked = (0, lodash_exports.isEqual)(\n        [...values].sort(alphabeticSort),\n        menuItems.map((item) => item.value).sort(alphabeticSort)\n      );\n      const hasDefaultValue = defaultValueArray.length > 0;\n      const isNonDefaultValueSelected = (0, lodash_exports.difference)(values, defaultValueArray).length > 0;\n      const wasOnlyDefaultValueSelected = (0, lodash_exports.isEqual)(\n        [...selectedValues].sort(alphabeticSort),\n        [...defaultValueArray].sort(alphabeticSort)\n      );\n      const shouldClearDefaultValue = clearDefaultOnSelection && hasDefaultValue && isNonDefaultValueSelected && wasOnlyDefaultValueSelected && !isSelectAllClicked;\n      const newValues = shouldClearDefaultValue ? (0, lodash_exports.without)(values, ...defaultValueArray) : values;\n      onValueChange(evt, newValues);\n    },\n    [\n      selectFirstSearchResult,\n      menuItems,\n      defaultValueArray,\n      selectedValues,\n      clearDefaultOnSelection,\n      onValueChange,\n      firstSearchResult\n    ]\n  );\n  return /* @__PURE__ */ react_default.createElement(\n    Multiselect_default,\n    {\n      values: selectedValues,\n      onChange: handleValueChange,\n      placeholder,\n      disabled: isDisabled || isError,\n      isLoadingOptions: isLoading,\n      loadingMessage: loadingMessage2,\n      compact: true,\n      defaultPlacement: \"below\",\n      \"aria-label\": title\n    },\n    multiselectOptions\n  );\n};\nMultiselect.canHandleValue = canHandleValue;\nMultiselect.valueToTokens = (value, { token }) => {\n  if (!token) {\n    return {};\n  }\n  if (!value) {\n    return {\n      [token]: null\n    };\n  }\n  return {\n    [token]: value\n  };\n};\nMultiselect.propTypes = __spreadProps(__spreadValues({}, BaseInput_default.propTypes), {\n  value: prop_types_default.oneOfType([prop_types_default.string, prop_types_default.arrayOf(prop_types_default.string)])\n});\nMultiselect.defaultProps = __spreadValues({}, BaseInput_default.defaultProps);\nvar meta = {\n  label: (0, i18n_exports._)(\"Multiselect\"),\n  description: (0, i18n_exports._)(\"Select multiple list values\"),\n  defaultConfig: {\n    options: {\n      items: [\n        { label: (0, i18n_exports._)(\"All\"), value: \"*\" },\n        { label: (0, i18n_exports._)(\"Item 1\"), value: \"item001\" },\n        { label: (0, i18n_exports._)(\"Item 2\"), value: \"item002\" },\n        { label: (0, i18n_exports._)(\"Item 3\"), value: \"item003\" }\n      ],\n      defaultValue: [\"item001\", \"item002\"]\n    },\n    title: (0, i18n_exports._)(\"Multiselect Input Title\")\n  },\n  tokenPrefix: \"ms\",\n  icon: dashboard_icons_exports.MultiselectInput\n};\nMultiselect.config = __spreadValues({\n  optionsSchema: MultiselectSchema_default,\n  editorConfig: MultiselectEditorConfig_default,\n  dataContract\n}, (0, lodash_exports.mapKeys)(\n  meta,\n  (_value, key) => key === \"defaultConfig\" ? \"baseShape\" : key\n));\nvar Multiselect_default2 = withInputWrapper(\n  Multiselect\n);\n\n// esm-externals:@splunk/react-ui/Select\nvar Select_exports = {};\n__export(Select_exports, {\n  default: () => Select_default\n});\nvar defaultImport17 = __toESM(require(\"@splunk/react-ui/Select\"));\n__reExport(Select_exports, require(\"@splunk/react-ui/Select\"));\nvar Select_default = \"default\" in defaultImport17 ? defaultImport17.default : defaultImport17;\n\n// esm-externals:@splunk/ui-utils/filter\nvar filter_exports = {};\n__export(filter_exports, {\n  default: () => filter_default\n});\nvar defaultImport18 = __toESM(require(\"@splunk/ui-utils/filter\"));\n__reExport(filter_exports, require(\"@splunk/ui-utils/filter\"));\nvar filter_default = \"default\" in defaultImport18 ? defaultImport18.default : defaultImport18;\n\n// src/Select/SelectSchema.js\nvar commonProperties2 = __spreadProps(__spreadValues({}, baseInputSchema), {\n  items: {\n    description: \"Specify the label text that appears below the value.\",\n    anyOf: [\n      {\n        type: \"array\",\n        items: {\n          type: \"object\",\n          properties: {\n            label: {\n              description: \"The text displayed in the dropdown menu\",\n              type: \"string\",\n              minLength: 1,\n              pattern: \".*\\\\S.*\"\n            },\n            value: {\n              description: \"The value used when the menu item is selected\",\n              type: \"string\",\n              minLength: 1,\n              pattern: \".*\\\\S.*\"\n            }\n          },\n          required: [\"value\"]\n        }\n      },\n      {\n        type: \"string\",\n        pattern: \"^>.*\"\n      }\n    ]\n  },\n  prefix: {\n    description: \"Text that will be prepended to the selected value\",\n    type: \"string\"\n  },\n  suffix: {\n    description: \"Text that will be concatenated to the selected value\",\n    type: \"string\"\n  }\n});\nvar SelectSchema_default = {\n  // extend means we are defining not just the properties, but the entire option schema itself\n  extend: {\n    type: \"object\",\n    anyOf: [\n      {\n        properties: __spreadValues({\n          selectFirstSearchResult: {\n            description: \"Select the first result of an attached search as default.\",\n            type: \"boolean\",\n            default: false,\n            const: false\n          },\n          defaultValue: {\n            description: \"Default value of the input when no value is specified\",\n            type: \"string\"\n          }\n        }, commonProperties2),\n        additionalProperties: false\n      },\n      {\n        properties: __spreadValues({\n          selectFirstSearchResult: {\n            description: \"Select the first result of an attached search as default.\",\n            type: \"boolean\",\n            default: false,\n            const: true\n          },\n          // setting a property to false means it is disallowed\n          defaultValue: false\n        }, commonProperties2),\n        additionalProperties: false\n      }\n    ]\n  }\n};\n\n// src/Select/Select.jsx\nvar selectStyle = {\n  width: \"100%\"\n};\nvar loadingMessage = (0, i18n_exports._)(\"Loading menu items...\");\nvar noItems3 = [];\nvar Select = ({\n  value,\n  onValueChange,\n  options: { defaultValue, items = noItems3, selectFirstSearchResult = false },\n  dataSources,\n  encoding,\n  context,\n  loading: isLoading,\n  isError,\n  errorMessage,\n  isDisabled: initialDisableStatus,\n  disabledMessage: initialDisabledMessage,\n  title\n}) => {\n  const searchHasNoResults = getSearchStatus(dataSources);\n  const selectFirstWithNoItems = items.length === 0 && selectFirstSearchResult || !selectFirstSearchResult;\n  const isDisabled = initialDisableStatus || defaultValue == null && searchHasNoResults && selectFirstWithNoItems;\n  const disabledMessage = isDisabled && (initialDisabledMessage || (0, i18n_exports._)(\"No results\"));\n  const { allItems, firstSearchResult, selectedItem } = (0, react_exports.useMemo)(() => {\n    if (isError || isLoading || isDisabled) {\n      return { allItems: noItems3, firstSearchResult: null };\n    }\n    const dynamicItems = fetchDynamicContent({\n      context,\n      items,\n      dataSources,\n      encoding\n    });\n    const staticItems = hasDynamicOptions([items]) ? noItems3 : items;\n    const firstResult = selectFirstSearchResult ? getFirstSearchResult({ staticItems, dynamicItems }) : null;\n    const defaultValues = defaultValue != null ? [defaultValue] : noItems3;\n    const mergedItems = mergeItems({\n      dynamicItems,\n      staticItems,\n      defaultValues\n    });\n    const menuOptions = [];\n    let selected = { label: value, value };\n    mergedItems.forEach((item) => {\n      if (!item.value) {\n        return;\n      }\n      if (item.value === value) {\n        selected = item;\n        return;\n      }\n      menuOptions.push(\n        /* @__PURE__ */ react_default.createElement(\n          Select_default.Option,\n          {\n            label: item.label,\n            value: item.value,\n            key: item.value,\n            truncate: true\n          }\n        )\n      );\n    });\n    return {\n      allItems: menuOptions,\n      firstSearchResult: firstResult,\n      selectedItem: selected\n    };\n  }, [\n    isError,\n    isLoading,\n    isDisabled,\n    context,\n    items,\n    dataSources,\n    encoding,\n    selectFirstSearchResult,\n    defaultValue,\n    value\n  ]);\n  const selectedMenuItem = (0, react_exports.useMemo)(() => {\n    if (!(selectedItem == null ? void 0 : selectedItem.value)) {\n      return null;\n    }\n    return /* @__PURE__ */ react_default.createElement(\n      Select_default.Option,\n      {\n        label: selectedItem.label,\n        value: selectedItem.value,\n        key: `selected-${selectedItem.value}`,\n        truncate: true\n      }\n    );\n  }, [selectedItem]);\n  const [currentKeyword, setCurrentKeyword] = (0, react_exports.useState)(\"\");\n  const [resultLength, setResultLength] = (0, react_exports.useState)(50);\n  const [isSimulatingLoad, setIsSimulatingLoad] = (0, react_exports.useState)(false);\n  const currentValue = value || firstSearchResult || \"\";\n  const filterResults = (0, react_exports.useMemo)(() => {\n    if (!currentKeyword) {\n      return [];\n    }\n    const keywords = (0, filter_exports.stringToKeywords)(currentKeyword);\n    return allItems.filter(\n      (option) => option.props.value !== (selectedItem == null ? void 0 : selectedItem.value) && (0, filter_exports.testPhrase)(option.props.label, keywords)\n    ).map((option) => {\n      const matchRanges = keywords && (0, filter_exports.keywordLocations)(option.props.label, keywords);\n      return (0, react_exports.cloneElement)(option, {\n        matchRanges: matchRanges || void 0\n      });\n    });\n  }, [allItems, currentKeyword, selectedItem == null ? void 0 : selectedItem.value]);\n  const maxLength = (0, react_exports.useMemo)(\n    () => currentKeyword ? filterResults.length : allItems.length,\n    [currentKeyword, filterResults, allItems.length]\n  );\n  const handleFilterChange = (0, react_exports.useCallback)((e, { keyword }) => {\n    setCurrentKeyword(keyword);\n    setResultLength(50);\n    setIsSimulatingLoad(true);\n    setTimeout(() => setIsSimulatingLoad(false), 0);\n  }, []);\n  (0, react_exports.useEffect)(() => {\n    if (!value && !!firstSearchResult) {\n      onValueChange(null, firstSearchResult);\n    }\n  }, [firstSearchResult, onValueChange, value]);\n  const handleClick = (0, react_exports.useCallback)(\n    (evt, { value: itemValue }) => {\n      onValueChange(evt, itemValue);\n    },\n    [onValueChange]\n  );\n  const handleScrollBottom = (0, react_exports.useCallback)(() => {\n    setResultLength((currResultLen) => currResultLen + 50);\n  }, []);\n  const handleClose = (0, react_exports.useCallback)(() => {\n    setResultLength(50);\n  }, []);\n  const placeholder = (0, react_exports.useMemo)(() => {\n    return (0, i18n_exports._)(errorMessage || disabledMessage || \"Select a value\");\n  }, [errorMessage, disabledMessage]);\n  const menuItems = (0, react_exports.useMemo)(() => {\n    if (isSimulatingLoad) {\n      return [];\n    }\n    return currentKeyword ? filterResults.slice(0, resultLength) : allItems.slice(0, resultLength);\n  }, [\n    allItems,\n    currentKeyword,\n    filterResults,\n    isSimulatingLoad,\n    resultLength\n  ]);\n  return /* @__PURE__ */ react_default.createElement(\n    Select_default,\n    {\n      value: currentValue,\n      onChange: handleClick,\n      disabled: isDisabled || isError,\n      defaultPlacement: \"below\",\n      isLoadingOptions: isLoading || isSimulatingLoad,\n      loadingMessage,\n      placeholder,\n      filter: isLoading ? false : \"controlled\",\n      inline: true,\n      style: selectStyle,\n      onScrollBottom: menuItems.length < maxLength ? handleScrollBottom : null,\n      onFilterChange: handleFilterChange,\n      onClose: handleClose,\n      labelText: title\n    },\n    selectedMenuItem,\n    selectedMenuItem && /* @__PURE__ */ react_default.createElement(Select_default.Divider, null),\n    menuItems\n  );\n};\nSelect.propTypes = __spreadValues({}, BaseInput_default.propTypes);\nSelect.defaultProps = __spreadValues({}, BaseInput_default.defaultProps);\nvar meta2 = {\n  label: (0, i18n_exports._)(\"Dropdown\"),\n  description: (0, i18n_exports._)(\"Select a single list value\"),\n  defaultConfig: {\n    options: {\n      items: [\n        { label: (0, i18n_exports._)(\"All\"), value: \"*\" },\n        { label: (0, i18n_exports._)(\"Item 1\"), value: \"item001\" },\n        { label: (0, i18n_exports._)(\"Item 2\"), value: \"item002\" }\n      ],\n      defaultValue: \"*\"\n    },\n    title: (0, i18n_exports._)(\"Dropdown Input Title\")\n  },\n  tokenPrefix: \"dd\",\n  icon: dashboard_icons_exports.DropdownInput\n};\nSelect.config = __spreadValues({\n  optionsSchema: SelectSchema_default,\n  editorConfig: DropdownEditorConfig_default,\n  dataContract\n}, (0, lodash_exports.mapKeys)(\n  meta2,\n  (value, key) => key === \"defaultConfig\" ? \"baseShape\" : key\n));\nSelect.canHandleValue = dashboard_utils_exports.isPrimitive;\nSelect.valueToTokens = (value, { token, prefix = \"\", suffix = \"\" }) => {\n  if (!token) {\n    return {};\n  }\n  if (!value) {\n    return {\n      [token]: null\n    };\n  }\n  return {\n    [token]: `${prefix}${value}${suffix}`\n  };\n};\nvar Select_default2 = withInputWrapper(Select);\n\n// esm-externals:@splunk/react-ui/Number\nvar Number_exports = {};\n__export(Number_exports, {\n  default: () => Number_default\n});\nvar defaultImport19 = __toESM(require(\"@splunk/react-ui/Number\"));\n__reExport(Number_exports, require(\"@splunk/react-ui/Number\"));\nvar Number_default = \"default\" in defaultImport19 ? defaultImport19.default : defaultImport19;\n\n// src/Number/NumberSchema.ts\nvar NumberSchema_default = __spreadProps(__spreadValues({}, baseInputSchema), {\n  defaultValue: {\n    description: \"Default value of the input when no value is specified\",\n    anyOf: [{ type: \"number\" }, { pattern: \"^>.*\", type: \"string\" }]\n  },\n  min: {\n    description: \"The smallest allowable value.\",\n    anyOf: [{ type: \"number\" }, { pattern: \"^>.*\", type: \"string\" }]\n  },\n  max: {\n    description: \"The largest allowable value.\",\n    anyOf: [{ type: \"number\" }, { pattern: \"^>.*\", type: \"string\" }]\n  },\n  step: {\n    description: \"The amount of increment and decrement applied by the buttons and arrow keys.\",\n    anyOf: [\n      { type: \"number\", default: 1, exclusiveMinimum: 0 },\n      { pattern: \"^>.*\", type: \"string\" }\n    ]\n  }\n});\n\n// src/Number/Number.tsx\nvar filterNaN = (value) => Number.isNaN(value) ? void 0 : value;\nvar defaultOptions2 = {};\nvar NumberInput = ({\n  id,\n  options: { min, max, step } = defaultOptions2,\n  value,\n  onValueChange = dashboard_utils_exports.noop,\n  isDisabled = false,\n  disabledMessage,\n  errorMessage,\n  isError = false,\n  isSelected = false,\n  title\n}) => {\n  const handleChange = (0, react_exports.useMemo)(\n    () => (0, lodash_exports.debounce)((e, payload) => onValueChange(e, payload.value), 250),\n    [onValueChange]\n  );\n  const displayValue = value != null ? Number(value) : void 0;\n  const inputRef = (0, react_exports.useRef)(null);\n  let message;\n  if (isError) {\n    message = errorMessage;\n  } else if (isDisabled) {\n    message = disabledMessage;\n  }\n  (0, react_exports.useEffect)(() => {\n    if (isSelected && !isDisabled && !!inputRef.current) {\n      inputRef.current.focus({ preventScroll: true });\n    }\n  }, [isSelected, isDisabled]);\n  return /* @__PURE__ */ react_default.createElement(\n    Number_default,\n    {\n      min,\n      max,\n      step,\n      error: isError,\n      disabled: isDisabled,\n      inputId: id,\n      onChange: handleChange,\n      value: message ? void 0 : filterNaN(displayValue),\n      placeholder: message,\n      inputRef,\n      \"aria-label\": title\n    }\n  );\n};\nvar editor2 = [\n  {\n    label: (0, i18n_exports._)(\"Token\"),\n    enableCollapsible: true,\n    enableSeparator: true,\n    layout: [\n      [\n        {\n          label: (0, i18n_exports._)(\"Token name\"),\n          option: \"token\",\n          editor: \"editor.text\"\n        }\n      ]\n    ]\n  },\n  {\n    label: (0, i18n_exports._)(\"Value\"),\n    enableCollapsible: true,\n    enableSeparator: true,\n    layout: [\n      [\n        {\n          label: (0, i18n_exports._)(\"Min\"),\n          option: \"min\",\n          editor: \"editor.number\",\n          placeholder: \"e.g. 0\"\n        },\n        {\n          label: (0, i18n_exports._)(\"Max\"),\n          option: \"max\",\n          editor: \"editor.number\",\n          placeholder: \"e.g. 100\"\n        },\n        {\n          label: (0, i18n_exports._)(\"Step\"),\n          option: \"step\",\n          editor: \"editor.number\",\n          editorProps: {\n            min: 1\n          }\n        }\n      ],\n      [\n        {\n          label: (0, i18n_exports._)(\"Default value\"),\n          option: \"defaultValue\",\n          editor: \"editor.number\"\n        }\n      ]\n    ]\n  }\n];\nNumberInput.config = {\n  editorConfig: editor2,\n  optionsSchema: NumberSchema_default,\n  label: (0, i18n_exports._)(\"Number\"),\n  description: (0, i18n_exports._)(\"Field to enter a number\"),\n  baseShape: {\n    options: {\n      defaultValue: 10\n    },\n    title: (0, i18n_exports._)(\"Number Input Title\")\n  },\n  tokenPrefix: \"num\",\n  icon: dashboard_icons_exports.NumberInput\n};\nNumberInput.canHandleValue = (value) => {\n  if (value === null || typeof value === \"undefined\") {\n    return true;\n  }\n  if (typeof value === \"number\" || typeof value === \"string\") {\n    return Number.isFinite(Number(value));\n  }\n  return false;\n};\nNumberInput.valueToTokens = (value, { token }) => {\n  if (!token) {\n    return {};\n  }\n  if (value == null) {\n    return {\n      [token]: null\n    };\n  }\n  return {\n    [token]: `${value}`\n  };\n};\nNumberInput.tokensToValue = ({ tokens, tokenName, tokenNamespace }) => {\n  var _a;\n  if (!tokens || !tokenName || !tokenNamespace) {\n    return null;\n  }\n  const tokenValue = (_a = tokens[tokenNamespace]) == null ? void 0 : _a[tokenName];\n  if (!tokenValue) {\n    return null;\n  }\n  return Number(tokenValue);\n};\nNumberInput.validate = (inputDef) => {\n  var _a;\n  const options = (_a = inputDef.options) != null ? _a : {};\n  const errorMessages = [];\n  const { min, max } = options;\n  if (min !== void 0 && max !== void 0 && min > max) {\n    errorMessages.push(\"min should be less than max\");\n  }\n  return { errorMessages };\n};\nvar Number_default2 = withInputWrapper(NumberInput);\n\n// esm-externals:@splunk/ui-utils/promise\nvar promise_exports = {};\n__export(promise_exports, {\n  default: () => promise_default\n});\nvar defaultImport20 = __toESM(require(\"@splunk/ui-utils/promise\"));\n__reExport(promise_exports, require(\"@splunk/ui-utils/promise\"));\nvar promise_default = \"default\" in defaultImport20 ? defaultImport20.default : defaultImport20;\n\n// esm-externals:@splunk/react-time-range/Dropdown\nvar Dropdown_exports = {};\n__export(Dropdown_exports, {\n  default: () => Dropdown_default\n});\nvar defaultImport21 = __toESM(require(\"@splunk/react-time-range/Dropdown\"));\n__reExport(Dropdown_exports, require(\"@splunk/react-time-range/Dropdown\"));\nvar Dropdown_default = \"default\" in defaultImport21 ? defaultImport21.default : defaultImport21;\n\n// esm-externals:@splunk/time-range-utils/time\nvar time_exports = {};\n__export(time_exports, {\n  default: () => time_default\n});\nvar defaultImport22 = __toESM(require(\"@splunk/time-range-utils/time\"));\n__reExport(time_exports, require(\"@splunk/time-range-utils/time\"));\nvar time_default = \"default\" in defaultImport22 ? defaultImport22.default : defaultImport22;\n\n// esm-externals:@splunk/dashboard-telemetry\nvar dashboard_telemetry_exports = {};\n__export(dashboard_telemetry_exports, {\n  default: () => dashboard_telemetry_default\n});\nvar defaultImport23 = __toESM(require(\"@splunk/dashboard-telemetry\"));\n__reExport(dashboard_telemetry_exports, require(\"@splunk/dashboard-telemetry\"));\nvar dashboard_telemetry_default = \"default\" in defaultImport23 ? defaultImport23.default : defaultImport23;\n\n// src/components/BaseTimeRange.jsx\nvar DEFAULT_VALUE = \"-24h@h,now\";\nvar DEFAULT_LATEST = \"now\";\nvar SHORT_WIDTH = 278;\nvar LONG_WIDTH = 395;\nvar LONG_LABEL_LENGTH = 28;\nvar actionPayload = (currentTime) => ({\n  pageAction: \"performance.markAll\",\n  metadata: {\n    markInformation: \"TimeRangePicker\",\n    currentTime\n  }\n});\nvar toValue = ({ earliest, latest }) => `${earliest},${latest}`;\nvar BaseTimeRangePicker = ({\n  id,\n  value,\n  presets,\n  options: { defaultValue = DEFAULT_VALUE },\n  realTimeDisabled,\n  onValueChange,\n  momentTimeZone,\n  isError,\n  isDisabled,\n  onUpdateWidth,\n  parseEarliest,\n  parseLatest,\n  onRequestParseEarliest,\n  onRequestParseLatest,\n  title\n}) => {\n  const { earliest, latest } = parseValue2(value, defaultValue);\n  const { featureFlags: { enableDragDropInputs } = {} } = (0, react_exports.useContext)(dashboard_context_default);\n  const telemetry = (0, react_exports.useContext)(dashboard_telemetry_exports.TelemetryContext);\n  (0, react_exports.useEffect)(() => {\n    const label = (0, time_exports.createRangeLabel)(earliest, latest, {\n      timeRangePresets: presets,\n      maxChars: 0\n    });\n    if (label.length > LONG_LABEL_LENGTH) {\n      onUpdateWidth(\n        enableDragDropInputs ? LONG_WIDTH_DRAGGABLE : LONG_WIDTH\n      );\n    } else {\n      onUpdateWidth(\n        enableDragDropInputs ? SHORT_WIDTH_DRAGGABLE : SHORT_WIDTH\n      );\n    }\n  }, [earliest, latest, presets, onUpdateWidth, enableDragDropInputs]);\n  const handleChange = (0, react_exports.useCallback)(\n    (evt, changeData) => {\n      telemetry.emit(actionPayload(performance.now()));\n      return onValueChange(evt, toValue(changeData));\n    },\n    [onValueChange, telemetry]\n  );\n  return /* @__PURE__ */ react_default.createElement(\n    Dropdown_default,\n    {\n      describedBy: id,\n      presets,\n      onChange: handleChange,\n      earliest,\n      latest,\n      realTimeDisabled,\n      onRequestParseEarliest,\n      onRequestParseLatest,\n      parseEarliest,\n      parseLatest,\n      momentTimeZone,\n      inline: false,\n      labelMaxChars: 0,\n      disabled: isError || isDisabled,\n      \"aria-label\": title\n    }\n  );\n};\nBaseTimeRangePicker.canHandleValue = (value) => (\n  // valueToTokens will call parseValue which coalesces falsy values with\n  // DEFAULT_VALUE effectively allowing _any_ falsy value to be valid for the input.\n  // The parseValue fn also handles strings _not_ containing commas. Very robust.\n  !value || typeof value === \"string\"\n);\nBaseTimeRangePicker.valueToTokens = (value, { token }) => {\n  if (!token) {\n    return {};\n  }\n  const { earliest, latest } = parseValue2(value);\n  return {\n    [`${token}.earliest`]: earliest,\n    [`${token}.latest`]: latest\n  };\n};\nBaseTimeRangePicker.tokensToValue = ({ tokens, tokenName, tokenNamespace }) => {\n  if (!tokens || !tokenName || !tokenNamespace) {\n    return null;\n  }\n  const earliest = (0, lodash_exports.get)(tokens, [tokenNamespace, `${tokenName}.earliest`]);\n  const latest = (0, lodash_exports.get)(tokens, [tokenNamespace, `${tokenName}.latest`]);\n  return earliest && latest ? toValue({ earliest, latest }) : null;\n};\nBaseTimeRangePicker.propTypes = __spreadProps(__spreadValues({}, BaseInput_default.propTypes), {\n  realTimeDisabled: prop_types_default.bool,\n  // See: https://eng.sv.splunk.com/react-time-range/6.0.0/index.html#/Dropdown\n  presets: prop_types_default.arrayOf(prop_types_default.object),\n  momentTimeZone: prop_types_default.object,\n  parseEarliest: prop_types_default.object,\n  parseLatest: prop_types_default.object,\n  onRequestParseEarliest: prop_types_default.func,\n  onRequestParseLatest: prop_types_default.func,\n  title: prop_types_default.string\n});\nBaseTimeRangePicker.defaultProps = __spreadProps(__spreadValues({}, BaseInput_default.defaultProps), {\n  presets: []\n});\nvar meta3 = {\n  label: (0, i18n_exports._)(\"Time range\"),\n  description: (0, i18n_exports._)(\"Select a time range\"),\n  defaultConfig: {\n    options: {\n      defaultValue: \"-24h@h,now\"\n    },\n    title: (0, i18n_exports._)(\"Time Range Input Title\")\n  },\n  tokenPrefix: \"tr\",\n  includeInToolbar: true,\n  icon: dashboard_icons_exports.TimeRangeInput\n};\nvar schema = __spreadProps(__spreadValues({}, baseInputSchema), {\n  defaultValue: {\n    description: \"Default value of the input when no value is specified\",\n    type: \"string\"\n  }\n});\nBaseTimeRangePicker.config = {\n  meta: meta3,\n  schema\n};\n\n// src/utils/helpers.ts\nvar parseValue2 = (value, defaultValue) => {\n  const v = value || defaultValue || DEFAULT_VALUE;\n  const timeRanges = v.split(\",\");\n  return {\n    earliest: timeRanges[0].trim(),\n    latest: timeRanges[1] && timeRanges[1].trim() ? timeRanges[1].trim() : DEFAULT_LATEST\n  };\n};\n\n// src/components/DefaultTimeRangeConnector.jsx\nvar parsePromise = (time) => Promise.resolve((0, dashboard_utils_exports.parse)(time));\nvar DefaultTimeRangeConnector = ({ children, value = null }) => {\n  const { earliest, latest } = (0, react_exports.useMemo)(() => parseValue2(value), [value]);\n  const [parseEarliest, setParseEarliest] = (0, react_exports.useState)((0, dashboard_utils_exports.parse)(earliest));\n  const [parseLatest, setParseLatest] = (0, react_exports.useState)((0, dashboard_utils_exports.parse)(latest));\n  const cancelableEarliestTimeParser = (0, react_exports.useRef)(null);\n  const cancelableLatestTimeParser = (0, react_exports.useRef)(null);\n  (0, react_exports.useEffect)(() => {\n    return () => {\n      if (cancelableEarliestTimeParser.current) {\n        cancelableEarliestTimeParser.current.cancel();\n      }\n      if (cancelableLatestTimeParser.current) {\n        cancelableLatestTimeParser.current.cancel();\n      }\n    };\n  }, []);\n  const handleRequestParseEarliest = (0, react_exports.useCallback)((time) => {\n    if (cancelableEarliestTimeParser.current) {\n      cancelableEarliestTimeParser.current.cancel();\n    }\n    cancelableEarliestTimeParser.current = (0, promise_exports.makeCancelable)(\n      parsePromise(time)\n    );\n    cancelableEarliestTimeParser.current.promise.then((timeData) => {\n      setParseEarliest(timeData);\n    }).catch(() => void 0);\n  }, []);\n  const handleRequestParseLatest = (0, react_exports.useCallback)((time) => {\n    if (cancelableLatestTimeParser.current) {\n      cancelableLatestTimeParser.current.cancel();\n    }\n    cancelableLatestTimeParser.current = (0, promise_exports.makeCancelable)(parsePromise(time));\n    cancelableLatestTimeParser.current.promise.then((timeData) => {\n      setParseLatest(timeData);\n    }).catch(() => void 0);\n  }, []);\n  return (0, react_exports.cloneElement)(react_default.Children.only(children), {\n    presets: dashboard_utils_exports.defaultTimePreset,\n    parseEarliest,\n    parseLatest,\n    onRequestParseEarliest: handleRequestParseEarliest,\n    onRequestParseLatest: handleRequestParseLatest,\n    realTimeDisabled: true\n  });\n};\nDefaultTimeRangeConnector.propTypes = {\n  children: prop_types_default.element,\n  value: prop_types_default.string\n};\nvar DefaultTimeRangeConnector_default = DefaultTimeRangeConnector;\n\n// src/components/TRPEditor.jsx\nvar InputContainer2 = styled_components_default.div`\n    width: 329px;\n`;\nvar TRPEditor = ({\n  onChange,\n  name,\n  value,\n  labelPosition,\n  label,\n  enableRealTime,\n  Connector\n}) => {\n  const isDisabled = !value || (0, dashboard_utils_exports.hasTokens)(value);\n  const handleChange = (0, react_exports.useCallback)(\n    (evt, data) => {\n      onChange(evt, name, data);\n    },\n    [name, onChange]\n  );\n  return /* @__PURE__ */ react_default.createElement(dashboard_ui_exports.ControlGroup, { label, labelPosition }, /* @__PURE__ */ react_default.createElement(InputContainer2, null, /* @__PURE__ */ react_default.createElement(Connector, { value }, /* @__PURE__ */ react_default.createElement(\n    BaseTimeRangePicker,\n    {\n      \"data-test\": name,\n      onValueChange: handleChange,\n      value,\n      disabled: isDisabled,\n      enableRealTime\n    }\n  ))));\n};\nTRPEditor.propTypes = {\n  /**\n   * Callback when changing the text value\n   *\n   * @param {SyntheticEvent} event The react `SyntheticEvent`\n   * @param {string} name The option name\n   * @param {string} value The option value\n   */\n  onChange: prop_types_default.func.isRequired,\n  /**\n   * The option name\n   */\n  name: prop_types_default.string.isRequired,\n  /**\n   * A human readable label for the option\n   */\n  label: prop_types_default.string.isRequired,\n  /**\n   * The option value\n   */\n  value: prop_types_default.string,\n  /**\n   * Label position\n   */\n  labelPosition: prop_types_default.oneOf([\"top\", \"left\"]),\n  /**\n   * What environment to use\n   */\n  enableRealTime: prop_types_default.bool,\n  /**\n   * A connector that will supply:\n   * presets, onRequestParseEarliest, onRequestParseLatest,\n   * parseEarliest, and parseLatest props for its children\n   */\n  Connector: prop_types_default.elementType.isRequired\n};\nTRPEditor.defaultProps = {\n  value: DEFAULT_VALUE,\n  labelPosition: \"top\",\n  enableRealTime: false\n};\nvar TRPEditor_default = TRPEditor;\n\n// src/TimeRangePicker/TimeRangePicker.jsx\nvar TimeRangePicker = (props) => {\n  const { value } = props;\n  return /* @__PURE__ */ react_default.createElement(DefaultTimeRangeConnector_default, { value }, /* @__PURE__ */ react_default.createElement(BaseTimeRangePicker, __spreadValues({}, props)));\n};\nTimeRangePicker.canHandleValue = BaseTimeRangePicker.canHandleValue;\nTimeRangePicker.valueToTokens = BaseTimeRangePicker.valueToTokens;\nTimeRangePicker.tokensToValue = BaseTimeRangePicker.tokensToValue;\nvar editor3 = [\n  {\n    label: (0, i18n_exports._)(\"Token\"),\n    enableCollapsible: true,\n    enableSeparator: true,\n    layout: [\n      [\n        {\n          label: (0, i18n_exports._)(\"Token name\"),\n          option: \"token\",\n          editor: \"editor.text\"\n        }\n      ]\n    ]\n  },\n  {\n    label: (0, i18n_exports._)(\"Value\"),\n    enableCollapsible: true,\n    enableSeparator: true,\n    layout: [\n      [\n        {\n          label: (0, i18n_exports._)(\"Default value\"),\n          option: \"defaultValue\",\n          editor: TRPEditor_default,\n          editorProps: {\n            Connector: DefaultTimeRangeConnector_default\n          }\n        }\n      ]\n    ]\n  }\n];\nTimeRangePicker.config = __spreadValues({\n  editorConfig: editor3,\n  optionsSchema: BaseTimeRangePicker.config.schema\n}, (0, lodash_exports.mapKeys)(\n  BaseTimeRangePicker.config.meta,\n  (value, key) => key === \"defaultConfig\" ? \"baseShape\" : key\n));\nvar TimeRangePicker_default = withInputWrapper(TimeRangePicker);\n\n// esm-externals:@splunk/react-time-range/SplunkwebConnector\nvar SplunkwebConnector_exports = {};\n__export(SplunkwebConnector_exports, {\n  default: () => SplunkwebConnector_default\n});\nvar defaultImport24 = __toESM(require(\"@splunk/react-time-range/SplunkwebConnector\"));\n__reExport(SplunkwebConnector_exports, require(\"@splunk/react-time-range/SplunkwebConnector\"));\nvar SplunkwebConnector_default = \"default\" in defaultImport24 ? defaultImport24.default : defaultImport24;\n\n// src/EnterpriseTimeRangePicker/EnterpriseTimeRangePicker.jsx\nvar EnterpriseTimeRangePicker = (props) => {\n  return (\n    // SplunkwebConnector defines realTimeDisabled, presets, onRequestParseEarliest, onRequestParseLatest, parseEarliest, and parseLatest props for its children\n    /* @__PURE__ */ react_default.createElement(SplunkwebConnector_default, { validateRTSearchCapability: true }, /* @__PURE__ */ react_default.createElement(BaseTimeRangePicker, __spreadValues({}, props)))\n  );\n};\nvar editor4 = [\n  {\n    enableCollapsible: false,\n    enableSeparator: false,\n    layout: [\n      [\n        {\n          label: (0, i18n_exports._)(\"Token name\"),\n          option: \"token\",\n          editor: \"editor.text\"\n        }\n      ],\n      [\n        {\n          label: (0, i18n_exports._)(\"Default value\"),\n          option: \"defaultValue\",\n          editor: TRPEditor_default,\n          editorProps: {\n            enableRealTime: true,\n            Connector: SplunkwebConnector_default\n          }\n        }\n      ]\n    ]\n  }\n];\nEnterpriseTimeRangePicker.canHandleValue = BaseTimeRangePicker.canHandleValue;\nEnterpriseTimeRangePicker.valueToTokens = BaseTimeRangePicker.valueToTokens;\nEnterpriseTimeRangePicker.tokensToValue = BaseTimeRangePicker.tokensToValue;\nEnterpriseTimeRangePicker.config = __spreadValues({\n  editorConfig: editor4,\n  optionsSchema: BaseTimeRangePicker.config.schema\n}, (0, lodash_exports.mapKeys)(\n  BaseTimeRangePicker.config.meta,\n  (value, key) => key === \"defaultConfig\" ? \"baseShape\" : key\n));\nvar EnterpriseTimeRangePicker_default = withInputWrapper(EnterpriseTimeRangePicker);\n\n// esm-externals:@splunk/react-ui/Button\nvar Button_exports = {};\n__export(Button_exports, {\n  default: () => Button_default\n});\nvar defaultImport25 = __toESM(require(\"@splunk/react-ui/Button\"));\n__reExport(Button_exports, require(\"@splunk/react-ui/Button\"));\nvar Button_default = \"default\" in defaultImport25 ? defaultImport25.default : defaultImport25;\n\n// src/Button/ButtonSchema.ts\nvar ButtonSchema_default = __spreadProps(__spreadValues({}, baseInputSchema), {\n  label: {\n    description: \"Button label value.\",\n    type: \"string\"\n  }\n});\n\n// src/Button/Button.tsx\nvar defaultOptions3 = {};\nvar ButtonInput = ({\n  options: { label } = defaultOptions3,\n  onValueChange = dashboard_utils_exports.noop,\n  isSelected = false\n}) => {\n  const handleChange = (0, react_exports.useMemo)(\n    () => (0, lodash_exports.debounce)(() => onValueChange(), 250),\n    [onValueChange]\n  );\n  const inputRef = (0, react_exports.useRef)(null);\n  const fallbackValue = (0, i18n_exports._)(\"Button\");\n  const displayLabel = label ? label : fallbackValue;\n  (0, react_exports.useEffect)(() => {\n    if (isSelected && !!inputRef.current) {\n      inputRef.current.focus({ preventScroll: true });\n    }\n  }, [isSelected]);\n  return /* @__PURE__ */ react_default.createElement(\n    Button_default,\n    {\n      label: displayLabel,\n      onClick: handleChange,\n      elementRef: inputRef\n    }\n  );\n};\nvar editor5 = [\n  {\n    label: (0, i18n_exports._)(\"Label\"),\n    enableCollapsible: true,\n    enableSeparator: true,\n    layout: [\n      [\n        {\n          label: (0, i18n_exports._)(\"Label\"),\n          option: \"label\",\n          editor: \"editor.text\"\n        }\n      ]\n    ]\n  }\n];\nButtonInput.config = {\n  editorConfig: editor5,\n  optionsSchema: ButtonSchema_default,\n  label: (0, i18n_exports._)(\"Button\"),\n  description: (0, i18n_exports._)(\"Interactive button\"),\n  showTitle: false,\n  showToken: false\n};\nvar Button_default2 = withInputWrapper(ButtonInput);\n//# sourceMappingURL=index.js.map\n","/* Copyright © 2020 Splunk Inc.\nSPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or\nin part without a valid written license from Splunk Inc. is PROHIBITED. */\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject2) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject2(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject2(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  AbsoluteLayout: () => AbsoluteLayout_default,\n  AbsoluteLayoutOptionsSchema: () => absoluteLayoutOptionsSchema_default,\n  AbsoluteLayoutViewer: () => AbsoluteLayoutViewer_default,\n  BaseLayout: () => BaseLayout_default,\n  CLONE_LAYOUT_ITEMS_MSG_PANEL_TOO_SMALL: () => CLONE_LAYOUT_ITEMS_MSG_PANEL_TOO_SMALL,\n  CommonLayoutOptionsSchema: () => commonLayoutOptionsSchema_default,\n  ConnectedLine: () => ConnectedLine_default,\n  ConnectedLineOptionsSchema: () => ConnectedLineOptionsSchema_default,\n  EDGE_PREVIEW_DELAY_MS: () => EDGE_PREVIEW_DELAY_MS,\n  EDGE_THICKNESS_PX: () => EDGE_THICKNESS_PX,\n  GRID_PADDING_PX: () => GRID_PADDING_PX,\n  GRID_SIZE_PX: () => GRID_SIZE_PX,\n  GridLayout: () => GridLayout_default,\n  GridLayoutOptionsSchema: () => gridLayoutOptionsSchema_default,\n  GridLayoutViewer: () => GridLayoutViewer_default,\n  ITEM_DROP_TARGET_PX: () => ITEM_DROP_TARGET_PX,\n  InputLayout: () => InputLayoutViewer_default,\n  MIN_HEIGHT_PX: () => MIN_HEIGHT_PX,\n  MIN_WIDTH_PX: () => MIN_WIDTH_PX,\n  PLACEHOLDER_SIZE_PX: () => PLACEHOLDER_SIZE_PX,\n  SNAP_RANGE_PX: () => SNAP_RANGE_PX,\n  VIZ_DEFAULT_HEIGHT_PX: () => VIZ_DEFAULT_HEIGHT_PX,\n  VIZ_PREVIEW_DELAY_MS: () => VIZ_PREVIEW_DELAY_MS,\n  absoluteLayoutOptions: () => absoluteLayoutOptions,\n  gridLayoutOptions: () => gridLayoutOptions\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// esm-externals:@splunk/dashboard-utils\nvar dashboard_utils_exports = {};\n__export(dashboard_utils_exports, {\n  default: () => dashboard_utils_default\n});\nvar defaultImport = __toESM(require(\"@splunk/dashboard-utils\"));\n__reExport(dashboard_utils_exports, require(\"@splunk/dashboard-utils\"));\nvar dashboard_utils_default = \"default\" in defaultImport ? defaultImport.default : defaultImport;\n\n// esm-externals:rxjs\nvar rxjs_exports = {};\n__export(rxjs_exports, {\n  default: () => rxjs_default\n});\nvar defaultImport2 = __toESM(require(\"rxjs\"));\n__reExport(rxjs_exports, require(\"rxjs\"));\nvar rxjs_default = \"default\" in defaultImport2 ? defaultImport2.default : defaultImport2;\n\n// esm-externals:react\nvar react_exports = {};\n__export(react_exports, {\n  default: () => react_default\n});\nvar defaultImport3 = __toESM(require(\"react\"));\n__reExport(react_exports, require(\"react\"));\nvar react_default = \"default\" in defaultImport3 ? defaultImport3.default : defaultImport3;\n\n// esm-externals:lodash\nvar lodash_exports = {};\n__export(lodash_exports, {\n  default: () => lodash_default\n});\nvar defaultImport4 = __toESM(require(\"lodash\"));\n__reExport(lodash_exports, require(\"lodash\"));\nvar lodash_default = \"default\" in defaultImport4 ? defaultImport4.default : defaultImport4;\n\n// esm-externals:@splunk/dashboard-context\nvar dashboard_context_exports = {};\n__export(dashboard_context_exports, {\n  default: () => dashboard_context_default\n});\nvar defaultImport5 = __toESM(require(\"@splunk/dashboard-context\"));\n__reExport(dashboard_context_exports, require(\"@splunk/dashboard-context\"));\nvar dashboard_context_default = \"default\" in defaultImport5 ? defaultImport5.default : defaultImport5;\n\n// esm-externals:@splunk/dashboard-definition\nvar dashboard_definition_exports = {};\n__export(dashboard_definition_exports, {\n  default: () => dashboard_definition_default\n});\nvar defaultImport6 = __toESM(require(\"@splunk/dashboard-definition\"));\n__reExport(dashboard_definition_exports, require(\"@splunk/dashboard-definition\"));\nvar dashboard_definition_default = \"default\" in defaultImport6 ? defaultImport6.default : defaultImport6;\n\n// esm-externals:@splunk/dashboard-telemetry\nvar dashboard_telemetry_exports = {};\n__export(dashboard_telemetry_exports, {\n  default: () => dashboard_telemetry_default\n});\nvar defaultImport7 = __toESM(require(\"@splunk/dashboard-telemetry\"));\n__reExport(dashboard_telemetry_exports, require(\"@splunk/dashboard-telemetry\"));\nvar dashboard_telemetry_default = \"default\" in defaultImport7 ? defaultImport7.default : defaultImport7;\n\n// esm-externals:@splunk/dashboard-ui\nvar dashboard_ui_exports = {};\n__export(dashboard_ui_exports, {\n  default: () => dashboard_ui_default\n});\nvar defaultImport8 = __toESM(require(\"@splunk/dashboard-ui\"));\n__reExport(dashboard_ui_exports, require(\"@splunk/dashboard-ui\"));\nvar dashboard_ui_default = \"default\" in defaultImport8 ? defaultImport8.default : defaultImport8;\n\n// src/BaseLayoutApi.ts\nvar BaseLayoutApi = class {\n  constructor() {\n    this.emitTelemetry = (payload) => {\n      if (!this.telemetry) {\n        return false;\n      }\n      this.telemetry.emit(__spreadValues({\n        source: \"layoutApi\"\n      }, payload));\n      return true;\n    };\n  }\n  /**\n   * add new layout item synchronously\n   */\n  addLayoutItemSync(...args) {\n    return this.addLayoutItem(...args);\n  }\n  /**\n   * add one or more new layout items\n   */\n  addLayoutItems(items, metadata) {\n    return this.addLayoutItemSync(\n      items,\n      metadata\n    );\n  }\n  /**\n   * copies item w/h and position with an offset synchronously\n   */\n  cloneLayoutItemsSync({ from, to }) {\n    return this.cloneLayoutItems({ from, to });\n  }\n  /**\n   * remove an item from layout synchronously\n   */\n  removeLayoutItemsSync(itemIds) {\n    return this.removeLayoutItems(itemIds);\n  }\n};\nvar BaseLayoutApi_default = BaseLayoutApi;\n\n// src/utils/edgeUtils.ts\nvar nextEdgeId = () => `edge_${(0, dashboard_utils_exports.uniqueId)()}`;\nvar getNextEdgeId = () => {\n  return nextEdgeId();\n};\nvar getNodes = (layoutStructure) => {\n  if (layoutStructure.length === 0) {\n    return null;\n  }\n  const nodes = {};\n  layoutStructure.forEach((viz) => {\n    const { x, y, w, h } = viz.position;\n    const corners = [\n      { x, y },\n      { x: x + w, y },\n      { x, y: y + h },\n      { x: x + w, y: y + h }\n    ];\n    corners.forEach((corner) => {\n      if (nodes[corner.x] === void 0) {\n        nodes[corner.x] = {};\n      }\n      if (nodes[corner.x][corner.y] === void 0) {\n        nodes[corner.x][corner.y] = [];\n      }\n      nodes[corner.x][corner.y].push(viz);\n    });\n  });\n  return nodes;\n};\nvar isTopEdge = (edge) => edge.orientation === \"horizontal\" && edge.edgeStart.y === 0;\nvar isBottomEdge = (edge, canvasHeight) => edge.orientation === \"horizontal\" && edge.edgeStart.y === canvasHeight;\nvar isLeftEdge = (edge) => edge.orientation === \"vertical\" && edge.edgeStart.x === 0;\nvar isRightEdge = (edge, canvasWidth) => edge.orientation === \"vertical\" && edge.edgeStart.x === canvasWidth;\nvar findVizAlongVerticalEdge = ({\n  x,\n  yStart,\n  yEnd,\n  yCurrent = yStart,\n  nodes,\n  visualizations = /* @__PURE__ */ new Set()\n}) => {\n  nodes[x][yCurrent].forEach((viz) => {\n    if (viz.position.y >= yStart && viz.position.y < yEnd) {\n      visualizations.add(viz);\n    }\n    if (viz.position.y >= yCurrent && yCurrent + viz.position.h <= yEnd) {\n      findVizAlongVerticalEdge({\n        x,\n        yStart,\n        yEnd,\n        yCurrent: yCurrent + viz.position.h,\n        nodes,\n        visualizations\n      });\n    }\n  });\n  return visualizations;\n};\nvar findVizAlongHorizontalEdge = ({\n  y,\n  xStart,\n  xEnd,\n  xCurrent = xStart,\n  nodes,\n  visualizations = /* @__PURE__ */ new Set()\n}) => {\n  nodes[xCurrent][y].forEach((viz) => {\n    if (viz.position.x >= xStart && viz.position.x < xEnd) {\n      visualizations.add(viz);\n    }\n    if (viz.position.x >= xCurrent && xCurrent + viz.position.w <= xEnd) {\n      findVizAlongHorizontalEdge({\n        y,\n        xStart,\n        xEnd,\n        xCurrent: xCurrent + viz.position.w,\n        nodes,\n        visualizations\n      });\n    }\n  });\n  return visualizations;\n};\nvar addEdge = ({\n  edges,\n  edgeStart,\n  edgeEnd,\n  nodes\n}) => {\n  const orientation = edgeStart.y === edgeEnd.y ? \"horizontal\" : \"vertical\";\n  const visualizations = orientation === \"vertical\" ? findVizAlongVerticalEdge({\n    x: edgeStart.x,\n    yStart: edgeStart.y,\n    yEnd: edgeEnd.y,\n    nodes\n  }) : findVizAlongHorizontalEdge({\n    y: edgeStart.y,\n    xStart: edgeStart.x,\n    xEnd: edgeEnd.x,\n    nodes\n  });\n  edges.push({\n    item: getNextEdgeId(),\n    edgeStart,\n    edgeEnd,\n    visualizations: Array.from(visualizations),\n    orientation\n  });\n};\nvar shouldTraverseDown = (y, visualizations) => {\n  return visualizations.every((viz) => viz.position.y >= y);\n};\nvar shouldTraverseRight = (x, visualizations) => {\n  return visualizations.every((viz) => viz.position.x >= x);\n};\nvar findOffset = ({\n  x,\n  y,\n  visualizations,\n  type\n}) => {\n  for (let i = 0; i < visualizations.length; i += 1) {\n    const { position } = visualizations[i];\n    if (position.y === y && position.x === x) {\n      return position[type];\n    }\n  }\n  for (let i = 0; i < visualizations.length; i += 1) {\n    const { position } = visualizations[i];\n    if (type === \"w\" && position.x === x) {\n      return position.w;\n    }\n    if (type === \"h\" && position.y === y) {\n      return position.h;\n    }\n  }\n  return 0;\n};\nfunction traverseRight({\n  x,\n  y,\n  nodes,\n  edges,\n  edgeStart,\n  canTraverseDown = true\n}) {\n  if (canTraverseDown && shouldTraverseDown(y, nodes[x][y])) {\n    traverseDown({\n      x,\n      y,\n      nodes,\n      edges,\n      edgeStart: { x, y },\n      // Start new edge when changing directions\n      canTraverseRight: false\n    });\n  }\n  const offset = findOffset({ x, y, visualizations: nodes[x][y], type: \"w\" });\n  if (!offset) {\n    addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n    return;\n  }\n  const isWindow = nodes[x][y].length === 4;\n  if (isWindow) {\n    addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n    traverseRight({\n      x: x + offset,\n      y,\n      nodes,\n      edges,\n      edgeStart: { x, y }\n    });\n    return;\n  }\n  traverseRight({\n    x: x + offset,\n    y,\n    nodes,\n    edges,\n    edgeStart\n  });\n}\nfunction traverseDown({\n  x,\n  y,\n  nodes,\n  edges,\n  edgeStart,\n  canTraverseRight = true\n}) {\n  if (canTraverseRight && shouldTraverseRight(x, nodes[x][y])) {\n    traverseRight({\n      x,\n      y,\n      nodes,\n      edges,\n      edgeStart: { x, y },\n      // Start new edge when changing directions\n      canTraverseDown: false\n    });\n  }\n  const offset = findOffset({ x, y, visualizations: nodes[x][y], type: \"h\" });\n  if (!offset) {\n    addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n    return;\n  }\n  const isWindow = nodes[x][y].length === 4;\n  if (isWindow) {\n    addEdge({ edges, edgeStart, edgeEnd: { x, y }, nodes });\n    traverseDown({\n      x,\n      y: y + offset,\n      nodes,\n      edges,\n      edgeStart: { x, y }\n    });\n    return;\n  }\n  traverseDown({\n    x,\n    y: y + offset,\n    nodes,\n    edges,\n    edgeStart\n  });\n}\nvar computeVerticalCanvasEdges = ({\n  edges,\n  canvasWidth,\n  layout\n}) => {\n  const nodes = getNodes(layout);\n  if (nodes == null) {\n    return;\n  }\n  const sortedRowEdges = edges.filter(\n    (edge) => edge.orientation === \"horizontal\" && edge.edgeStart.x === 0 && edge.edgeEnd.x === canvasWidth\n  ).sort((a, b) => a.edgeStart.y - b.edgeStart.y);\n  for (let i = 0; i < sortedRowEdges.length - 1; i += 1) {\n    const { edgeStart: edgeStartA, edgeEnd: edgeEndA } = sortedRowEdges[i];\n    const { edgeStart: edgeStartB, edgeEnd: edgeEndB } = sortedRowEdges[i + 1];\n    addEdge({\n      edges,\n      edgeStart: edgeStartA,\n      edgeEnd: edgeStartB,\n      nodes\n    });\n    addEdge({\n      edges,\n      edgeStart: edgeEndA,\n      edgeEnd: edgeEndB,\n      nodes\n    });\n  }\n};\nvar getAllEdges = (layout) => {\n  const edges = [];\n  const nodes = getNodes(layout);\n  if (nodes === null || nodes[0] === void 0 || nodes[0][0] === void 0) {\n    return [];\n  }\n  traverseRight({\n    x: 0,\n    y: 0,\n    nodes,\n    edges,\n    edgeStart: { x: 0, y: 0 }\n  });\n  return edges;\n};\nvar computeEdges = ({\n  layout,\n  canvasHeight,\n  canvasWidth\n}) => {\n  if (layout === void 0) {\n    return [];\n  }\n  let edges = getAllEdges(layout);\n  edges = edges.filter((edge) => {\n    return !(isLeftEdge(edge) || isRightEdge(edge, canvasWidth));\n  });\n  computeVerticalCanvasEdges({ edges, layout, canvasWidth });\n  edges = edges.map((edge) => {\n    let isCanvasEdge = false;\n    if (isTopEdge(edge) || isRightEdge(edge, canvasWidth) || isBottomEdge(edge, canvasHeight) || isLeftEdge(edge)) {\n      isCanvasEdge = true;\n    }\n    return __spreadProps(__spreadValues({}, edge), { isCanvasEdge });\n  });\n  return edges;\n};\nvar applyVizPadding = ({\n  item,\n  padding = 0\n}) => {\n  const { x, y, w, h } = item.position;\n  return __spreadProps(__spreadValues({}, item), {\n    position: {\n      x: x + padding,\n      y: y + padding,\n      w: w - 2 * padding,\n      h: h - 2 * padding\n    }\n  });\n};\nvar getVerticalBoundaries = ({\n  visualizations,\n  y,\n  minHeight,\n  isFullWidthEdge = false\n}) => {\n  const boundaries = {\n    upperBoundary: Number.NEGATIVE_INFINITY,\n    lowerBoundary: Number.POSITIVE_INFINITY\n  };\n  const comparePosition = (position) => {\n    if (position.y >= y && !isFullWidthEdge) {\n      boundaries.lowerBoundary = Math.min(\n        boundaries.lowerBoundary,\n        position.y + position.h - minHeight\n      );\n    }\n    if (position.y < y) {\n      boundaries.upperBoundary = Math.max(\n        boundaries.upperBoundary,\n        position.y + minHeight\n      );\n    }\n  };\n  visualizations.forEach((viz) => comparePosition(viz.position));\n  return boundaries;\n};\nvar getHorizontalBoundaries = ({\n  visualizations,\n  x,\n  minWidth\n}) => {\n  const boundaries = {\n    rightBoundary: Number.POSITIVE_INFINITY,\n    leftBoundary: Number.NEGATIVE_INFINITY\n  };\n  const comparePosition = (position) => {\n    if (position.x >= x) {\n      boundaries.rightBoundary = Math.min(\n        boundaries.rightBoundary,\n        position.x + position.w - minWidth\n      );\n    }\n    if (position.x < x) {\n      boundaries.leftBoundary = Math.max(\n        boundaries.leftBoundary,\n        position.x + minWidth\n      );\n    }\n  };\n  visualizations.forEach((viz) => comparePosition(viz.position));\n  return boundaries;\n};\nvar moveHorizontalEdge = ({\n  edge,\n  offset,\n  edgeBoundaries: { upperBoundary, lowerBoundary }\n}) => {\n  const updatedY = offset < 0 ? Math.max(upperBoundary, edge.edgeStart.y + offset) : Math.min(lowerBoundary, edge.edgeStart.y + offset);\n  return __spreadProps(__spreadValues({}, edge), {\n    edgeStart: {\n      x: edge.edgeStart.x,\n      y: updatedY\n    },\n    edgeEnd: {\n      x: edge.edgeEnd.x,\n      y: updatedY\n    }\n  });\n};\nvar moveVerticalEdge = ({\n  edge,\n  offset,\n  edgeBoundaries: { leftBoundary, rightBoundary }\n}) => {\n  const updatedX = offset < 0 ? Math.max(leftBoundary, edge.edgeStart.x + offset) : Math.min(rightBoundary, edge.edgeStart.x + offset);\n  return __spreadProps(__spreadValues({}, edge), {\n    edgeStart: {\n      x: updatedX,\n      y: edge.edgeStart.y\n    },\n    edgeEnd: {\n      x: updatedX,\n      y: edge.edgeEnd.y\n    }\n  });\n};\nvar findSnappableEdges = ({\n  edge,\n  edges,\n  snapRange\n}) => {\n  const coordinate = edge.orientation === \"horizontal\" ? \"y\" : \"x\";\n  const snappableEdges = edges.reduce(\n    (currentSnappableEdges, nextEdge) => {\n      const nextEdgeDistance = Math.abs(\n        nextEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]\n      );\n      if (nextEdgeDistance <= snapRange) {\n        if (currentSnappableEdges.length === 0) {\n          return [nextEdge];\n        }\n        const lastEdge = currentSnappableEdges[currentSnappableEdges.length - 1];\n        const lastEdgeDistance = Math.abs(\n          lastEdge.edgeStart[coordinate] - edge.edgeStart[coordinate]\n        );\n        if (nextEdgeDistance < lastEdgeDistance) {\n          return [nextEdge];\n        }\n        if (nextEdgeDistance === lastEdgeDistance) {\n          return [...currentSnappableEdges, nextEdge];\n        }\n      }\n      return [...currentSnappableEdges];\n    },\n    []\n  );\n  const firstSnappableEdge = snappableEdges.length > 0 ? snappableEdges[0] : edge;\n  return {\n    updatedEdge: __spreadProps(__spreadValues({}, edge), {\n      edgeStart: __spreadProps(__spreadValues({}, edge.edgeStart), {\n        [coordinate]: firstSnappableEdge.edgeStart[coordinate]\n      }),\n      edgeEnd: __spreadProps(__spreadValues({}, edge.edgeEnd), {\n        [coordinate]: firstSnappableEdge.edgeEnd[coordinate]\n      })\n    }),\n    snappableEdges\n  };\n};\nvar findEdgesInBoundary = ({\n  edge,\n  edges,\n  edgeBoundaries\n}) => {\n  const { orientation } = edge;\n  if (orientation === \"horizontal\") {\n    return edges.filter(\n      (e) => e.orientation === \"horizontal\" && e.edgeStart.y >= edgeBoundaries.upperBoundary && e.edgeStart.y <= edgeBoundaries.lowerBoundary && e !== edge\n    );\n  }\n  if (orientation === \"vertical\") {\n    return edges.filter(\n      (e) => e.orientation === \"vertical\" && e.edgeStart.x >= edgeBoundaries.leftBoundary && e.edgeStart.x <= edgeBoundaries.rightBoundary && e !== edge\n    );\n  }\n  return [];\n};\n\n// src/utils/layoutUtils.ts\nvar computeMaxHeight = dashboard_utils_exports.computeMaxHeight;\nvar isBlockPositionValid = (position) => !!(position && Number.isInteger(position.x) && Number.isInteger(position.y) && Number.isInteger(position.w) && Number.isInteger(position.h));\nvar isValidConnection = (connection) => {\n  if (\"x\" in connection && \"y\" in connection && Number.isInteger(connection.x) && Number.isInteger(connection.y)) {\n    return true;\n  }\n  if (\"item\" in connection && \"port\" in connection && connection.item != null && connection.port != null) {\n    return true;\n  }\n  return false;\n};\nvar isLinePositionValid = (position) => {\n  if (position.from != null && position.to != null) {\n    return isValidConnection(position.from) && isValidConnection(position.to);\n  }\n  return false;\n};\nvar removeInvalidItems = (layoutStructure = []) => layoutStructure.filter((structure) => {\n  if (structure.type === \"line\") {\n    return isLinePositionValid(structure.position);\n  }\n  return isBlockPositionValid(structure.position);\n});\nvar positionToStyle = (pos) => ({\n  width: `${pos.w}px`,\n  height: `${pos.h}px`,\n  transform: `translate(${pos.x}px, ${pos.y}px)`\n});\nvar getClientPosition = (e, scaleFactor = 1) => ({\n  x: Math.round(e.clientX / scaleFactor),\n  y: Math.round(e.clientY / scaleFactor)\n});\nvar getOffset = (currentPosition, startPosition) => ({\n  offsetX: currentPosition.x - startPosition.x,\n  offsetY: currentPosition.y - startPosition.y\n});\nvar considerMoved = ({\n  offsetX,\n  offsetY\n}) => offsetX !== 0 || offsetY !== 0;\nvar positionsToBoundary = (startPos, endPos) => ({\n  x: Math.min(startPos.x, endPos.x),\n  y: Math.min(startPos.y, endPos.y),\n  w: Math.abs(startPos.x - endPos.x),\n  h: Math.abs(startPos.y - endPos.y)\n});\nvar filterBlockItemsByBoundary = (items, boundary) => items.filter((item) => {\n  const itemPosition = item.position;\n  return !(boundary.x > itemPosition.x + itemPosition.w || boundary.x + boundary.w < itemPosition.x || boundary.y > itemPosition.y + itemPosition.h || boundary.y + boundary.h < itemPosition.y);\n});\nvar findTopBlockItemByPosition = (items, pos, padding = 0) => (0, lodash_exports.findLast)(items, (item) => {\n  const itemPosition = padding ? applyVizPadding({ item, padding }).position : item.position;\n  return itemPosition.x <= pos.x && itemPosition.x + itemPosition.w >= pos.x && itemPosition.y <= pos.y && itemPosition.y + itemPosition.h >= pos.y;\n});\nvar snapOffset = (current, offset, snapTo) => {\n  const remainder = (current + offset) % snapTo;\n  const newOffset = remainder > snapTo / 2 ? offset + (snapTo - remainder) : offset - remainder;\n  return newOffset;\n};\nvar snapOffsetToXY = ({\n  position,\n  offset,\n  gridWidth,\n  gridHeight,\n  spacing = 0,\n  padding = 0\n}) => {\n  let { offsetX, offsetY } = offset;\n  offsetX = snapOffset(position.x, offsetX, gridWidth + spacing) + padding;\n  offsetY = snapOffset(position.y, offsetY, gridHeight + spacing) + padding;\n  return {\n    offsetX,\n    offsetY\n  };\n};\nvar snapOffsetToWH = ({\n  position,\n  offset,\n  gridWidth,\n  gridHeight,\n  spacing = 0,\n  padding = 0\n}) => {\n  let { offsetX, offsetY } = offset;\n  offsetX = snapOffset(position.x + position.w, offsetX, gridWidth + spacing) + (padding - spacing);\n  offsetY = snapOffset(position.y + position.h, offsetY, gridHeight + spacing) + (padding - spacing);\n  return {\n    offsetX,\n    offsetY\n  };\n};\nvar updateBlockItemSize = ({\n  item,\n  offset,\n  dir,\n  options: { minWidth = 0, minHeight = 0 } = {}\n}) => {\n  const { w, h } = item.position;\n  const { offsetX, offsetY } = offset;\n  const updatedPosition = __spreadValues({}, item.position);\n  if ([\"n\", \"ne\", \"nw\"].includes(dir)) {\n    updatedPosition.y += Math.min(h - minHeight, offsetY);\n    updatedPosition.h -= offsetY;\n  }\n  if ([\"s\", \"se\", \"sw\"].includes(dir)) {\n    updatedPosition.h += offsetY;\n  }\n  if ([\"e\", \"ne\", \"se\"].includes(dir)) {\n    updatedPosition.w += offsetX;\n  }\n  if ([\"w\", \"nw\", \"sw\"].includes(dir)) {\n    updatedPosition.x += Math.min(w - minWidth, offsetX);\n    updatedPosition.w -= offsetX;\n  }\n  updatedPosition.w = Math.max(minWidth, updatedPosition.w);\n  updatedPosition.h = Math.max(minHeight, updatedPosition.h);\n  return __spreadProps(__spreadValues({}, item), {\n    position: updatedPosition\n  });\n};\nvar updateBlockItemPosition = (item, offset) => {\n  const { offsetX, offsetY } = offset;\n  return __spreadProps(__spreadValues({}, item), {\n    position: __spreadProps(__spreadValues({}, item.position), {\n      x: item.position.x + offsetX,\n      y: item.position.y + offsetY\n    })\n  });\n};\nvar createOffset = (dir, x, y) => {\n  switch (dir) {\n    case \"n\":\n      return {\n        offsetX: 0,\n        offsetY: -y\n      };\n    case \"s\":\n      return {\n        offsetX: 0,\n        offsetY: y\n      };\n    case \"w\":\n      return {\n        offsetX: -x,\n        offsetY: 0\n      };\n    case \"e\":\n      return {\n        offsetX: x,\n        offsetY: 0\n      };\n    default:\n      return {\n        offsetX: 0,\n        offsetY: 0\n      };\n  }\n};\nvar computeScaleToFit = ({\n  canvasWidth,\n  canvasHeight,\n  containerWidth,\n  containerHeight,\n  scrollbarWidth,\n  max = Infinity,\n  enableGridLayoutCssScaling = true\n}) => {\n  if (!((0, lodash_exports.isNumber)(containerWidth) && containerWidth > 0 && (0, lodash_exports.isNumber)(canvasWidth) && canvasWidth > 0)) {\n    dashboard_utils_exports.console.warn(\n      `Failed to calculate layout scale: canvasWidth=${canvasWidth}, containerWidth=${containerWidth}; falling back to scale=1`\n    );\n    return 1;\n  }\n  const scale = Math.min(containerWidth / canvasWidth, max);\n  const scrollbarScale = Math.min(\n    (containerWidth - scrollbarWidth) / canvasWidth,\n    max\n  );\n  if (!enableGridLayoutCssScaling) {\n    return scrollbarScale;\n  }\n  if (canvasHeight * scale > containerHeight) {\n    return scrollbarScale;\n  }\n  return scale;\n};\nvar moveLayoutItem = (items, from, to) => {\n  const structure = [...items];\n  const removed = (0, lodash_exports.pullAt)(structure, [from]);\n  structure.splice(to, 0, removed[0]);\n  return structure;\n};\nvar isLineConnected = ({ line, dir }) => \"item\" in line.position[dir];\nvar disconnectLine = ({\n  line,\n  dir,\n  absPos\n}) => {\n  const updatePosition = __spreadProps(__spreadValues({}, line.position), {\n    [dir]: __spreadValues({}, absPos)\n  });\n  return __spreadProps(__spreadValues({}, line), {\n    position: updatePosition\n  });\n};\nvar connectLine = ({\n  line,\n  dir,\n  itemId,\n  port\n}) => {\n  const { position } = line;\n  const updatedPosition = __spreadProps(__spreadValues({}, position), {\n    [dir]: {\n      item: itemId,\n      port\n    }\n  });\n  return __spreadProps(__spreadValues({}, line), {\n    position: updatedPosition\n  });\n};\nvar updateLineAbsPosition = ({\n  line,\n  dir,\n  offset\n}) => {\n  const { offsetX, offsetY } = offset;\n  const { position } = line;\n  if (!(\"x\" in position[dir])) {\n    throw Error(\n      `line item ${line.item} does not have x value for its direction ${dir}`\n    );\n  }\n  if (!(\"y\" in position[dir])) {\n    throw Error(\n      `line item ${line.item} does not have y value for its direction ${dir}`\n    );\n  }\n  const { x, y } = position[dir];\n  return __spreadProps(__spreadValues({}, line), {\n    position: __spreadProps(__spreadValues({}, position), {\n      [dir]: {\n        x: x + offsetX,\n        y: y + offsetY\n      }\n    })\n  });\n};\nvar computeLineBoxPosition = (from, to) => ({\n  x: Math.min(from.x, to.x),\n  y: Math.min(from.y, to.y)\n});\nvar computeLineRelativePosition = (from, to, box) => ({\n  from: {\n    x: from.x - box.x,\n    y: from.y - box.y\n  },\n  to: {\n    x: to.x - box.x,\n    y: to.y - box.y\n  }\n});\nvar cloneBlockItem = ({\n  id,\n  item,\n  offsetMultiplier\n}) => {\n  const copiedPosition = item.position;\n  return __spreadProps(__spreadValues({}, item), {\n    item: id,\n    position: {\n      x: copiedPosition.x + 20 * offsetMultiplier,\n      y: copiedPosition.y + 20 * offsetMultiplier,\n      w: copiedPosition.w,\n      h: copiedPosition.h\n    }\n  });\n};\nvar cloneLine = ({\n  id,\n  item,\n  offsetMultiplier\n}) => {\n  const copiedPosition = item.position;\n  return __spreadProps(__spreadValues({}, item), {\n    item: id,\n    position: {\n      from: {\n        x: copiedPosition.from.x + 20 * offsetMultiplier,\n        y: copiedPosition.from.y + 20 * offsetMultiplier\n      },\n      to: {\n        x: copiedPosition.to.x + 20 * offsetMultiplier,\n        y: copiedPosition.to.y + 20 * offsetMultiplier\n      }\n    }\n  });\n};\nvar shiftViewportOnZoom = ({\n  scrollLeft,\n  scrollTop,\n  offsetWidth,\n  offsetHeight,\n  scaleRatio\n}) => {\n  const middleOffsetWidth = offsetWidth / 2;\n  const middleOffsetHeight = offsetHeight / 2;\n  return {\n    scrollLeft: (scrollLeft + middleOffsetWidth) * scaleRatio - middleOffsetWidth,\n    scrollTop: (scrollTop + middleOffsetHeight) * scaleRatio - middleOffsetHeight\n  };\n};\nvar computeRelativePosition = (e, canvasRef, scale = 1) => {\n  var _a;\n  const pos = getClientPosition(e, scale);\n  const canvasDomNode = canvasRef == null ? void 0 : canvasRef.current;\n  const rect = (_a = canvasDomNode == null ? void 0 : canvasDomNode.getBoundingClientRect) == null ? void 0 : _a.call(canvasDomNode);\n  if (pos && rect) {\n    return {\n      x: pos.x - rect.left / scale,\n      y: pos.y - rect.top / scale\n    };\n  }\n  return pos;\n};\nvar scaleGridLayoutStructureByWidth = ({\n  layout,\n  scale = 1\n}) => {\n  if (scale === 1) {\n    return layout;\n  }\n  const edges = getAllEdges(layout);\n  const verticalEdges = (0, lodash_exports.sortBy)(\n    edges.filter((edge) => edge.orientation === \"vertical\"),\n    [\"edgeStart.x\"]\n  );\n  const newLayout = [];\n  verticalEdges.forEach((edge) => {\n    const {\n      visualizations,\n      edgeStart: { x }\n    } = edge;\n    const scaledEdgeX = Math.round(x * scale);\n    const left = visualizations.filter((viz) => viz.position.x < x);\n    const right = visualizations.filter((viz) => viz.position.x >= x);\n    left.forEach((layoutItem) => {\n      const newLayoutItem = newLayout.find(\n        ({ item: id }) => layoutItem.item === id\n      );\n      if (newLayoutItem) {\n        newLayoutItem.position.w = scaledEdgeX - newLayoutItem.position.x;\n      }\n    });\n    right.forEach((layoutItem) => {\n      newLayout.push(__spreadProps(__spreadValues({}, layoutItem), {\n        position: __spreadProps(__spreadValues({}, layoutItem.position), {\n          x: scaledEdgeX\n        })\n      }));\n    });\n  });\n  return newLayout;\n};\n\n// esm-externals:@splunk/ui-utils/i18n\nvar i18n_exports = {};\n__export(i18n_exports, {\n  default: () => i18n_default\n});\nvar defaultImport9 = __toESM(require(\"@splunk/ui-utils/i18n\"));\n__reExport(i18n_exports, require(\"@splunk/ui-utils/i18n\"));\nvar i18n_default = \"default\" in defaultImport9 ? defaultImport9.default : defaultImport9;\n\n// src/utils/blockUtils.ts\nvar findSelectedBlockItems = ({\n  layoutStructure,\n  selectedItems\n}) => layoutStructure.filter(\n  (item) => selectedItems.findIndex(\n    ({ id }) => item.item === id && (0, dashboard_utils_exports.isBlockItem)(item)\n  ) >= 0\n);\nvar getAllBlockItems = ({\n  layoutStructure,\n  layoutStructureState = {}\n}) => {\n  return layoutStructure.map((item) => {\n    var _a;\n    return (_a = layoutStructureState[item.item]) != null ? _a : item;\n  }).filter((item) => (0, dashboard_utils_exports.isBlockItem)(item));\n};\nvar computePortPosition = (blockItem, port) => {\n  const blockPosition = blockItem.position;\n  switch (port) {\n    case \"n\":\n      return {\n        x: Math.round(blockPosition.x + blockPosition.w / 2),\n        y: blockPosition.y\n      };\n    case \"w\":\n      return {\n        x: blockPosition.x,\n        y: Math.round(blockPosition.y + blockPosition.h / 2)\n      };\n    case \"e\":\n      return {\n        x: blockPosition.x + blockPosition.w,\n        y: Math.round(blockPosition.y + blockPosition.h / 2)\n      };\n    case \"s\":\n    default:\n      return {\n        x: Math.round(blockPosition.x + blockPosition.w / 2),\n        y: blockPosition.y + blockPosition.h\n      };\n  }\n};\nvar InvalidBlockItemError = \"refers to an invalid block item\";\nvar InvalidBlockItemErrorMessage = (0, i18n_exports._)(`%s ${InvalidBlockItemError}`);\nvar getBlockItem = ({\n  layoutStructure,\n  id\n}) => {\n  const blockItem = layoutStructure.find(({ item }) => item === id);\n  if (!blockItem || blockItem.type === \"line\") {\n    throw Error(InvalidBlockItemErrorMessage.replace(\"%s\", id));\n  }\n  return blockItem;\n};\n\n// src/utils/lineUtils.ts\nvar computeLineAbsPosition = ({\n  layoutStructure,\n  position\n}) => {\n  let { from, to } = position;\n  if (\"item\" in from && \"port\" in from) {\n    const blockItem = getBlockItem({ layoutStructure, id: from.item });\n    from = computePortPosition(blockItem, from.port);\n  }\n  if (\"item\" in to && \"port\" in to) {\n    const blockItem = getBlockItem({ layoutStructure, id: to.item });\n    to = computePortPosition(blockItem, to.port);\n  }\n  return {\n    from,\n    to\n  };\n};\nvar findSelectedLineItems = ({\n  layoutStructure,\n  selectedItems\n}) => layoutStructure.filter(\n  ({ item, type }) => selectedItems.findIndex(\n    ({ id }) => item === id && type === \"line\"\n  ) >= 0\n);\nvar handleSingleLineMove = ({\n  lineId,\n  offset,\n  layoutStructure\n}) => {\n  let line = layoutStructure.find(\n    (item) => item.item === lineId\n  );\n  const linePosition = computeLineAbsPosition({\n    layoutStructure,\n    position: line.position\n  });\n  if (isLineConnected({ line, dir: \"from\" })) {\n    line = disconnectLine({\n      line,\n      dir: \"from\",\n      absPos: linePosition.from\n    });\n  }\n  if (isLineConnected({ line, dir: \"to\" })) {\n    line = disconnectLine({\n      line,\n      dir: \"to\",\n      absPos: linePosition.to\n    });\n  }\n  line = updateLineAbsPosition({\n    line,\n    dir: \"from\",\n    offset\n  });\n  line = updateLineAbsPosition({\n    line,\n    dir: \"to\",\n    offset\n  });\n  return line;\n};\nvar handleSingleLineDragStart = ({\n  lineId,\n  layoutStructure,\n  lineDir\n}) => {\n  let line = layoutStructure.find(\n    (item) => item.item === lineId\n  );\n  const linePosition = computeLineAbsPosition({\n    layoutStructure,\n    position: line.position\n  });\n  if (isLineConnected({\n    line,\n    dir: lineDir\n  })) {\n    line = disconnectLine({\n      line,\n      dir: lineDir,\n      absPos: linePosition[lineDir]\n    });\n  }\n  return line;\n};\nvar getAllLineItems = ({\n  layoutStructure,\n  layoutStructureState = {}\n}) => {\n  return layoutStructure.map((item) => {\n    var _a;\n    return (_a = layoutStructureState[item.item]) != null ? _a : item;\n  }).filter(({ type }) => type === \"line\");\n};\n\n// src/utils/imageUtils.ts\nvar isFromImageRegistry = (src = \"\") => {\n  const [type] = src.split(\"://\");\n  return src.indexOf(\"://\") > -1 && type !== \"http\" && type !== \"https\" && type !== \"ftp\" && type !== \"file\";\n};\nvar validImagePos = ({\n  x,\n  y,\n  canvasWidth,\n  canvasHeight\n}) => !!(x != null && Number.isInteger(x) && y != null && Number.isInteger(y) && x <= canvasWidth && y <= canvasHeight && x >= 0 && y >= 0);\nvar validImageWidthHeight = (imageWidth = 1, imageHeight = 1) => !!(Number.isInteger(imageWidth) && Number.isInteger(imageHeight) && imageWidth > 0 && imageHeight > 0);\nvar invalidImageSizeType = (sizeType) => !!(sizeType !== \"cover\" && sizeType !== \"contain\" && sizeType !== \"auto\" && sizeType !== void 0);\nvar getImageDimension = (0, lodash_exports.memoize)(\n  (imgSrc) => {\n    const img = new Image();\n    try {\n      img.src = imgSrc;\n      img.style.position = \"absolute\";\n      img.style.left = \"-9999\";\n      img.style.visibility = \"hidden\";\n      document.body.appendChild(img);\n      const height = img.naturalHeight;\n      const width = img.naturalWidth;\n      return { width, height };\n    } catch (ex) {\n      return { width: 0, height: 0 };\n    } finally {\n      if (document.body.contains(img)) {\n        document.body.removeChild(img);\n      }\n    }\n  }\n);\nvar validateBackgroundImage = ({\n  backgroundImage = {},\n  canvasWidth,\n  canvasHeight\n}) => {\n  const { src } = backgroundImage;\n  let { x, y, w, h, sizeType } = backgroundImage;\n  if ((0, lodash_exports.isEmpty)(backgroundImage)) {\n    return { src, x, y, w, h, sizeType };\n  }\n  if (src == null) {\n    return { src, x, y, w, h, sizeType };\n  }\n  if (!validImagePos({ x, y, canvasWidth, canvasHeight })) {\n    dashboard_utils_exports.console.warn(\n      `Invalid background image position, x: ${x} y: ${y}. Defaulting to x: 0, y: 0`\n    );\n    x = 0;\n    y = 0;\n  }\n  if (w == null && h == null && (sizeType == null || invalidImageSizeType(sizeType))) {\n    dashboard_utils_exports.console.warn(\n      `Invalid background image sizeType, ${sizeType}. Defaulting to contain`\n    );\n    sizeType = \"contain\";\n  } else if ((sizeType == null || invalidImageSizeType(sizeType)) && (w != null && h == null || w == null && h != null || !validImageWidthHeight(w, h))) {\n    dashboard_utils_exports.console.warn(\n      `Invalid background image width and height, w: ${w} h: ${h}. Defaulting to image original size`\n    );\n    w = w || 0;\n    h = h || 0;\n  }\n  return { src, x, y, w, h, sizeType };\n};\n\n// src/DefaultOptions.ts\nvar absoluteLayoutOptions = {\n  width: dashboard_utils_exports.DEFAULT_CANVAS_WIDTH,\n  height: dashboard_utils_exports.DEFAULT_CANVAS_HEIGHT,\n  display: \"auto\"\n};\nvar gridLayoutOptions = {\n  width: dashboard_utils_exports.DEFAULT_CANVAS_WIDTH,\n  gutterSize: 8\n};\n\n// src/apis/AbsoluteLayoutApi.ts\nvar AbsoluteLayoutApi = class extends BaseLayoutApi_default {\n  constructor(_a) {\n    var _b = _a, { telemetry } = _b, layout = __objRest(_b, [\"telemetry\"]);\n    super();\n    /**\n     * Get layout items in order\n     * @method\n     * @returns {String} ordered item ids\n     * @public\n     */\n    this.getLayoutItemOrder = () => {\n      return getAllBlockItems({\n        layoutStructure: this.layout.layoutStructureRef.current\n      }).map(({ item }) => item);\n    };\n    /**\n     * Adjust layout item order synchronously\n     * @method\n     * @param {Number} currentOrder\n     * @param {Number} newOrder\n     * @returns {AbsoluteLayoutStructure} updated layout structure\n     * @public\n     */\n    this.adjustLayoutItemOrderSync = (currentOrder, newOrder, metadata) => {\n      this.emitTelemetry({\n        pageAction: \"adjustLayoutItemOrder\",\n        metadata\n      });\n      const blockItems = getAllBlockItems({\n        layoutStructure: this.layout.layoutStructureRef.current\n      });\n      const lineItems = getAllLineItems({\n        layoutStructure: this.layout.layoutStructureRef.current\n      });\n      const updatedBlockItems = moveLayoutItem(\n        blockItems,\n        currentOrder,\n        Math.min(newOrder, blockItems.length)\n      );\n      return [...lineItems, ...updatedBlockItems];\n    };\n    /**\n     * Adjust layout item order\n     * @method\n     * @param {Number} currentOrder\n     * @param {Number} newOrder\n     * @returns {Promise<AbsoluteLayoutStructure>} updated layout structure\n     * @public\n     */\n    this.adjustLayoutItemOrder = (currentOrder, newOrder, metadata) => __async(this, null, function* () {\n      return this.adjustLayoutItemOrderSync(currentOrder, newOrder, metadata);\n    });\n    /**\n     * Add a new layout item to the structure synchronously\n     * @method\n     * @param {Object} options\n     * @param {String} options.itemId\n     * @param {Object} options.vizContract\n     * @param {String} [options.type='block']\n     * @param {Object} options.config\n     * @returns {AbsoluteLayoutStructure} updated layout structure\n     * @public\n     */\n    this.addLayoutItemSync = ({\n      itemId,\n      vizContract,\n      type = \"block\",\n      config,\n      metadata\n    }) => {\n      this.emitTelemetry({\n        pageAction: \"addLayoutItem\",\n        metadata\n      });\n      return this.addLayoutItemsInternal({\n        items: [{ itemId, vizContract, type, config }]\n      });\n    };\n    /**\n     * Add a new layout item to the structure\n     * @method\n     * @param {Object} options\n     * @param {String} options.itemId\n     * @param {Object} options.vizContract\n     * @param {String} [options.type='block']\n     * @param {Object} options.config\n     * @returns {Promise<AbsoluteLayoutStructure>} updated layout structure\n     * @public\n     */\n    this.addLayoutItem = (_0) => __async(this, [_0], function* ({\n      itemId,\n      vizContract,\n      type = \"block\",\n      config,\n      metadata\n    }) {\n      return this.addLayoutItemSync({ itemId, vizContract, type, config, metadata });\n    });\n    /**\n     * Synchronously generate a new layout structure with one one or more items added\n     * @method addLayoutItemsSync\n     * @param {Object[]} items\n     * @param {Object} [metadata]\n     * @returns {AbsoluteLayoutStructure} New layout structure\n     * @public\n     */\n    this.addLayoutItemsSync = (items, metadata) => {\n      this.emitTelemetry({\n        pageAction: \"addLayoutItems\",\n        metadata\n      });\n      return this.addLayoutItemsInternal({ items });\n    };\n    /**\n     * Generate a new layout structure with one one or more items added\n     * @method addLayoutItems\n     * @param {Object[]} items\n     * @param {Object} [metadata]\n     * @returns {AbsoluteLayoutStructure} New layout structure\n     * @public\n     */\n    this.addLayoutItems = (items, metadata) => __async(this, null, function* () {\n      return this.addLayoutItemsSync(items, metadata);\n    });\n    /**\n     * Add multiple new layout items to the structure synchronously\n     * @method\n     * @param {Object} options\n     * @param {Object[]}} options.items\n     * @returns {AbsoluteLayoutStructure} updated layout structure\n     * @private\n     */\n    this.addLayoutItemsInternal = ({\n      items\n    }) => {\n      var _a, _b, _c, _d;\n      const width = (_b = (_a = this.options) == null ? void 0 : _a.width) != null ? _b : absoluteLayoutOptions.width;\n      const height = (_d = (_c = this.options) == null ? void 0 : _c.height) != null ? _d : absoluteLayoutOptions.height;\n      return items.reduce(\n        (proposedStructure, item) => {\n          var _a2;\n          const newStructureItem = (0, dashboard_utils_exports.computeNewAbsoluteStructureItem)(__spreadProps(__spreadValues({}, item), {\n            config: item.config,\n            type: (_a2 = item.type) != null ? _a2 : \"block\",\n            canvasWidth: width,\n            canvasHeight: height,\n            layoutItems: proposedStructure\n          }));\n          proposedStructure.push(newStructureItem);\n          return proposedStructure;\n        },\n        [...this.layout.layoutStructureRef.current]\n      );\n    };\n    /**\n     * Remove items from layout structure synchronously\n     * @method\n     * @param {String[]} [itemIds = []] IDs of items to be removed\n     * @param {Object} [metadata] Optional telemetry metadata\n     * @returns {AbsoluteLayoutStructure} Updated layout structure\n     * @public\n     */\n    this.removeLayoutItemsSync = (itemIds = [], metadata = void 0) => {\n      this.emitTelemetry({\n        pageAction: \"removeLayoutItems\",\n        metadata\n      });\n      const updatedItems = [];\n      this.layout.layoutStructureRef.current.forEach((item) => {\n        let iterItem = item;\n        if (item.type === \"line\") {\n          let updatedLine = item;\n          const absPos = computeLineAbsPosition({\n            layoutStructure: this.layout.layoutStructureRef.current,\n            position: updatedLine.position\n          });\n          if (\"item\" in updatedLine.position.from && itemIds.indexOf(updatedLine.position.from.item) >= 0) {\n            updatedLine = disconnectLine({\n              line: updatedLine,\n              dir: \"from\",\n              absPos: absPos.from\n            });\n          }\n          if (\"item\" in updatedLine.position.to && itemIds.indexOf(updatedLine.position.to.item) >= 0) {\n            updatedLine = disconnectLine({\n              line: updatedLine,\n              dir: \"to\",\n              absPos: absPos.to\n            });\n          }\n          iterItem = updatedLine;\n        }\n        if (itemIds.indexOf(iterItem.item) < 0) {\n          updatedItems.push(iterItem);\n        }\n      });\n      return updatedItems;\n    };\n    /**\n     * Remove items from layout structure\n     * @method\n     * @param {String[]} [itemIds = []] IDs of items to be removed\n     * @param {Object} [metadata] Optional telemetry metadata\n     * @returns {Promise<AbsoluteLayoutStructure>} Updated layout structure\n     * @public\n     */\n    this.removeLayoutItems = (..._0) => __async(this, [..._0], function* (itemIds = [], metadata = void 0) {\n      return this.removeLayoutItemsSync(itemIds, metadata);\n    });\n    /**\n     * Copies a layout item position and size and offsets by `2 * GRID_SIZE` synchronously\n     * @method\n     * @param {Object} config\n     * @param {Array} config.from List of original viz ids\n     * @param {Array} config.to List of new viz ids\n     * @param {Number} [config.offsetMultiplier=1] Number of grids to offset\n     * @returns {AbsoluteLayoutStructure} Layout structure of all known items\n     * @public\n     * @throws {Error} Will error if `from` or `to` is not an array, or `from.length` != `to.length`\n     */\n    this.cloneLayoutItemsSync = ({\n      from,\n      to,\n      offsetMultiplier = 1,\n      metadata\n    }) => {\n      if (!Array.isArray(from) || !Array.isArray(to) || from.length !== to.length) {\n        throw new Error(\n          `Cannot clone item, incorrect inputs from ${from}, to: ${to}`\n        );\n      }\n      this.emitTelemetry({\n        pageAction: \"cloneLayoutItems\",\n        metadata\n      });\n      const currentStructure = Object.fromEntries(\n        Object.values(this.layout.layoutStructureRef.current).map(\n          (item) => [item.item, item]\n        )\n      );\n      const newLayoutItems = [];\n      from.forEach((copyItemId, idx) => {\n        const item = currentStructure[copyItemId];\n        if (!item) {\n          return;\n        }\n        if ((0, dashboard_utils_exports.isBlockItem)(item)) {\n          const clonedBlockItem = cloneBlockItem({\n            id: to[idx],\n            item,\n            offsetMultiplier\n          });\n          newLayoutItems.push(clonedBlockItem);\n        } else if (item.type === \"line\") {\n          const linePosition = computeLineAbsPosition({\n            layoutStructure: this.layout.layoutStructureRef.current,\n            position: item.position\n          });\n          const clonedLine = cloneLine({\n            id: to[idx],\n            item: {\n              item: copyItemId,\n              type: \"line\",\n              position: linePosition\n            },\n            offsetMultiplier\n          });\n          newLayoutItems.push(clonedLine);\n        }\n      });\n      return [...this.layout.layoutStructureRef.current, ...newLayoutItems];\n    };\n    /**\n     * Copies a layout item position and size and offsets by 2 * GRID_SIZE\n     * @method\n     * @param {Object} config\n     * @param {Array} config.from List of original viz ids\n     * @param {Array} config.to List of new viz ids\n     * @param {Number} [config.offsetMultiplier=1] Number of grids to offset\n     * @returns {AbsoluteLayoutStructure} Layout structure of all known items\n     * @public\n     */\n    this.cloneLayoutItems = (_0) => __async(this, [_0], function* ({\n      from,\n      to,\n      offsetMultiplier = 1,\n      metadata\n    }) {\n      return this.cloneLayoutItemsSync({ from, to, offsetMultiplier, metadata });\n    });\n    /**\n     * get dashboard canvas dom element\n     */\n    this.getCanvasDomElement = () => {\n      return this.layout.getCanvasDomElement();\n    };\n    /**\n     * return snapshot of that includes inlined background image\n     * @method\n     * @returns {Object} Updated Layout options with encoded background image\n     * @public\n     */\n    this.snapshot = () => {\n      var _a, _c;\n      const _b = (_a = this.options) != null ? _a : {}, { backgroundImage: imgFromOpts } = _b, opts = __objRest(_b, [\"backgroundImage\"]);\n      const srcFromOptions = (_c = imgFromOpts == null ? void 0 : imgFromOpts.src) != null ? _c : \"\";\n      const srcFromImageRegistry = isFromImageRegistry(srcFromOptions);\n      const backgroundImage = imgFromOpts ? {\n        backgroundImage: __spreadProps(__spreadValues({}, imgFromOpts), {\n          src: srcFromImageRegistry ? this.layout.getBgImageSrc() : srcFromOptions\n        })\n      } : {};\n      return {\n        options: __spreadValues(__spreadValues({}, opts != null ? opts : {}), backgroundImage)\n      };\n    };\n    /**\n     * Sets dashboard scale\n     * @param {Number} scale New scale as floating point number\n     */\n    this.setScale = (scale) => {\n      return this.layout.setScale(scale);\n    };\n    /**\n     * Increases dashboard zoom level for one step\n     */\n    this.zoomIn = () => {\n      return this.layout.zoomIn();\n    };\n    /**\n     * Decreases dashboard zoom level for one step\n     */\n    this.zoomOut = () => {\n      return this.layout.zoomOut();\n    };\n    /**\n     * Adjust dashboard's scale to fit the width of the container\n     */\n    this.fitToWidth = (maxScale = Infinity) => {\n      return this.layout.setFitToWidthAndScrollToTopLeft(maxScale);\n    };\n    /**\n     * @returns {Object} Observable that tracks zoom level changes or null if zoom is unsupported\n     */\n    this.getZoomLevel = () => {\n      return this.layout.getZoomObserver();\n    };\n    this.layout = layout;\n    this.telemetry = telemetry;\n    Object.defineProperty(this, \"options\", {\n      get() {\n        var _a2;\n        return (_a2 = this.layout.optionsRef) == null ? void 0 : _a2.current;\n      }\n    });\n  }\n};\nvar AbsoluteLayoutApi_default = AbsoluteLayoutApi;\n\n// src/GridLayoutConstants.ts\nvar CLONE_LAYOUT_ITEMS_MSG_PANEL_TOO_SMALL = (0, i18n_exports._)(\n  \"This panel is too small to be split into duplicates. Stretch or move the panel to make it bigger first.\"\n);\nvar EDGE_THICKNESS_PX = 4;\nvar GRID_PADDING_PX = 1;\nvar GRID_SIZE_PX = 10;\nvar MIN_HEIGHT_PX = 64;\nvar MIN_WIDTH_PX = 64;\nvar SNAP_RANGE_PX = 8;\nvar PLACEHOLDER_SIZE_PX = 128;\nvar ITEM_DROP_TARGET_PX = 12;\nvar VIZ_DEFAULT_HEIGHT_PX = 400;\nvar VIZ_PREVIEW_DELAY_MS = 50;\nvar EDGE_PREVIEW_DELAY_MS = 500;\n\n// src/apis/GridLayoutApi.ts\nvar empty = {};\nvar GridLayoutApi = class extends BaseLayoutApi_default {\n  constructor({\n    layoutStructureRef,\n    options = empty,\n    userMessage,\n    onItemAdded,\n    getCanvasDomElement,\n    telemetry\n  }) {\n    super();\n    /**\n     * Add a new item to grid layout synchronously\n     * @method\n     * @param {Object} options\n     * @param {String} options.itemId visualization id\n     * @returns {Object[]} updated layout structure\n     * @public\n     */\n    this.addLayoutItemSync = ({\n      itemId,\n      type = \"block\",\n      metadata\n    }) => {\n      this.emitTelemetry({\n        pageAction: \"addLayoutItem\",\n        metadata\n      });\n      return this.addLayoutItemsInternal({ items: [{ itemId, type }] });\n    };\n    /**\n     * Add a new item to grid layout\n     * @method\n     * @param {Object} options\n     * @param {String} options.itemId visualization id\n     * @returns {Object[]} updated layout structure\n     * @public\n     */\n    this.addLayoutItem = ({\n      itemId,\n      type = \"block\",\n      metadata\n    }) => this.addLayoutItemSync({ itemId, type, metadata });\n    /**\n     * @method addLayoutItemsSync\n     * Synchronously generate a new layout structure with one one or more items added\n     * @param {Object[]} items\n     * @param {Object} [metadata]\n     * @returns {GridLayoutStructure} New layout structure\n     * @public\n     */\n    this.addLayoutItemsSync = (items, metadata) => {\n      this.emitTelemetry({\n        pageAction: \"addLayoutItems\",\n        metadata\n      });\n      return this.addLayoutItemsInternal({ items });\n    };\n    /**\n     * @method addLayoutItems\n     * Generate a new layout structure with one one or more items added\n     * @param {Object[]} items\n     * @param {Object} [metadata]\n     * @returns {GridLayoutStructure} New layout structure\n     * @public\n     */\n    this.addLayoutItems = (items, metadata) => this.addLayoutItemsSync(items, metadata);\n    /**\n     * Add multiple new items to grid layout\n     * @method\n     * @param {Object} options\n     * @param {Object[]} options.items item data\n     * @returns {Object[]} updated layout structure\n     * @private\n     */\n    this.addLayoutItemsInternal = ({\n      items\n    }) => {\n      var _a;\n      const width = (_a = this.options.width) != null ? _a : gridLayoutOptions.width;\n      const proposedLayoutStructure = items.reduce(\n        (structure, { itemId, type }) => {\n          const newStructureItem = (0, dashboard_utils_exports.computeNewGridStructureItem)({\n            itemId,\n            type: type != null ? type : \"block\",\n            canvasWidth: width,\n            layoutItems: structure\n          });\n          structure.push(newStructureItem);\n          return structure;\n        },\n        [...this.layoutStructureRef.current]\n      );\n      this.onItemAdded();\n      return proposedLayoutStructure;\n    };\n    /**\n     * Remove item specified in itemIds list synchronously\n     * Note: Only removes one item even though it accepts a list of item ids.\n     * @method\n     * @param {string[]} item ids to remove.\n     * @returns {object[]} updated layout structure\n     * @public\n     */\n    this.removeLayoutItemsSync = (itemIds = [], metadata = void 0) => {\n      var _a;\n      this.emitTelemetry({\n        pageAction: \"removeLayoutItems\",\n        metadata\n      });\n      const items = this.layoutStructureRef.current;\n      let itemToRemove;\n      try {\n        itemToRemove = getBlockItem({\n          layoutStructure: items,\n          id: itemIds[0]\n        });\n      } catch (e) {\n        return items;\n      }\n      const width = (_a = this.options.width) != null ? _a : gridLayoutOptions.width;\n      const updatedItems = (0, dashboard_utils_exports.updateRemovedVizNeighbors)({\n        itemToRemove,\n        items,\n        width\n      });\n      const keys = updatedItems.map((item) => item.item);\n      const filteredItems = items.filter(\n        (vizItem) => vizItem.item !== itemToRemove.item && keys.indexOf(vizItem.item) < 0\n      );\n      return [...updatedItems, ...filteredItems];\n    };\n    /**\n     * Remove item specified in itemIds list.\n     * Note: Only removes one item even though it accepts a list of item ids.\n     * @method\n     * @param {string[]} item ids to remove.\n     * @returns {object[]} updated layout structure\n     * @public\n     */\n    this.removeLayoutItems = (itemIds = [], metadata = void 0) => this.removeLayoutItemsSync(itemIds, metadata);\n    /**\n     * There are 3 actors in this cloning algorithm:\n     * 1. Clone Ancestor\n     * 2. Left-side Descendant\n     * 3. Right-side Descendant\n     * @method\n     * @param {Object} options\n     * @param {String[]} options.from List of original viz ids (ancestors). These id's will be re-used to produce left-side descendants.\n     * @param {String[]} options.to List of new viz ids. Has the id's of right-side descendants.\n     * @returns {Object[]} Layout structure of all known items\n     * @public\n     */\n    this.cloneLayoutItemsSync = ({\n      from,\n      to,\n      metadata\n    }) => {\n      if (!Array.isArray(from) || !Array.isArray(to) || from.length !== to.length) {\n        throw new Error(\n          `Cannot clone viz, incorrect inputs from ${from}, to: ${to}`\n        );\n      }\n      this.emitTelemetry({\n        pageAction: \"cloneLayoutItems\",\n        metadata\n      });\n      const items = this.layoutStructureRef.current;\n      return from.reduce((accumulator, fromItemId, index) => {\n        const ancestor = getBlockItem({\n          layoutStructure: items,\n          id: fromItemId\n        });\n        if (ancestor.position.w < MIN_WIDTH_PX * 2) {\n          this.userMessage({\n            message: CLONE_LAYOUT_ITEMS_MSG_PANEL_TOO_SMALL,\n            level: \"warning\",\n            sender: \"GridLayoutApi\"\n          });\n          return accumulator;\n        }\n        const lsDescendant = updateBlockItemSize({\n          item: __spreadValues({}, ancestor),\n          offset: {\n            offsetX: -1 * Math.floor(ancestor.position.w / 2),\n            offsetY: 0\n          },\n          dir: \"e\"\n        });\n        const rsDescendant = updateBlockItemSize({\n          item: __spreadProps(__spreadValues({}, ancestor), {\n            item: to[index]\n          }),\n          offset: {\n            offsetX: Math.ceil(ancestor.position.w / 2),\n            offsetY: 0\n          },\n          dir: \"w\"\n        });\n        const accumulatorSansAncestor = (0, lodash_exports.reject)(accumulator, {\n          item: fromItemId\n        });\n        return [...accumulatorSansAncestor, lsDescendant, rsDescendant];\n      }, items);\n    };\n    /**\n     * There are 3 actors in this cloning algorithm:\n     * 1. Clone Ancestor\n     * 2. Left-side Descendant\n     * 3. Right-side Descendant\n     * @method\n     * @param {Object} options\n     * @param {String[]} options.from List of original viz ids (ancestors). These id's will be re-used to produce left-side descendants.\n     * @param {String[]} options.to List of new viz ids. Has the id's of right-side descendants.\n     * @returns {Object[]} Layout structure of all known items\n     * @public\n     */\n    this.cloneLayoutItems = ({\n      from,\n      to,\n      metadata\n    }) => this.cloneLayoutItemsSync({ from, to, metadata });\n    /**\n     * Return snapshot as an empty object for the time being\n     * @method\n     */\n    // eslint-disable-next-line class-methods-use-this\n    this.snapshot = () => {\n      return {};\n    };\n    /**\n     * Return zoom level as null for now\n     * @method\n     */\n    // eslint-disable-next-line class-methods-use-this\n    this.getZoomLevel = () => {\n      return null;\n    };\n    this.layoutStructureRef = layoutStructureRef;\n    this.options = options;\n    this.userMessage = userMessage;\n    this.onItemAdded = onItemAdded;\n    this.getCanvasDomElement = getCanvasDomElement;\n    this.telemetry = telemetry;\n  }\n};\nvar GridLayoutApi_default = GridLayoutApi;\n\n// esm-externals:styled-components\nvar styled_components_exports = {};\n__export(styled_components_exports, {\n  default: () => styled_components_default\n});\nvar defaultImport10 = __toESM(require(\"styled-components\"));\n__reExport(styled_components_exports, require(\"styled-components\"));\nvar styled_components_default = \"default\" in defaultImport10 ? defaultImport10.default : defaultImport10;\n\n// esm-externals:@splunk/themes\nvar themes_exports = {};\n__export(themes_exports, {\n  default: () => themes_default\n});\nvar defaultImport11 = __toESM(require(\"@splunk/themes\"));\n__reExport(themes_exports, require(\"@splunk/themes\"));\nvar themes_default = \"default\" in defaultImport11 ? defaultImport11.default : defaultImport11;\n\n// src/hooks/useBackgroundImage.ts\nvar useBackgroundImage = (backgroundImageSrc) => {\n  const [imageSrc, setImageSrc] = (0, react_exports.useState)(\"\");\n  const imageRegistry = (0, dashboard_context_exports.useImageRegistry)();\n  const fetchBackgroundImage = (registry, bgImageSrc) => __async(void 0, null, function* () {\n    try {\n      if (registry) {\n        if (registry.isResourceURL(bgImageSrc)) {\n          const imageObject = yield registry.getByURL(bgImageSrc);\n          setImageSrc(imageObject.dataURI);\n        } else {\n          setImageSrc(bgImageSrc);\n        }\n      } else {\n        setImageSrc(bgImageSrc);\n      }\n    } catch (error) {\n      dashboard_utils_exports.console.error(error);\n    }\n  });\n  (0, react_exports.useEffect)(() => {\n    if (backgroundImageSrc) {\n      fetchBackgroundImage(\n        imageRegistry,\n        backgroundImageSrc\n      );\n    } else {\n      setImageSrc(\"\");\n    }\n  }, [imageRegistry, backgroundImageSrc]);\n  return imageSrc;\n};\n\n// esm-externals:@splunk/dashboard-state\nvar dashboard_state_exports = {};\n__export(dashboard_state_exports, {\n  default: () => dashboard_state_default\n});\nvar defaultImport12 = __toESM(require(\"@splunk/dashboard-state\"));\n__reExport(dashboard_state_exports, require(\"@splunk/dashboard-state\"));\nvar dashboard_state_default = \"default\" in defaultImport12 ? defaultImport12.default : defaultImport12;\n\n// src/utils/showHideUtils.ts\nvar hasNoResults = (searchData) => {\n  var _a, _b, _c;\n  if (typeof searchData === \"undefined\") {\n    return true;\n  }\n  return ((_b = (_a = searchData.meta) == null ? void 0 : _a.totalCount) != null ? _b : 0) === 0 && ((_c = searchData == null ? void 0 : searchData.meta) == null ? void 0 : _c.status) !== \"refreshing\";\n};\nvar shouldHideItem = ({\n  item,\n  definition,\n  searchData\n}) => {\n  var _a, _b, _c, _d;\n  if (item.type === \"line\") {\n    return false;\n  }\n  const hideWhenNoData = !!definition.hideWhenNoData || !!((_b = (_a = definition.containerOptions) == null ? void 0 : _a.visibility) == null ? void 0 : _b.hideWhenNoData);\n  if (hideWhenNoData && hasNoResults(searchData)) {\n    return true;\n  }\n  if (((_c = definition.containerOptions) == null ? void 0 : _c.visibility) && \"hideInViewMode\" in definition.containerOptions.visibility && !!((_d = definition.containerOptions.visibility) == null ? void 0 : _d.hideInViewMode)) {\n    return true;\n  }\n  return false;\n};\n\n// src/hooks/useLayoutShowHide.ts\nvar useLayoutShowHide = (layoutStructure, handleReflow) => {\n  const allVizs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectVisualizations);\n  const allInputs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectInputs);\n  const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);\n  const subscriptions = (0, dashboard_ui_exports.useBatchSubscribeToSearches)({\n    consumerId: \"<layout>\"\n  });\n  const { enableShowHide } = (0, dashboard_context_exports.useFeatureFlags)();\n  return (0, react_exports.useMemo)(() => {\n    if (!enableShowHide || mode === \"edit\") {\n      return layoutStructure;\n    }\n    const itemsToRemove = [];\n    const filteredStructure = layoutStructure.filter((item) => {\n      var _a;\n      if (shouldHideItem({\n        item,\n        definition: (_a = allVizs[item.item]) != null ? _a : allInputs == null ? void 0 : allInputs[item.item],\n        searchData: subscriptions[item.item]\n      })) {\n        itemsToRemove.push(item);\n        return false;\n      }\n      return true;\n    });\n    return itemsToRemove.length && handleReflow ? handleReflow(layoutStructure, itemsToRemove) : filteredStructure;\n  }, [\n    allInputs,\n    allVizs,\n    enableShowHide,\n    mode,\n    subscriptions,\n    handleReflow,\n    layoutStructure\n  ]);\n};\n\n// src/hooks/useMouseDownWithHandleEventListeners.ts\nvar useMouseDownWithHandleEventListeners = ({\n  handleMouseDownOnItem,\n  canvasRef,\n  scale,\n  setStartPosition,\n  movable,\n  setIsMoving,\n  isMovingRef\n}) => {\n  const handleMouseDownOnVizWithHandle = (0, dashboard_ui_exports.useEventCallback)(\n    (e) => {\n      const { vizId, initialEvent, type } = e.detail;\n      const pos = computeRelativePosition(initialEvent, canvasRef, scale);\n      setStartPosition(pos);\n      const block = {\n        id: vizId,\n        type\n      };\n      handleMouseDownOnItem(initialEvent, block);\n    }\n  );\n  const handleMouseDownOnHandle = (0, dashboard_ui_exports.useEventCallback)((e) => {\n    const { vizId, initialEvent, type } = e.detail;\n    const pos = computeRelativePosition(initialEvent, canvasRef, scale);\n    setStartPosition(pos);\n    const block = {\n      id: vizId,\n      type\n    };\n    handleMouseDownOnItem(initialEvent, block);\n    if (movable) {\n      setIsMoving(true);\n      if (isMovingRef) {\n        isMovingRef.current = true;\n      }\n    }\n  });\n  (0, dashboard_ui_exports.useEventListener)({\n    eventName: dashboard_ui_exports.EVENT_MOUSE_DOWN_ON_VIZ_WITH_HANDLE,\n    target: document,\n    listener: handleMouseDownOnVizWithHandle\n  });\n  (0, dashboard_ui_exports.useEventListener)({\n    eventName: dashboard_ui_exports.EVENT_MOUSE_DOWN_ON_HANDLE,\n    target: document,\n    listener: handleMouseDownOnHandle\n  });\n};\n\n// src/components/Canvas.tsx\nvar GRID_LINE_OPACITY = 0.1;\nvar toBackgroundImageSize = (props) => {\n  var _a;\n  const { width, height } = getImageDimension((_a = props.bgImageSrc) != null ? _a : \"\");\n  if (props.bgImageWidth && props.bgImageHeight) {\n    return `${(0, dashboard_utils_exports.toPx)(props.bgImageWidth)} ${(0, dashboard_utils_exports.toPx)(props.bgImageHeight)}`;\n  }\n  if (props.bgImageWidth || props.bgImageHeight) {\n    return `${(0, dashboard_utils_exports.toPx)(props.bgImageWidth || width)} ${(0, dashboard_utils_exports.toPx)(\n      props.bgImageHeight || height\n    )}`;\n  }\n  if (props.bgImageSizeType) {\n    return props.bgImageSizeType;\n  }\n  return \"contain\";\n};\nvar toBackgroundImage = (props) => {\n  if (props.bgImageSrc) {\n    return `\n            background-repeat: no-repeat;\n            background-image: url(\"${props.bgImageSrc}\");\n            background-size: ${toBackgroundImageSize(props)};\n            background-position:\n                ${(0, dashboard_utils_exports.toPx)(props.bgImagePositionX)} ${(0, dashboard_utils_exports.toPx)(props.bgImagePositionY)};\n        `;\n  }\n  return \"\";\n};\nvar toScale = (scale) => scale ? {\n  transform: `scale(${scale})`,\n  transformOrigin: \"0 0\",\n  width: `${100 / scale}%`\n} : {\n  width: \"100%\"\n};\nvar CanvasContainer = styled_components_default.div.attrs((props) => ({\n  style: { width: props.width, height: props.height }\n}))`\n    ${themes_exports.mixins.reset(\"block\")};\n    overflow: ${(prop) => prop.showOverflowContent ? \"visible\" : \"hidden\"};\n    user-select: ${(prop) => prop.userSelect ? \"text\" : \"none\"};\n    position: relative;\n`;\nvar Background = styled_components_default.div.attrs((props) => ({\n  style: __spreadValues({\n    height: props.height\n  }, toScale(props.scale))\n}))`\n    ${themes_exports.mixins.reset(\"inline-block\")};\n    position: relative;\n    background: ${(prop) => prop.bgColor || // NOTE: this needs to match packages/dashboard-editors/src/layouts/AbsoluteLayoutEditor.jsx\ndashboard_ui_exports.customThemeVariables.dashboardBackgroundColor};\n    ${(prop) => toBackgroundImage(prop)};\n`;\nvar Border = styled_components_default.div.attrs((props) => ({\n  style: { width: props.width, height: props.height }\n}))`\n    position: absolute;\n    box-sizing: border-box;\n    border: 2px dashed\n        ${(0, themes_exports.pick)({\n  enterprise: {\n    light: themes_exports.variables.gray80,\n    dark: themes_exports.variables.gray30\n  },\n  prisma: themes_exports.variables.interactiveColorBorder\n})};\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n`;\nvar getGridLineColor = (props) => props.gridLineColor || (0, themes_exports.pick)({\n  light: \"#D8D8D8\",\n  dark: \"#9B9B9B\"\n});\nvar GridLines = styled_components_default.div`\n    position: absolute;\n    box-sizing: border-box;\n    left: 0px;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    opacity: ${(prop) => prop.gridLineOpacity || GRID_LINE_OPACITY};\n    ${(prop) => (0, dashboard_utils_exports.toDimension)({ width: prop.width, height: prop.height })};\n    background-size: ${(prop) => prop.gridWidth + prop.gridLineWidth}px\n        ${(prop) => prop.gridHeight + prop.gridLineWidth}px;\n    background-image: repeating-linear-gradient(\n            0deg,\n            ${getGridLineColor},\n            ${getGridLineColor} ${(prop) => (0, dashboard_utils_exports.toPx)(prop.gridLineWidth)},\n            transparent ${(prop) => prop.gridLineWidth}px,\n            transparent ${(prop) => prop.gridHeight + prop.gridLineWidth}px\n        ),\n        repeating-linear-gradient(\n            -90deg,\n            ${getGridLineColor},\n            ${getGridLineColor} ${(prop) => (0, dashboard_utils_exports.toPx)(prop.gridLineWidth)},\n            transparent ${(prop) => prop.gridLineWidth}px,\n            transparent ${(prop) => prop.gridWidth + prop.gridLineWidth}px\n        );\n`;\nvar Canvas = (_a, canvasRef) => {\n  var _b = _a, {\n    width,\n    height,\n    scale,\n    backgroundColor: unsanitizedBgColor = \"\",\n    backgroundImageSrc,\n    backgroundImageSizeType,\n    backgroundImageWidth,\n    backgroundImageHeight,\n    backgroundImagePositionX,\n    backgroundImagePositionY,\n    gridLineOpacity,\n    children,\n    showOverflowContent = false,\n    userSelect = false,\n    showGrid = false,\n    gridPadding = 0,\n    gridLineWidth = 1,\n    gridLineColor,\n    gridWidth = 9,\n    gridHeight = 9,\n    showBorder = false,\n    cssScaling = true\n  } = _b, others = __objRest(_b, [\n    \"width\",\n    \"height\",\n    \"scale\",\n    \"backgroundColor\",\n    \"backgroundImageSrc\",\n    \"backgroundImageSizeType\",\n    \"backgroundImageWidth\",\n    \"backgroundImageHeight\",\n    \"backgroundImagePositionX\",\n    \"backgroundImagePositionY\",\n    \"gridLineOpacity\",\n    \"children\",\n    \"showOverflowContent\",\n    \"userSelect\",\n    \"showGrid\",\n    \"gridPadding\",\n    \"gridLineWidth\",\n    \"gridLineColor\",\n    \"gridWidth\",\n    \"gridHeight\",\n    \"showBorder\",\n    \"cssScaling\"\n  ]);\n  const imageSrc = useBackgroundImage(backgroundImageSrc);\n  const containerWidth = scale != null ? width * scale : width;\n  const containerHeight = scale != null && cssScaling ? height * scale : height;\n  const backgroundColor = (0, dashboard_ui_exports.sanitizeColor)(unsanitizedBgColor);\n  return /* @__PURE__ */ react_default.createElement(\n    CanvasContainer,\n    __spreadValues({\n      \"data-test\": \"canvas-container\",\n      \"data-width\": containerWidth,\n      \"data-height\": containerHeight,\n      width: cssScaling ? containerWidth : width,\n      height: containerHeight,\n      showOverflowContent,\n      userSelect,\n      ref: canvasRef\n    }, others),\n    /* @__PURE__ */ react_default.createElement(\n      Background,\n      {\n        \"data-test\": \"canvas\",\n        \"data-width\": width,\n        \"data-height\": height,\n        \"data-scale\": scale,\n        height,\n        scale: cssScaling ? scale : void 0,\n        bgColor: backgroundColor,\n        bgImageSrc: imageSrc,\n        bgImageSizeType: backgroundImageSizeType,\n        bgImageWidth: backgroundImageWidth,\n        bgImageHeight: backgroundImageHeight,\n        bgImagePositionX: backgroundImagePositionX,\n        bgImagePositionY: backgroundImagePositionY\n      },\n      showBorder && /* @__PURE__ */ react_default.createElement(Border, { width, height }),\n      showGrid && /* @__PURE__ */ react_default.createElement(\n        GridLines,\n        {\n          \"data-test\": \"gridlines\",\n          width,\n          height,\n          gridLineOpacity,\n          gridPadding,\n          gridLineWidth,\n          gridLineColor,\n          gridWidth,\n          gridHeight\n        }\n      ),\n      children\n    )\n  );\n};\nvar Canvas_default = (0, react_exports.forwardRef)(Canvas);\n\n// esm-externals:prop-types\nvar prop_types_exports = {};\n__export(prop_types_exports, {\n  default: () => prop_types_default\n});\nvar defaultImport13 = __toESM(require(\"prop-types\"));\n__reExport(prop_types_exports, require(\"prop-types\"));\nvar prop_types_default = \"default\" in defaultImport13 ? defaultImport13.default : defaultImport13;\n\n// src/components/SelectBox.jsx\nvar SelectDiv = styled_components_default.div.attrs(({ x, y, w, h }) => ({\n  style: {\n    width: w,\n    height: h,\n    transform: `translate(${x}px, ${y}px)`\n  }\n}))`\n    ${themes_exports.mixins.reset(\"block\")};\n    position: absolute;\n    background: transparent;\n    // the next line is important to avoid blocking the drilldowns, and it allows to select text from visualizations\n    pointer-events: none;\n    border: 1px solid\n        ${(0, themes_exports.pick)({\n  enterprise: themes_exports.variables.accentColorL10,\n  prisma: themes_exports.variables.interactiveColorPrimary\n})};\n    z-index: 1000;\n`;\nvar SelectBox = ({ start, end }) => /* @__PURE__ */ react_default.createElement(\n  SelectDiv,\n  {\n    w: Math.abs(start.x - end.x),\n    h: Math.abs(start.y - end.y),\n    x: Math.min(start.x, end.x),\n    y: Math.min(start.y, end.y)\n  }\n);\nSelectBox.propTypes = {\n  /**\n   * starting position\n   */\n  start: prop_types_default.shape({\n    x: prop_types_default.number,\n    y: prop_types_default.number\n  }),\n  /**\n   * end position\n   */\n  end: prop_types_default.shape({\n    x: prop_types_default.number,\n    y: prop_types_default.number\n  })\n};\nvar SelectBox_default = SelectBox;\n\n// src/utils/findStatusIcon.ts\nvar findStatusIcon = ({\n  canvasRef,\n  id\n}) => {\n  const canvas = canvasRef == null ? void 0 : canvasRef.current;\n  if (!canvas) {\n    return null;\n  }\n  return canvas.querySelector(\n    `[data-id=\"${id}\"] [data-test=\"simple-status-icon-container\"]`\n  );\n};\n\n// src/components/AbsoluteCanvas.tsx\nvar defaultState = {\n  startPosition: null,\n  currentPosition: null,\n  isMoving: false,\n  isSelecting: false\n};\nvar DEFAULT_SELECTED_LAYOUT_ITEMS = [];\nvar AbsoluteCanvas = (props) => {\n  const _a = props, {\n    scale,\n    children,\n    canvasRef,\n    blockItems,\n    onItemMove = dashboard_utils_exports.noop,\n    onItemMoved = dashboard_utils_exports.noop,\n    onItemSelected,\n    movable = false,\n    allowMultiselect,\n    selectedLayoutItems = DEFAULT_SELECTED_LAYOUT_ITEMS,\n    initialState = defaultState,\n    onMouseDownCapture,\n    onMouseUpCapture\n  } = _a, canvasProps = __objRest(_a, [\n    \"scale\",\n    \"children\",\n    \"canvasRef\",\n    \"blockItems\",\n    \"onItemMove\",\n    \"onItemMoved\",\n    \"onItemSelected\",\n    \"movable\",\n    \"allowMultiselect\",\n    \"selectedLayoutItems\",\n    \"initialState\",\n    \"onMouseDownCapture\",\n    \"onMouseUpCapture\"\n  ]);\n  const [startPosition, setStartPosition] = (0, react_exports.useState)(\n    initialState.startPosition\n  );\n  const [currentPosition, setCurrentPosition] = (0, react_exports.useState)(\n    initialState.currentPosition\n  );\n  const [isMoving, setIsMoving] = (0, react_exports.useState)(initialState.isMoving);\n  const [isSelecting, setIsSelecting] = (0, react_exports.useState)(initialState.isSelecting);\n  const isMovingRef = (0, react_exports.useRef)(false);\n  const profiler = (0, dashboard_telemetry_exports.useDashboardProfiler)();\n  const resetState = (0, react_exports.useCallback)(() => {\n    setStartPosition(defaultState.startPosition);\n    setCurrentPosition(defaultState.currentPosition);\n    setIsMoving(defaultState.isMoving);\n    setIsSelecting(defaultState.isSelecting);\n    isMovingRef.current = false;\n  }, []);\n  (0, react_exports.useEffect)(() => {\n    if (isMovingRef.current && blockItems && (profiler == null ? void 0 : profiler.hasPartialMeasurement(dashboard_telemetry_exports.VIZ_MOVE_EVENT))) {\n      profiler == null ? void 0 : profiler.endMeasurement(dashboard_telemetry_exports.VIZ_MOVE_EVENT);\n    }\n  }, [blockItems, profiler]);\n  (0, react_exports.useEffect)(() => {\n    if (selectedLayoutItems.length) {\n      profiler == null ? void 0 : profiler.emitAndClearTimer({\n        timerName: dashboard_telemetry_exports.VIZ_SELECT_EVENT,\n        metadata: {\n          numOfSelectedItems: selectedLayoutItems.length\n        }\n      });\n    }\n  }, [profiler, selectedLayoutItems]);\n  const handleItemSelected = (0, react_exports.useCallback)(\n    (e, itemIds = []) => {\n      if (itemIds.some(\n        ({ id, type }) => {\n          var _a2;\n          return type === \"input\" && ((_a2 = findStatusIcon({ canvasRef, id })) == null ? void 0 : _a2.contains(e.target));\n        }\n      )) {\n        return;\n      }\n      profiler == null ? void 0 : profiler.startTimer({\n        timerName: dashboard_telemetry_exports.VIZ_SELECT_EVENT\n      });\n      const isMacOS = (0, dashboard_utils_exports.isMac)();\n      if (isMacOS && e.metaKey || !isMacOS && e.ctrlKey) {\n        const selectedItems = selectedLayoutItems.filter(\n          ({ type }) => type === \"block\" || type === \"input\"\n        );\n        onItemSelected(e, (0, lodash_exports.uniqBy)([...selectedItems, ...itemIds], \"id\"));\n      } else {\n        onItemSelected(e, itemIds);\n      }\n    },\n    [canvasRef, profiler, selectedLayoutItems, onItemSelected]\n  );\n  const handleMouseDownOnItem = (0, react_exports.useCallback)(\n    (event, blockItem) => {\n      const { id, type = \"block\" } = blockItem;\n      if (!selectedLayoutItems.find(\n        ({ id: selectedId }) => selectedId === id\n      )) {\n        handleItemSelected(event, [{ id, type }]);\n      }\n    },\n    [handleItemSelected, selectedLayoutItems]\n  );\n  const handleMouseMove = (0, dashboard_ui_exports.useEventCallback)((e) => {\n    if (!startPosition) {\n      return;\n    }\n    const newPosition = computeRelativePosition(e, canvasRef, scale);\n    const offset = getOffset(newPosition, startPosition);\n    if (isMoving && considerMoved(offset)) {\n      e.stopImmediatePropagation();\n      e.preventDefault();\n      onItemMove(e, offset);\n    }\n    setCurrentPosition(newPosition);\n  });\n  const handleMouseUp = (0, dashboard_ui_exports.useEventCallback)((e) => {\n    if (!startPosition) {\n      return;\n    }\n    e.preventDefault();\n    const curPosition = computeRelativePosition(e, canvasRef, scale);\n    const offset = getOffset(curPosition, startPosition);\n    const isMoved = considerMoved(offset);\n    if (isMoving && isMoved) {\n      isMovingRef.current = false;\n      onItemMoved(e, offset);\n    } else if (isSelecting) {\n      const boundary = positionsToBoundary(startPosition, curPosition);\n      const selectedBlocks = filterBlockItemsByBoundary(\n        blockItems,\n        boundary\n      ).map(({ item, type = \"block\" }) => ({\n        id: item,\n        type\n      }));\n      let selectedBlockItems = [];\n      if (!isMoved && selectedBlocks.length) {\n        selectedBlockItems.push((0, lodash_exports.last)(selectedBlocks));\n      } else {\n        selectedBlockItems = selectedBlocks;\n      }\n      handleItemSelected(e, selectedBlockItems);\n    } else {\n      const { item, type = \"block\" } = findTopBlockItemByPosition(blockItems, curPosition) || {};\n      if (item && !(selectedLayoutItems.length === 1 && selectedLayoutItems[0].id === item) && !isMoved) {\n        handleItemSelected(e, [{ id: item, type }]);\n      } else if (!item && !findTopBlockItemByPosition(blockItems, startPosition)) {\n        handleItemSelected(e, []);\n      }\n    }\n    resetState();\n  });\n  const handleMouseDown = (0, dashboard_ui_exports.useEventCallback)((e, selectedBlockItem) => {\n    const pos = computeRelativePosition(e, canvasRef, scale);\n    setStartPosition(pos);\n    const block = selectedBlockItem != null ? selectedBlockItem : findTopBlockItemByPosition(blockItems, pos);\n    if (!block) {\n      if (allowMultiselect) {\n        setIsSelecting(true);\n      }\n      return;\n    }\n    const { item, type } = block;\n    handleMouseDownOnItem(e, {\n      id: item,\n      type\n    });\n    if (movable) {\n      setIsMoving(true);\n      isMovingRef.current = true;\n    }\n  });\n  const handleMouseDownCapture = (0, dashboard_ui_exports.useEventCallback)((e) => {\n    onMouseDownCapture == null ? void 0 : onMouseDownCapture(e);\n    const pos = computeRelativePosition(e, canvasRef, scale);\n    const selectedBlockItems = blockItems.filter(\n      (item) => selectedLayoutItems.some(\n        (selectedItem) => selectedItem.id === item.item\n      )\n    );\n    const topSelectedBlock = findTopBlockItemByPosition(\n      selectedBlockItems,\n      pos\n    );\n    const topBlock = findTopBlockItemByPosition(blockItems, pos);\n    if (topSelectedBlock && topSelectedBlock !== topBlock) {\n      handleMouseDown(e, topSelectedBlock);\n      e.stopPropagation();\n      e.preventDefault();\n    }\n  });\n  (0, react_exports.useEffect)(() => {\n    document.addEventListener(\"mousemove\", handleMouseMove, true);\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove, true);\n    };\n  }, [handleMouseMove]);\n  (0, react_exports.useEffect)(() => {\n    document.addEventListener(\"mouseup\", handleMouseUp);\n    return () => {\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [handleMouseUp]);\n  useMouseDownWithHandleEventListeners({\n    handleMouseDownOnItem,\n    canvasRef,\n    scale,\n    setStartPosition,\n    movable,\n    setIsMoving,\n    isMovingRef\n  });\n  const selectBox = (0, react_exports.useMemo)(() => {\n    if (allowMultiselect && isSelecting && !isMoving && startPosition && currentPosition) {\n      return /* @__PURE__ */ react_default.createElement(SelectBox_default, { start: startPosition, end: currentPosition });\n    }\n    return null;\n  }, [\n    allowMultiselect,\n    isSelecting,\n    isMoving,\n    startPosition,\n    currentPosition\n  ]);\n  return /* @__PURE__ */ react_default.createElement(\n    Canvas_default,\n    __spreadProps(__spreadValues({\n      ref: canvasRef\n    }, canvasProps), {\n      scale,\n      onMouseDown: handleMouseDown,\n      onContextMenu: resetState,\n      onMouseDownCapture: handleMouseDownCapture,\n      onMouseUpCapture\n    }),\n    selectBox,\n    children\n  );\n};\nvar AbsoluteCanvas_default = (0, react_exports.forwardRef)((props, ref) => {\n  return /* @__PURE__ */ react_default.createElement(AbsoluteCanvas, __spreadValues({ canvasRef: ref }, props));\n});\n\n// src/components/AbsoluteItem.jsx\nvar AbsoluteDiv = styled_components_default.div.attrs(({ x, y, w, h }) => ({\n  style: {\n    width: w,\n    height: h,\n    top: `${y}px`,\n    left: `${x}px`\n  }\n}))`\n    display: block;\n    position: absolute;\n    background: transparent;\n`;\nvar AbsoluteItem = ({\n  itemId,\n  type = \"block\",\n  x,\n  y,\n  w,\n  h,\n  renderLayoutItem\n}) => /* @__PURE__ */ react_default.createElement(\n  AbsoluteDiv,\n  {\n    x,\n    y,\n    w,\n    h,\n    \"data-test\": \"absolute-item\",\n    \"data-x\": x,\n    \"data-y\": y,\n    \"data-w\": w,\n    \"data-h\": h\n  },\n  renderLayoutItem(\n    itemId,\n    {\n      width: w,\n      height: h\n    },\n    type\n  )\n);\nAbsoluteItem.propTypes = {\n  itemId: prop_types_default.string.isRequired,\n  type: prop_types_default.string,\n  x: prop_types_default.number.isRequired,\n  y: prop_types_default.number.isRequired,\n  w: prop_types_default.number.isRequired,\n  h: prop_types_default.number.isRequired,\n  renderLayoutItem: prop_types_default.func.isRequired\n};\nvar AbsoluteItem_default = AbsoluteItem;\n\n// src/components/ActionMenuPortal.ts\nvar ActionMenuPortal = styled_components_default.div.attrs((props) => ({\n  \"data-test\": \"action-menu-portal\",\n  style: {\n    width: props.w,\n    top: props.y + props.h,\n    left: props.x\n  }\n}))`\n    display: block;\n    position: absolute;\n    background: transparent;\n    pointer-events: all;\n    box-sizing: border-box;\n    height: 0px;\n    z-index: ${(props) => props.zIndex};\n`;\nvar ActionMenuPortal_default = ActionMenuPortal;\n\n// src/components/Edge.tsx\nvar EdgeWrapper = styled_components_default.div.attrs(\n  ({ x, y, w, h }) => {\n    return {\n      style: {\n        width: w,\n        height: h,\n        transform: `translate(${x}px, ${y}px)`\n      }\n    };\n  }\n)`\n    display: block;\n    position: absolute;\n    background: transparent;\n    box-sizing: border-box;\n\n    &:hover {\n        cursor: ${(props) => props.orientation === \"vertical\" ? \"col-resize\" : \"row-resize\"};\n        background: ${(0, themes_exports.pickVariant)(\"appearance\", {\n  invalid: dashboard_ui_exports.customThemeVariables.invalidDropTargetBackgroundColor,\n  dropTarget: dashboard_ui_exports.customThemeVariables.validDropTargetBackgroundColor,\n  normal: \"transparent\",\n  hidden: \"transparent\"\n})};\n        border: ${(0, themes_exports.pickVariant)(\"appearance\", {\n  invalid: `1px solid ${dashboard_ui_exports.customThemeVariables.invalidDropTargetBorderColor}`,\n  dropTarget: `1px solid ${dashboard_ui_exports.customThemeVariables.validDropTargetBorderColor}`,\n  normal: \"none\",\n  hidden: \"none\"\n})};\n        transition: background 0.2s ease-out;\n    }\n`;\nvar EdgeComponent = styled_components_default.div.attrs(\n  ({ x, y, w, h }) => {\n    return {\n      style: {\n        width: w,\n        height: h,\n        transform: `translate(${x}px, ${y}px)`\n      }\n    };\n  }\n)`\n    display: block;\n    position: absolute;\n    opacity: 0.35;\n    pointer-events: none;\n    background-color: ${(props) => props.appearance === \"dropTarget\" ? dashboard_ui_exports.customThemeVariables.validDropTargetBorderColor : (0, themes_exports.pick)({\n  enterprise: themes_exports.variables.accentColorL10,\n  prisma: themes_exports.variables.interactiveColorPrimary\n})};\n    ${EdgeWrapper}:hover + & {\n        opacity: 0.7;\n    }\n`;\nvar Edge = ({\n  itemId,\n  x,\n  y,\n  h,\n  w,\n  orientation,\n  isCanvasEdge,\n  padding = 0,\n  appearance = \"normal\",\n  onMouseDown,\n  \"data-test-edge-position\": edgePositionTestHook\n}) => {\n  const handleMouseDown = (0, react_exports.useCallback)(\n    (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      onMouseDown(e, { id: itemId });\n    },\n    [onMouseDown, itemId]\n  );\n  if (appearance === \"hidden\" || isCanvasEdge && appearance !== \"dropTarget\" && (orientation === \"vertical\" || y + padding === 0)) {\n    return null;\n  }\n  const coord = { x, y, w, h };\n  const shift = padding / 2;\n  if (orientation === \"horizontal\") {\n    coord.y += shift;\n    coord.h -= padding;\n  }\n  if (orientation === \"vertical\") {\n    coord.x += shift;\n    coord.w -= padding;\n  }\n  return /* @__PURE__ */ react_default.createElement(react_default.Fragment, null, /* @__PURE__ */ react_default.createElement(\n    EdgeWrapper,\n    {\n      x,\n      y,\n      w,\n      h,\n      orientation,\n      appearance,\n      onMouseDown: handleMouseDown,\n      \"data-test\": \"edge\",\n      \"data-test-edge-position\": edgePositionTestHook\n    }\n  ), /* @__PURE__ */ react_default.createElement(\n    EdgeComponent,\n    {\n      x: coord.x,\n      y: coord.y,\n      w: coord.w,\n      h: coord.h,\n      appearance\n    }\n  ));\n};\n\n// src/components/ErrorMessageOverlay.jsx\nvar ErrorOverlay = styled_components_default.div`\n    position: absolute;\n    box-sizing: border-box;\n    top: 0;\n    left: 0;\n    height: 100%;\n    width: 100%;\n    pointer-events: none;\n    background-color: ${(0, themes_exports.pick)({\n  light: \"#a81916cc\",\n  dark: \"#a81916b3\"\n})};\n    color: white;\n    overflow: hidden;\n    padding: 8px;\n    z-index: 2;\n`;\nvar MessageContainer = styled_components_default.div`\n    padding-top: 8px;\n`;\nvar OverlayTitle = styled_components_default.div`\n    font-weight: bold;\n`;\nvar ErrorMessageOverlay = ({ messages }) => {\n  if (!messages || messages.length === 0) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(ErrorOverlay, { \"data-test\": \"error-overlay\" }, /* @__PURE__ */ react_default.createElement(OverlayTitle, null, \"Layout Errors:\"), messages.map((message) => /* @__PURE__ */ react_default.createElement(\n    MessageContainer,\n    {\n      \"data-test\": \"error-overlay-message\",\n      key: message\n    },\n    message\n  )));\n};\nErrorMessageOverlay.propTypes = {\n  messages: prop_types_default.arrayOf(prop_types_default.string)\n};\n\n// src/components/GridCanvas.tsx\nvar defaultState2 = {\n  startPosition: null,\n  isMoving: false\n};\nvar DEFAULT_SELECTED_LAYOUT_ITEMS2 = [];\nvar noop2 = () => void 0;\nvar GridCanvas = (props) => {\n  const _a = props, {\n    movable = false,\n    selectable = false,\n    selectedLayoutItems = DEFAULT_SELECTED_LAYOUT_ITEMS2,\n    panelPadding = 0,\n    scale = 1,\n    onItemMove = noop2,\n    onItemMoved = noop2,\n    onItemSelected,\n    children,\n    canvasRef,\n    blockItems\n  } = _a, canvasProps = __objRest(_a, [\n    \"movable\",\n    \"selectable\",\n    \"selectedLayoutItems\",\n    \"panelPadding\",\n    \"scale\",\n    \"onItemMove\",\n    \"onItemMoved\",\n    \"onItemSelected\",\n    \"children\",\n    \"canvasRef\",\n    \"blockItems\"\n  ]);\n  const { enableGridLayoutCssScaling } = (0, dashboard_context_exports.useFeatureFlags)();\n  const [startPosition, setStartPosition] = (0, react_exports.useState)(\n    defaultState2.startPosition\n  );\n  const [isMoving, setIsMoving] = (0, react_exports.useState)(defaultState2.isMoving);\n  const resetState = (0, react_exports.useCallback)(() => {\n    setIsMoving(defaultState2.isMoving);\n    setStartPosition(defaultState2.startPosition);\n  }, []);\n  const mouseScale = enableGridLayoutCssScaling ? scale : 1;\n  const handleItemSelected = (0, react_exports.useCallback)(\n    (e, itemIds = []) => {\n      if (itemIds.some(\n        ({ id, type }) => {\n          var _a2;\n          return type === \"input\" && ((_a2 = findStatusIcon({ canvasRef, id })) == null ? void 0 : _a2.contains(e.target));\n        }\n      )) {\n        return;\n      }\n      if (e.metaKey) {\n        const selectedItems = selectedLayoutItems.filter(\n          ({ type }) => type === \"block\"\n        );\n        onItemSelected(e, (0, lodash_exports.uniqBy)([...selectedItems, ...itemIds], \"id\"));\n      } else {\n        onItemSelected(e, itemIds);\n      }\n    },\n    [canvasRef, selectedLayoutItems, onItemSelected]\n  );\n  const handleMouseDownOnItem = (0, react_exports.useCallback)(\n    (event, blockItem) => {\n      const { id, type = \"block\" } = blockItem;\n      if (!selectedLayoutItems.find(\n        ({ id: selectedId }) => selectedId === id\n      )) {\n        handleItemSelected(event, [{ id, type }]);\n      }\n    },\n    [handleItemSelected, selectedLayoutItems]\n  );\n  const handleMouseDown = (0, react_exports.useCallback)(\n    (e) => {\n      const pos = computeRelativePosition(e, canvasRef, mouseScale);\n      const block = findTopBlockItemByPosition(\n        blockItems,\n        pos,\n        panelPadding\n      );\n      if (selectable) {\n        setStartPosition(pos);\n      }\n      if (block) {\n        handleMouseDownOnItem(e, {\n          id: block.item,\n          type: block.type\n        });\n        if (movable) {\n          setIsMoving(true);\n        }\n      }\n    },\n    [\n      canvasRef,\n      mouseScale,\n      blockItems,\n      panelPadding,\n      selectable,\n      handleMouseDownOnItem,\n      movable\n    ]\n  );\n  const handleMouseMove = (0, dashboard_ui_exports.useEventCallback)((e) => {\n    if (startPosition) {\n      const currentPosition = computeRelativePosition(\n        e,\n        canvasRef,\n        mouseScale\n      );\n      if (currentPosition) {\n        const offset = getOffset(currentPosition, startPosition);\n        if (isMoving && considerMoved(offset)) {\n          e.preventDefault();\n          onItemMove(e, { currentPosition });\n        }\n      }\n    }\n  });\n  const handleMouseUp = (0, dashboard_ui_exports.useEventCallback)((e) => {\n    if (startPosition) {\n      const currentPosition = computeRelativePosition(\n        e,\n        canvasRef,\n        mouseScale\n      );\n      if (currentPosition) {\n        const offset = getOffset(currentPosition, startPosition);\n        if (isMoving && considerMoved(offset)) {\n          onItemMoved(e, offset);\n        } else {\n          let blocks = blockItems;\n          if (panelPadding) {\n            blocks = blocks.map(\n              (block) => applyVizPadding({\n                item: block,\n                padding: panelPadding\n              })\n            );\n          }\n          const boundary = positionsToBoundary(\n            startPosition,\n            currentPosition\n          );\n          const selectedBlocks = filterBlockItemsByBoundary(\n            blocks,\n            boundary\n          ).map(({ item, type = \"block\" }) => ({\n            id: item,\n            type\n          }));\n          const topItem = selectedBlocks[selectedBlocks.length - 1];\n          handleItemSelected(e, topItem ? [topItem] : []);\n        }\n        resetState();\n      }\n    }\n  });\n  useMouseDownWithHandleEventListeners({\n    handleMouseDownOnItem,\n    canvasRef,\n    scale,\n    setStartPosition,\n    movable,\n    setIsMoving\n  });\n  (0, react_exports.useEffect)(() => {\n    document.addEventListener(\"mouseup\", handleMouseUp);\n    return () => {\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [handleMouseUp]);\n  (0, dashboard_ui_exports.useMouseMoveHandler)({ onMouseMove: handleMouseMove, isEnabled: movable });\n  return /* @__PURE__ */ react_default.createElement(\n    Canvas_default,\n    __spreadProps(__spreadValues({\n      ref: canvasRef\n    }, canvasProps), {\n      scale,\n      onMouseDown: handleMouseDown,\n      onContextMenu: resetState,\n      cssScaling: enableGridLayoutCssScaling,\n      showGrid: false\n    }),\n    children\n  );\n};\nvar GridCanvas_default = (0, react_exports.forwardRef)(\n  (props, ref) => /* @__PURE__ */ react_default.createElement(GridCanvas, __spreadValues({ canvasRef: ref }, props))\n);\n\n// src/components/GridItem.tsx\nvar GridDiv = styled_components_default.div`\n    height: 100%;\n    width: 100%;\n    grid-row: ${(props) => props.id}-start / ${(props) => props.id}-end;\n    grid-column: ${(props) => props.id}-start / ${(props) => props.id}-end;\n    background: transparent;\n`;\nvar GridItem = ({\n  itemId,\n  type = \"block\",\n  renderLayoutItem\n}) => /* @__PURE__ */ react_default.createElement(GridDiv, { id: itemId, \"data-test\": \"grid-item\" }, renderLayoutItem(itemId, { width: \"100%\", height: \"100%\" }, type));\nGridItem.propTypes = {\n  itemId: prop_types_default.string.isRequired,\n  type: prop_types_default.string,\n  renderLayoutItem: prop_types_default.func.isRequired\n};\nvar GridItem_default = GridItem;\n\n// src/components/ItemDragPlaceholder.tsx\nvar Placeholder = styled_components_default.div.attrs(\n  ({ position }) => ({\n    style: positionToStyle(position)\n  })\n)`\n    background-color: ${(0, themes_exports.pick)({\n  enterprise: {\n    light: themes_exports.variables.backgroundColorHover,\n    dark: themes_exports.variables.neutral300\n  },\n  prisma: themes_exports.variables.interactiveColorOverlayDrag\n})};\n    opacity: 0.75;\n    user-select: none;\n    position: absolute;\n    flex-direction: column;\n    top: 0;\n    left: 0;\n    cursor: move;\n`;\nvar ItemDragPlaceholder = ({\n  position,\n  size = 128\n}) => {\n  const placeHolderPosition = (0, react_exports.useMemo)(() => {\n    return {\n      // update x and y to be the center of the placeholder\n      x: position.x - Math.round(size / 2),\n      y: position.y - Math.round(size / 2),\n      w: size,\n      h: size\n    };\n  }, [position, size]);\n  return /* @__PURE__ */ react_default.createElement(\n    Placeholder,\n    {\n      \"data-test\": \"item-drag-placeholder\",\n      position: placeHolderPosition\n    }\n  );\n};\n\n// src/components/ItemDropTarget.jsx\nvar DropTarget = styled_components_default.div.attrs(({ position }) => ({\n  style: positionToStyle(position)\n}))`\n    background-color: ${(0, themes_exports.pickVariant)(\"validDropTarget\", {\n  true: dashboard_ui_exports.customThemeVariables.validDropTargetBackgroundColor,\n  false: dashboard_ui_exports.customThemeVariables.invalidDropTargetBackgroundColor\n})};\n    border-width: '1px';\n    border-style: 'solid';\n    border-color: ${(0, themes_exports.pickVariant)(\"validDropTarget\", {\n  true: dashboard_ui_exports.customThemeVariables.validDropTargetBorderColor,\n  false: dashboard_ui_exports.customThemeVariables.invalidDropTargetBorderColor\n})};\n    user-select: none;\n    position: absolute;\n    pointer-events: none;\n`;\nvar ItemDropTarget = ({ position, direction }) => {\n  const validDropTarget = (direction === \"e\" || direction === \"w\") && position.w >= 128 || (direction === \"n\" || direction === \"s\") && position.h >= 128;\n  const dropTargetPosition = (0, react_exports.useMemo)(() => {\n    let updatedPosition = null;\n    switch (direction) {\n      case \"n\":\n        updatedPosition = __spreadProps(__spreadValues({}, position), {\n          h: ITEM_DROP_TARGET_PX\n        });\n        break;\n      case \"s\":\n        updatedPosition = __spreadProps(__spreadValues({}, position), {\n          y: position.y + position.h - ITEM_DROP_TARGET_PX,\n          h: ITEM_DROP_TARGET_PX\n        });\n        break;\n      case \"w\":\n        updatedPosition = __spreadProps(__spreadValues({}, position), {\n          w: ITEM_DROP_TARGET_PX\n        });\n        break;\n      case \"e\":\n        updatedPosition = __spreadProps(__spreadValues({}, position), {\n          x: position.x + position.w - ITEM_DROP_TARGET_PX,\n          w: ITEM_DROP_TARGET_PX\n        });\n        break;\n      default:\n        updatedPosition = position;\n        break;\n    }\n    return updatedPosition;\n  }, [position, direction]);\n  if (validDropTarget) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(\n    DropTarget,\n    {\n      \"data-test\": \"item-drop-target\",\n      position: dropTargetPosition,\n      validDropTarget\n    }\n  );\n};\nItemDropTarget.propTypes = {\n  position: prop_types_default.shape({\n    x: prop_types_default.number.isRequired,\n    y: prop_types_default.number.isRequired,\n    w: prop_types_default.number.isRequired,\n    h: prop_types_default.number.isRequired\n  }).isRequired,\n  direction: prop_types_default.oneOf([\"n\", \"s\", \"w\", \"e\"]).isRequired\n};\n\n// src/components/Layer.tsx\nvar Layer = styled_components_default.div`\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    right: 0px;\n    bottom: 0px;\n    pointer-events: none;\n    z-index: ${(props) => props.zIndex};\n`;\nvar Layer_default = Layer;\n\n// esm-externals:@splunk/react-icons/enterprise/Plus\nvar Plus_exports = {};\n__export(Plus_exports, {\n  default: () => Plus_default\n});\nvar defaultImport14 = __toESM(require(\"@splunk/react-icons/enterprise/Plus\"));\n__reExport(Plus_exports, require(\"@splunk/react-icons/enterprise/Plus\"));\nvar Plus_default = \"default\" in defaultImport14 ? defaultImport14.default : defaultImport14;\n\n// src/utils/outlineUtils.ts\nvar getVerticalPosition = (dir, offset) => {\n  if (dir[0] === \"n\") {\n    return `top: -${offset}px`;\n  }\n  if (dir[0] === \"s\") {\n    return `bottom: -${offset}px`;\n  }\n  return `top: calc(50% - ${offset}px)`;\n};\nvar getHorizontalPosition = (dir, offset) => {\n  if (dir.slice(-1) === \"w\") {\n    return `left: -${offset}px`;\n  }\n  if (dir.slice(-1) === \"e\") {\n    return `right: -${offset}px`;\n  }\n  return `left: calc(50% - ${offset}px)`;\n};\n\n// src/components/Port.tsx\nvar portOffset = 8;\nvar PORT_DIRECTIONS = [\"n\", \"e\", \"s\", \"w\"];\nvar PortContainer = styled_components_default.div.attrs(({ port }) => ({\n  \"data-test\": \"port\",\n  \"data-test-port\": port\n}))`\n    text-align: center;\n    width: 16px;\n    height: 16px;\n    line-height: 16px;\n    box-sizing: border-box;\n    border-radius: 50%;\n    position: absolute;\n    color: ${(0, themes_exports.pick)({\n  enterprise: themes_exports.variables.accentColorL10,\n  prisma: themes_exports.variables.interactiveColorPrimary\n})};\n    ${({ port }) => getVerticalPosition(port, portOffset)};\n    ${({ port }) => getHorizontalPosition(port, portOffset)};\n    z-index: 999;\n    pointer-events: auto;\n    user-select: none;\n    &:hover {\n        background-color: ${(0, themes_exports.pick)({\n  enterprise: themes_exports.variables.accentColorL10,\n  prisma: themes_exports.variables.interactiveColorPrimary\n})};\n    }\n`;\nvar Port = ({\n  port,\n  onMouseEnter,\n  onMouseLeave\n}) => /* @__PURE__ */ react_default.createElement(\n  PortContainer,\n  {\n    port,\n    onMouseEnter,\n    onMouseLeave\n  },\n  /* @__PURE__ */ react_default.createElement(Plus_default, null)\n);\n\n// src/components/PreviewPlaceholderItem.jsx\nvar PlaceholderComponent = styled_components_default.div.attrs(({ position }) => ({\n  style: {\n    width: position.w,\n    height: position.h,\n    transform: `translate(${position.x}px, ${position.y}px)`\n  }\n}))`\n    display: block;\n    position: absolute;\n    pointer-events: none;\n    box-sizing: border-box;\n    border: 1px solid ${dashboard_ui_exports.customThemeVariables.validDropTargetBorderColor};\n    background-color: ${dashboard_ui_exports.customThemeVariables.validDropTargetBackgroundColor};\n`;\nvar PreviewPlaceholderItem = ({ position }) => {\n  return /* @__PURE__ */ react_default.createElement(\n    PlaceholderComponent,\n    {\n      position,\n      \"data-test\": \"preview-placeholder\",\n      \"data-test-preview-position\": `${position.x},${position.y}-${position.w},${position.h}`\n    }\n  );\n};\nPreviewPlaceholderItem.propTypes = {\n  position: prop_types_default.shape({\n    x: prop_types_default.number.isRequired,\n    y: prop_types_default.number.isRequired,\n    w: prop_types_default.number.isRequired,\n    h: prop_types_default.number.isRequired\n  }).isRequired\n};\n\n// esm-externals:@splunk/ui-utils/format\nvar format_exports = {};\n__export(format_exports, {\n  default: () => format_default\n});\nvar defaultImport15 = __toESM(require(\"@splunk/ui-utils/format\"));\n__reExport(format_exports, require(\"@splunk/ui-utils/format\"));\nvar format_default = \"default\" in defaultImport15 ? defaultImport15.default : defaultImport15;\n\n// src/components/ResizeHandle.tsx\nvar resizeHandleOffset = 7;\nvar computeCursor = (dir) => {\n  switch (dir) {\n    case \"n\":\n    case \"s\":\n      return \"ns-resize\";\n    case \"e\":\n    case \"w\":\n      return \"ew-resize\";\n    case \"ne\":\n    case \"sw\":\n      return \"nesw-resize\";\n    case \"se\":\n    case \"nw\":\n    default:\n      return \"nwse-resize\";\n  }\n};\nvar computeDirection = (dir) => {\n  switch (dir) {\n    case \"n\":\n      return (0, i18n_exports._)(\"North\");\n    case \"s\":\n      return (0, i18n_exports._)(\"South\");\n    case \"e\":\n      return (0, i18n_exports._)(\"East\");\n    case \"w\":\n      return (0, i18n_exports._)(\"West\");\n    case \"ne\":\n      return (0, i18n_exports._)(\"North-East\");\n    case \"sw\":\n      return (0, i18n_exports._)(\"South-West\");\n    case \"se\":\n      return (0, i18n_exports._)(\"South-East\");\n    case \"nw\":\n      return (0, i18n_exports._)(\"North-West\");\n    default:\n      return \"\";\n  }\n};\nvar Handle = styled_components_default.button.attrs(({ direction }) => ({\n  \"data-test\": \"handle\",\n  \"data-test-direction\": direction\n}))`\n    width: 10px;\n    height: 10px;\n    background-color: ${(0, themes_exports.pick)({\n  enterprise: themes_exports.variables.accentColorL10,\n  prisma: themes_exports.variables.interactiveColorPrimary\n})};\n    border: none;\n    border-radius: 20%;\n    padding: 0;\n    position: absolute;\n    ${({ direction }) => getVerticalPosition(direction, resizeHandleOffset)};\n    ${({ direction }) => getHorizontalPosition(direction, resizeHandleOffset)};\n    cursor: ${({ direction }) => computeCursor(direction)};\n    z-index: 999;\n    pointer-events: auto;\n    user-select: none;\n`;\nvar ResizeHandle = ({\n  onMouseDown,\n  onKeyDown,\n  direction\n}) => {\n  const handleMouseDown = (0, react_exports.useCallback)(\n    (e) => {\n      onMouseDown(e, direction);\n    },\n    [onMouseDown, direction]\n  );\n  const handleKeyDown = (0, react_exports.useCallback)(\n    (e) => {\n      onKeyDown(e, direction);\n    },\n    [onKeyDown, direction]\n  );\n  return /* @__PURE__ */ react_default.createElement(\n    Handle,\n    {\n      \"aria-label\": (0, format_exports.sprintf)((0, i18n_exports._)(\"Move %(direction)s direction\"), {\n        direction: computeDirection(direction)\n      }),\n      direction,\n      onMouseDown: handleMouseDown,\n      onKeyDown: handleKeyDown\n    }\n  );\n};\n\n// src/components/ResponsiveBox.tsx\nvar ResponsiveBox = styled_components_default.div.attrs(\n  ({ itemId, x, y, w, h, \"data-test\": dataTest, zIndex }) => {\n    const attributes = {\n      \"data-test\": dataTest != null ? dataTest : \"responsive-box\",\n      \"data-id\": itemId,\n      \"data-test-viz-item-position\": `${x},${y},${w},${h}`,\n      style: {\n        width: `${w}px`,\n        height: `${h}px`,\n        top: `${y}px`,\n        left: `${x}px`,\n        zIndex\n      }\n    };\n    if (!zIndex) {\n      delete attributes.style.zIndex;\n    }\n    return attributes;\n  }\n)`\n    display: block;\n    position: absolute;\n    background: transparent;\n    pointer-events: none;\n    box-sizing: border-box;\n    visibility: ${(props) => {\n  return props.appearance === \"hidden\" ? \"hidden\" : \"visible\";\n}};\n    opacity: ${(props) => props.appearance === \"highlighted\" ? 1 : 0.5};\n`;\nResponsiveBox.defaultProps = {\n  appearance: \"highlighted\"\n};\nvar ResponsiveBox_default = ResponsiveBox;\n\n// src/components/DragHandlePortal.tsx\nvar DragHandlePortal = styled_components_default.div.attrs(\n  (props) => ({\n    \"data-test\": \"drag-handle-portal\",\n    style: {\n      width: props.w,\n      top: props.y,\n      left: props.x\n    }\n  })\n)`\n    display: block;\n    position: absolute;\n    background: transparent;\n    pointer-events: all;\n    box-sizing: border-box;\n    height: 0px;\n    z-index: ${(props) => props.zIndex};\n    visibility: ${({ isHidden }) => isHidden ? \"hidden\" : \"visible\"};\n`;\n\n// src/components/ResponsiveBlockItem.tsx\nvar defaultPortalState = Object.freeze({\n  current: null\n});\nvar ResponsiveBlockItem = ({\n  x: originalX,\n  y: originalY,\n  w: originalW,\n  h: originalH,\n  canvasHeight,\n  padding,\n  itemId,\n  type = \"block\",\n  errorMessages,\n  onItemSelected,\n  renderLayoutItem,\n  appearance = \"highlighted\",\n  isMouseDownEventRef\n}) => {\n  var _a;\n  const selectIsSelected = (0, react_exports.useMemo)(dashboard_state_exports.makeSelectIsSelected, []);\n  const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);\n  const isSelected = (0, dashboard_state_exports.useSelector)((state) => selectIsSelected(state, itemId));\n  const [isClicked, setIsClicked] = (0, react_exports.useState)(false);\n  const [actionMenuPortal, setActionMenuPortal] = (0, react_exports.useState)(defaultPortalState);\n  const [dragHandlePortal, setDragHandlePortal] = (0, react_exports.useState)(defaultPortalState);\n  const layerData = (0, dashboard_context_exports.useLayoutLayers)();\n  const {\n    layer: itemLayer,\n    actionMenu: actionMenuLayer,\n    dragHandle: dragHandleLayer\n  } = (_a = layerData == null ? void 0 : layerData[itemId]) != null ? _a : {};\n  const renderActionMenuInPortal = typeof itemLayer === \"number\";\n  const {\n    position: { x, y, w, h }\n  } = applyVizPadding({\n    item: {\n      position: {\n        x: originalX,\n        y: originalY,\n        w: originalW,\n        h: originalH\n      }\n    },\n    padding\n  });\n  const layoutItem = (0, react_exports.useMemo)(\n    () => renderLayoutItem(\n      itemId,\n      {\n        width: w,\n        height: h,\n        y,\n        canvasHeight,\n        renderActionMenuInPortal,\n        actionMenuPortal,\n        dragHandlePortal\n      },\n      type,\n      onItemSelected\n    ),\n    [\n      renderLayoutItem,\n      itemId,\n      type,\n      w,\n      h,\n      y,\n      canvasHeight,\n      onItemSelected,\n      renderActionMenuInPortal,\n      actionMenuPortal,\n      dragHandlePortal\n    ]\n  );\n  const handleFocus = (0, react_exports.useCallback)(\n    (event) => {\n      if (isMouseDownEventRef == null ? void 0 : isMouseDownEventRef.current) {\n        setIsClicked(true);\n        return;\n      }\n      if (!event.relatedTarget) {\n        return;\n      }\n      setIsClicked(false);\n      if (\n        // The tabindex was moved to the SelectableContainer (in renderLayoutItem), so we'll check that thats the target\n        event.target.getAttribute(\"data-test\") === \"select-outline\" && event.target.getAttribute(\"data-id\") === itemId\n      ) {\n        onItemSelected(event, [{ id: itemId, type }]);\n      }\n    },\n    [isMouseDownEventRef, itemId, onItemSelected, type]\n  );\n  const trackActionMenuPortal = (0, react_exports.useCallback)((element) => {\n    setActionMenuPortal({ current: element });\n  }, []);\n  const trackDragHandlePortal = (0, react_exports.useCallback)((element) => {\n    setDragHandlePortal({ current: element });\n  }, []);\n  const isHidden = appearance === \"hidden\";\n  return /* @__PURE__ */ react_default.createElement(\n    dashboard_ui_exports.AbsoluteItemContainer,\n    {\n      \"data-id\": itemId,\n      \"data-selected\": `${isSelected}`,\n      \"data-click-focus\": `${isClicked && isSelected && mode === \"view\"}`\n    },\n    /* @__PURE__ */ react_default.createElement(\n      ResponsiveBox_default,\n      {\n        \"data-test\": \"absolute-item\",\n        itemId,\n        appearance,\n        x,\n        y,\n        w,\n        h,\n        onFocusCapture: handleFocus\n      },\n      layoutItem,\n      /* @__PURE__ */ react_default.createElement(ErrorMessageOverlay, { messages: errorMessages })\n    ),\n    renderActionMenuInPortal && /* @__PURE__ */ react_default.createElement(\n      ActionMenuPortal_default,\n      {\n        x,\n        y,\n        w,\n        h,\n        ref: trackActionMenuPortal,\n        zIndex: actionMenuLayer\n      }\n    ),\n    /* @__PURE__ */ react_default.createElement(\n      DragHandlePortal,\n      {\n        x,\n        y,\n        w,\n        ref: trackDragHandlePortal,\n        zIndex: dragHandleLayer,\n        isHidden\n      }\n    )\n  );\n};\nvar ResponsiveBlockItem_default = react_default.memo(ResponsiveBlockItem);\n\n// src/AbsoluteLayoutConstants.ts\nvar GRID_SIZE = 10;\nvar GRID_PADDING = 1;\nvar MIN_WIDTH = GRID_SIZE * 2;\nvar MIN_HEIGHT = GRID_SIZE * 2;\nvar ZOOM_STEP_SIZE = 0.25;\n\n// src/components/ResponsiveBlockOutline.tsx\nvar keyDirectionMap = {\n  ArrowUp: [\"n\", \"ne\", \"se\", \"s\", \"sw\", \"nw\"],\n  ArrowDown: [\"n\", \"ne\", \"se\", \"s\", \"sw\", \"nw\"],\n  ArrowLeft: [\"ne\", \"e\", \"se\", \"sw\", \"w\", \"nw\"],\n  ArrowRight: [\"ne\", \"e\", \"se\", \"sw\", \"w\", \"nw\"]\n};\nvar isKeyAllowedCheck = (key) => Object.keys(keyDirectionMap).includes(key);\nvar noop3 = () => void 0;\nvar ResponsiveBlockOutline = ({\n  itemId,\n  scale = 1,\n  connectable = false,\n  resizable = false,\n  onResize = noop3,\n  onResized = noop3,\n  onLineConnect = noop3,\n  onLineDisconnect = noop3,\n  handleDirections,\n  x,\n  y,\n  w,\n  h\n}) => {\n  const startPosition = (0, react_exports.useRef)(\n    null\n  );\n  const resizing = (0, react_exports.useRef)(false);\n  const resizeDir = (0, react_exports.useRef)(null);\n  const keyUpOffset = (0, react_exports.useRef)({ offsetX: 0, offsetY: 0 });\n  const handleResizeMouseDown = (0, react_exports.useCallback)(\n    (e, dir) => {\n      e.preventDefault();\n      e.stopPropagation();\n      startPosition.current = getClientPosition(e, scale);\n      resizing.current = true;\n      resizeDir.current = dir;\n    },\n    [scale]\n  );\n  const handleMouseMove = (0, react_exports.useCallback)(\n    (e) => {\n      if (startPosition.current && resizing.current && resizeDir.current) {\n        e.preventDefault();\n        const currentPosition = getClientPosition(e, scale);\n        const offset = getOffset(\n          currentPosition,\n          startPosition.current\n        );\n        onResize(e, itemId, offset, resizeDir.current);\n      }\n    },\n    [scale, onResize, itemId]\n  );\n  const handleMouseUp = (0, react_exports.useCallback)(\n    (e) => {\n      if (startPosition.current && resizing.current && resizeDir.current) {\n        e.preventDefault();\n        const currentPosition = getClientPosition(e, scale);\n        const offset = getOffset(\n          currentPosition,\n          startPosition.current\n        );\n        startPosition.current = null;\n        resizing.current = false;\n        onResized(e, itemId, offset, resizeDir.current);\n        resizeDir.current = null;\n      }\n    },\n    [itemId, scale, onResized]\n  );\n  const handleResizeKeyDown = (0, react_exports.useCallback)(\n    (e, dir) => {\n      const { key } = e;\n      const isKeyAllowed = isKeyAllowedCheck(key);\n      const isDirectionAllowed = isKeyAllowed && keyDirectionMap[key].includes(dir);\n      if (!isDirectionAllowed) {\n        return;\n      }\n      e.preventDefault();\n      e.stopPropagation();\n      resizeDir.current = dir;\n      if (e.key === \"ArrowUp\") {\n        keyUpOffset.current.offsetY -= GRID_SIZE;\n      }\n      if (e.key === \"ArrowDown\") {\n        keyUpOffset.current.offsetY += GRID_SIZE;\n      }\n      if (e.key === \"ArrowLeft\") {\n        keyUpOffset.current.offsetX -= GRID_SIZE;\n      }\n      if (e.key === \"ArrowRight\") {\n        keyUpOffset.current.offsetX += GRID_SIZE;\n      }\n      onResize(e, itemId, keyUpOffset.current, dir);\n    },\n    [itemId, onResize]\n  );\n  const handleKeyUp = (0, react_exports.useCallback)(\n    (e) => {\n      if (keyUpOffset.current && resizeDir.current) {\n        onResized(e, itemId, keyUpOffset.current, resizeDir.current);\n        resizeDir.current = null;\n        keyUpOffset.current = { offsetX: 0, offsetY: 0 };\n      }\n    },\n    [itemId, onResized]\n  );\n  const handlePortEnter = (0, react_exports.useCallback)(\n    (port) => (e) => {\n      e.preventDefault();\n      onLineConnect(itemId, port);\n    },\n    [itemId, onLineConnect]\n  );\n  const handlePortLeave = (0, react_exports.useCallback)(\n    (port) => (e) => {\n      e.preventDefault();\n      onLineDisconnect(itemId, port);\n    },\n    [itemId, onLineDisconnect]\n  );\n  (0, react_exports.useLayoutEffect)(() => {\n    if (resizable) {\n      document.addEventListener(\"mousemove\", handleMouseMove);\n    }\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n    };\n  }, [resizable, handleMouseMove]);\n  (0, react_exports.useLayoutEffect)(() => {\n    if (resizable) {\n      document.addEventListener(\"mouseup\", handleMouseUp);\n    }\n    return () => {\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [resizable, handleMouseUp]);\n  (0, react_exports.useLayoutEffect)(() => {\n    if (resizable) {\n      document.addEventListener(\"keyup\", handleKeyUp);\n    }\n    return () => {\n      document.removeEventListener(\"keyup\", handleKeyUp);\n    };\n  }, [resizable, handleKeyUp]);\n  const ResizeHandles = (0, react_exports.useMemo)(() => {\n    if (!resizable) {\n      return null;\n    }\n    return handleDirections.map((dir) => /* @__PURE__ */ react_default.createElement(\n      ResizeHandle,\n      {\n        key: `handle-${dir}`,\n        onMouseDown: handleResizeMouseDown,\n        onKeyDown: handleResizeKeyDown,\n        direction: dir\n      }\n    ));\n  }, [\n    resizable,\n    handleDirections,\n    handleResizeMouseDown,\n    handleResizeKeyDown\n  ]);\n  const Ports = (0, react_exports.useMemo)(() => {\n    if (!connectable) {\n      return null;\n    }\n    return PORT_DIRECTIONS.map((port) => /* @__PURE__ */ react_default.createElement(\n      Port,\n      {\n        key: `port-${port}`,\n        port,\n        onMouseEnter: handlePortEnter(port),\n        onMouseLeave: handlePortLeave(port)\n      }\n    ));\n  }, [connectable, handlePortEnter, handlePortLeave]);\n  return /* @__PURE__ */ react_default.createElement(ResponsiveBox_default, { itemId, x, y, w, h }, ResizeHandles, Ports);\n};\nvar ResponsiveBlockOutline_default = ResponsiveBlockOutline;\n\n// src/components/ResponsiveLine.tsx\nvar LineBox = styled_components_default.div`\n    position: absolute;\n    pointer-events: none;\n    z-index: ${(props) => props.zIndex};\n`;\nvar AdjustHandle = styled_components_default.a.attrs(({ x, y }) => ({\n  style: {\n    transform: `translate(${x}px, ${y}px)`\n  }\n}))`\n    width: 10px;\n    height: 10px;\n    left: -5px;\n    top: -5px;\n    background-color: ${(0, themes_exports.pick)({\n  enterprise: themes_exports.variables.accentColorL10,\n  prisma: themes_exports.variables.interactiveColorPrimary\n})};\n    border-radius: 50%;\n    position: absolute;\n    z-index: 999;\n    pointer-events: auto;\n    cursor: move;\n    user-select: none;\n`;\nvar ResponsiveLine = ({\n  fromX,\n  fromY,\n  fromItem,\n  fromPort,\n  toX,\n  toY,\n  toItem,\n  toPort,\n  lineId,\n  scale = 1,\n  selectable = false,\n  editable = false,\n  renderLayoutItem,\n  onItemSelected = dashboard_utils_exports.noop,\n  onLineDragStart = dashboard_utils_exports.noop,\n  onLineMove = dashboard_utils_exports.noop,\n  onLineMoved = dashboard_utils_exports.noop,\n  onLineDrag = dashboard_utils_exports.noop,\n  onLineDragged = dashboard_utils_exports.noop\n}) => {\n  const [startPosition, setStartPosition] = (0, react_exports.useState)(null);\n  const [action, setAction] = (0, react_exports.useState)(null);\n  const layerData = (0, dashboard_context_exports.useLayoutLayers)();\n  const lineLayer = (0, react_exports.useMemo)(() => {\n    const selectionLayer = Object.values(layerData != null ? layerData : {}).map((entry) => entry.selection).filter(Boolean)[0];\n    return typeof selectionLayer === \"number\" ? selectionLayer + 1 : void 0;\n  }, [layerData]);\n  const handleLineSelected = (0, react_exports.useCallback)(\n    (e) => {\n      e.stopPropagation();\n      setStartPosition(getClientPosition(e, scale));\n      setAction(\"move\");\n      onItemSelected(e, [{ id: lineId, type: \"line\" }]);\n    },\n    [lineId, onItemSelected, scale]\n  );\n  const handleMouseDownFrom = (0, react_exports.useCallback)(\n    (e) => {\n      e.stopPropagation();\n      setStartPosition(getClientPosition(e, scale));\n      setAction(\"drag\");\n      onLineDragStart(e, \"from\");\n    },\n    [onLineDragStart, scale]\n  );\n  const handleMouseDownTo = (0, react_exports.useCallback)(\n    (e) => {\n      e.stopPropagation();\n      setStartPosition(getClientPosition(e, scale));\n      setAction(\"drag\");\n      onLineDragStart(e, \"to\");\n    },\n    [onLineDragStart, scale]\n  );\n  const handleMouseUp = (0, react_exports.useCallback)(\n    (e) => {\n      if (startPosition == null || action == null) {\n        return;\n      }\n      setStartPosition(null);\n      const currentPosition = getClientPosition(e, scale);\n      const offset = getOffset(currentPosition, startPosition);\n      if (!offset.offsetX && !offset.offsetY) {\n        return;\n      }\n      switch (action) {\n        case \"drag\":\n          onLineDragged(e, offset);\n          break;\n        case \"move\":\n          onLineMoved(e, offset);\n          break;\n        default:\n          break;\n      }\n    },\n    [action, onLineDragged, onLineMoved, scale, startPosition]\n  );\n  const handleMouseMove = (0, react_exports.useCallback)(\n    (e) => {\n      if (startPosition == null || action == null) {\n        return;\n      }\n      if (e.buttons <= 0 || e.buttons % 2 === 0) {\n        handleMouseUp(e);\n        return;\n      }\n      e.preventDefault();\n      const currentPosition = getClientPosition(e, scale);\n      const offset = getOffset(currentPosition, startPosition);\n      if (!offset.offsetX && !offset.offsetY) {\n        return;\n      }\n      switch (action) {\n        case \"drag\":\n          onLineDrag(e, offset);\n          break;\n        case \"move\":\n          onLineMove(e, offset);\n          break;\n        default:\n          break;\n      }\n    },\n    [action, handleMouseUp, onLineDrag, onLineMove, scale, startPosition]\n  );\n  const from = { x: fromX, y: fromY };\n  const to = { x: toX, y: toY };\n  const boxPos = computeLineBoxPosition(from, to);\n  const relativePos = computeLineRelativePosition(from, to, boxPos);\n  const lineBoxStyle = (0, react_exports.useMemo)(\n    () => ({\n      transform: `translate(${boxPos.x}px, ${boxPos.y}px)`\n    }),\n    [boxPos.x, boxPos.y]\n  );\n  const fromHandleElement = (0, react_exports.useMemo)(() => {\n    if (!editable) {\n      return null;\n    }\n    return /* @__PURE__ */ react_default.createElement(\n      AdjustHandle,\n      {\n        \"data-test\": \"line-handle-from\",\n        \"data-test-item\": fromItem,\n        \"data-test-port\": fromPort,\n        x: relativePos.from.x,\n        y: relativePos.from.y,\n        onMouseDown: handleMouseDownFrom\n      }\n    );\n  }, [\n    editable,\n    fromItem,\n    fromPort,\n    relativePos.from.x,\n    relativePos.from.y,\n    handleMouseDownFrom\n  ]);\n  const toHandleElement = (0, react_exports.useMemo)(() => {\n    if (!editable) {\n      return null;\n    }\n    return /* @__PURE__ */ react_default.createElement(\n      AdjustHandle,\n      {\n        \"data-test\": \"line-handle-to\",\n        \"data-test-item\": toItem,\n        \"data-test-port\": toPort,\n        x: relativePos.to.x,\n        y: relativePos.to.y,\n        onMouseDown: handleMouseDownTo\n      }\n    );\n  }, [\n    editable,\n    toItem,\n    toPort,\n    relativePos.to.x,\n    relativePos.to.y,\n    handleMouseDownTo\n  ]);\n  const lineElement = (0, react_exports.useMemo)(\n    () => renderLayoutItem(\n      lineId,\n      {\n        from: {\n          x: relativePos.from.x,\n          y: relativePos.from.y\n        },\n        to: {\n          x: relativePos.to.x,\n          y: relativePos.to.y\n        },\n        // todo: this is inconsistent with the ResponsiveBlockItem which accepts the `onSelect` callback as the 4th argument of `renderLayoutItem`.\n        onLineSelect: selectable ? handleLineSelected : dashboard_utils_exports.noop\n      },\n      \"line\"\n    ),\n    [\n      handleLineSelected,\n      lineId,\n      relativePos.from.x,\n      relativePos.from.y,\n      relativePos.to.x,\n      relativePos.to.y,\n      renderLayoutItem,\n      selectable\n    ]\n  );\n  (0, react_exports.useEffect)(() => {\n    if (editable) {\n      document.addEventListener(\"mousemove\", handleMouseMove);\n      document.addEventListener(\"mouseup\", handleMouseUp);\n    }\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [editable, handleMouseMove, handleMouseUp]);\n  return /* @__PURE__ */ react_default.createElement(\n    LineBox,\n    {\n      \"data-test\": \"line-box\",\n      style: lineBoxStyle,\n      \"data-viz-type\": \"abslayout.line\",\n      \"data-id\": lineId,\n      \"data-test-line-position\": `${from.x},${from.y}-${to.x},${to.y}`,\n      zIndex: lineLayer\n    },\n    fromHandleElement,\n    toHandleElement,\n    lineElement\n  );\n};\nvar ResponsiveLine_default = ResponsiveLine;\n\n// src/utils/absoluteLayoutUtils.ts\nvar initializeLayoutStructureState = (layoutStructure) => layoutStructure.reduce((obj, item) => {\n  obj[item.item] = __spreadValues({}, item);\n  return obj;\n}, {});\nvar reducer = (state, action) => {\n  switch (action.type) {\n    case \"lineMove\":\n      return __spreadProps(__spreadValues({}, state), {\n        [action.payload.item]: action.payload\n      });\n    case \"lineDragStart\":\n      return __spreadProps(__spreadValues({}, state), {\n        [action.payload.item]: action.payload\n      });\n    case \"lineDrag\": {\n      const lineToDrag = state[action.payload.id];\n      return isLineConnected({\n        line: lineToDrag,\n        dir: action.payload.dir\n      }) ? state : __spreadProps(__spreadValues({}, state), {\n        [action.payload.id]: __spreadProps(__spreadValues({}, lineToDrag), {\n          position: __spreadProps(__spreadValues({}, lineToDrag.position), {\n            [action.payload.dir]: action.payload.absPos\n          })\n        })\n      });\n    }\n    case \"lineConnect\": {\n      const lineToConnect = state[action.payload.lineId];\n      return isLineConnected({\n        line: lineToConnect,\n        dir: action.payload.lineDir\n      }) ? state : __spreadProps(__spreadValues({}, state), {\n        [action.payload.lineId]: connectLine({\n          line: lineToConnect,\n          dir: action.payload.lineDir,\n          itemId: action.payload.itemId,\n          port: action.payload.port\n        })\n      });\n    }\n    case \"lineDisconnect\": {\n      const lineToDisconnect = state[action.payload.lineId];\n      return isLineConnected({\n        line: lineToDisconnect,\n        dir: action.payload.lineDir\n      }) ? __spreadProps(__spreadValues({}, state), {\n        [action.payload.lineId]: disconnectLine({\n          line: lineToDisconnect,\n          dir: action.payload.lineDir,\n          absPos: computeLineAbsPosition({\n            layoutStructure: Object.values(state),\n            position: lineToDisconnect.position\n          })[action.payload.lineDir]\n        })\n      }) : state;\n    }\n    case \"blockResize\":\n      return __spreadProps(__spreadValues({}, state), {\n        [action.payload.item]: action.payload\n      });\n    case \"blocksMove\":\n      return action.payload.reduce(\n        (s, blockItem) => __spreadProps(__spreadValues({}, s), {\n          [blockItem.item]: blockItem\n        }),\n        __spreadValues({}, state)\n      );\n    case \"reset\":\n      return initializeLayoutStructureState(action.payload);\n    default:\n      return state;\n  }\n};\nvar updateLayoutStructureOnKeyboardMove = ({\n  selectedLineItems,\n  selectedBlockItems,\n  layoutStructure,\n  dir,\n  snap,\n  gridSize\n}) => {\n  const updatedLines = selectedLineItems.map(({ item }) => {\n    const offset = createOffset(dir, 1, 1);\n    return handleSingleLineMove({\n      layoutStructure,\n      lineId: item,\n      offset\n    });\n  });\n  const updatedBlocks = selectedBlockItems.map((blockItem) => {\n    const { position } = blockItem;\n    const snapOffset2 = snap ? snapOffsetToXY({\n      position,\n      offset: createOffset(dir, gridSize, gridSize),\n      gridWidth: gridSize,\n      gridHeight: gridSize,\n      spacing: 0,\n      padding: 0\n    }) : createOffset(dir, 1, 1);\n    return updateBlockItemPosition(blockItem, snapOffset2);\n  });\n  const updatedItems = [...updatedLines, ...updatedBlocks];\n  const updatedLayoutStructure = layoutStructure.map(\n    (item) => {\n      var _a;\n      return (_a = updatedItems.find((line) => line.item === item.item)) != null ? _a : item;\n    }\n  );\n  return updatedLayoutStructure;\n};\n\n// src/absoluteLayoutOptionsSchema.ts\nvar absoluteLayoutOptionsSchema_default = {\n  backgroundColor: {\n    oneOf: [\n      {\n        pattern: \"^#[0-9a-fA-F]{6}$\",\n        type: \"string\",\n        description: `Specify the color of the layout background color using a Hex code, such as \"#FF0000\".\n\nThe default for light mode is \"#F2F4f5\". The default for dark mode is \"#3C444D\". The default for SCP mode is \"#15161B\"`\n      },\n      {\n        type: \"string\",\n        enum: dashboard_ui_exports.namedColors,\n        description: `Specify the color of the layout background color using a valid web color such as 'blue'`\n      }\n    ]\n  },\n  display: {\n    type: \"string\",\n    default: \"auto\",\n    enum: [\"actual-size\", \"fit-to-width\", \"auto\", \"auto-scale\"],\n    description: `Specify the display behavior. Valid options are:\n\n\nactual-size: The dashboard will not change size when the browser is resized.\n\n\nfit-to-width: The dashboard will change in size as the browser is resized, always filling the available width of the browser.\n\n\nauto: The dashboard will change in size as the browser is resized, to a maximum zoom of 100%.`\n  },\n  backgroundImage: {\n    type: \"object\",\n    properties: {\n      w: {\n        type: \"number\",\n        description: `Specify the image's h (height) and w (width) in pixels. These options should not be specified if you set the sizeType option. If they are, they will overrule that setting.`\n      },\n      h: {\n        type: \"number\",\n        description: `Specify the image's h (height) and w (width) in pixels. These options should not be specified if you set the sizeType option. If they are, they will overrule that setting.`\n      },\n      x: {\n        type: \"number\",\n        description: \"Specify, in pixels, the position of the background image on the x-axis and y-axis. These options should not be specified if you set the sizeType option. If they are, they will overrule that setting.\"\n      },\n      y: {\n        type: \"number\",\n        description: \"Specify, in pixels, the position of the background image on the x-axis and y-axis. These options should not be specified if you set the sizeType option. If they are, they will overrule that setting.\"\n      },\n      src: {\n        type: \"string\",\n        description: \"The url of background image.\"\n      },\n      sizeType: {\n        type: \"string\",\n        enum: [\"auto\", \"contain\", \"cover\"],\n        default: \"contain\",\n        description: `Specify one of the following:\n\n\nauto: Scales the image while maintaining the image proportion.\n\n\ncontain: Increases the size of the of the image as much as possible without cropping or stretching it.\n\n\ncover: Increases the size of the image without stretching it. The image may be cropped vertically and horizontally so that no empty space is shown.`\n      }\n    },\n    description: `A background image must be one of the following types: jpg, jpeg, png, svg, or gif\n\nSpecify the location of a background image using the option src. For example: \"src\": \"https://www.myImageLocation.com/galleryX/image1.png`,\n    additionalProperties: false\n  },\n  width: {\n    type: \"number\",\n    default: dashboard_utils_exports.DEFAULT_CANVAS_WIDTH,\n    description: \"Canvas width in pixels.\"\n  },\n  height: {\n    type: \"number\",\n    default: dashboard_utils_exports.DEFAULT_CANVAS_HEIGHT,\n    description: \"Canvas height in pixels.\"\n  }\n};\n\n// src/enhancers/withLayoutShowHide.tsx\nvar EmptyStructure = [];\nvar withLayoutShowHide = (Layout, { schema, reflowFn }) => {\n  const EnhancedLayout = (props) => {\n    var _a;\n    const layoutStructure = useLayoutShowHide(\n      (_a = props.layoutStructure) != null ? _a : EmptyStructure,\n      reflowFn\n    );\n    return /* @__PURE__ */ react_default.createElement(\n      Layout,\n      __spreadProps(__spreadValues({}, props), {\n        layoutStructure,\n        rawLayoutStructure: props.layoutStructure\n      })\n    );\n  };\n  EnhancedLayout.schema = schema;\n  return EnhancedLayout;\n};\n\n// src/AbsoluteLayout.tsx\nvar emptySelectedItems = [];\nvar emptyLayoutStructure = [];\nvar AbsoluteLayout = (props) => {\n  const {\n    mode = \"view\",\n    showGrid = true,\n    options: {\n      width = absoluteLayoutOptions.width,\n      height = absoluteLayoutOptions.height,\n      display = absoluteLayoutOptions.display,\n      backgroundColor,\n      backgroundImage\n    } = {},\n    layoutStructure = emptyLayoutStructure,\n    rawLayoutStructure = emptyLayoutStructure,\n    containerWidth,\n    containerHeight,\n    selectedItems = emptySelectedItems,\n    renderLayoutItem,\n    onLayoutItemsSelect = dashboard_utils_exports.noop,\n    onLayoutStructureChange = dashboard_utils_exports.noop,\n    layoutApiRef = dashboard_utils_exports.noop\n  } = props;\n  const [activeLine, setActiveLine] = (0, react_exports.useState)(null);\n  const [scale, setScaleInternal] = (0, react_exports.useState)(1);\n  const [fitToWidth, setFitToWidth] = (0, react_exports.useState)(false);\n  const [layoutStructureState, dispatch] = (0, react_exports.useReducer)(\n    reducer,\n    layoutStructure,\n    initializeLayoutStructureState\n  );\n  const canvasRef = (0, react_exports.useRef)(null);\n  const layoutApi = (0, react_exports.useRef)(null);\n  const zoomObserver = (0, react_exports.useRef)(null);\n  const savedScroll = (0, react_exports.useRef)(null);\n  const isMouseDownEventRef = (0, react_exports.useRef)(false);\n  const layoutStructureRef = (0, react_exports.useRef)(layoutStructure);\n  layoutStructureRef.current = layoutStructure;\n  const currentStepRef = (0, react_exports.useRef)(1);\n  currentStepRef.current = Math.round(scale / ZOOM_STEP_SIZE) * ZOOM_STEP_SIZE;\n  const keyboardListener = (0, dashboard_context_exports.useKeyboardListener)();\n  const featureFlags = (0, dashboard_context_exports.useFeatureFlags)();\n  const preset = (0, dashboard_context_exports.usePreset)();\n  const dashboardApi = (0, dashboard_context_exports.useDashboardCoreApi)();\n  const telemetry = (0, dashboard_telemetry_exports.useTelemetryApi)();\n  const profiler = (0, dashboard_telemetry_exports.useDashboardProfiler)();\n  const previousScale = (0, dashboard_ui_exports.usePrevious)(scale);\n  const previousLayoutStructure = (0, dashboard_ui_exports.usePrevious)(layoutStructure);\n  const scrollbarWidth = (0, react_exports.useMemo)(() => (0, dashboard_utils_exports.getScrollbarWidth)(), []);\n  const getZoomObserver = (0, react_exports.useCallback)(() => {\n    if (zoomObserver.current == null) {\n      zoomObserver.current = new rxjs_exports.BehaviorSubject(1);\n    }\n    return zoomObserver.current;\n  }, []);\n  const setScale = (0, react_exports.useCallback)(\n    (s) => {\n      getZoomObserver().next(s);\n      setScaleInternal(s);\n      setFitToWidth(false);\n    },\n    [getZoomObserver]\n  );\n  const getCanvasDomElement = (0, react_exports.useCallback)(() => {\n    return canvasRef.current;\n  }, []);\n  const scrollToTopLeft = (0, react_exports.useCallback)(() => {\n    const layoutEl = getCanvasDomElement().parentElement;\n    if (layoutEl) {\n      layoutEl.scrollTop = 0;\n      layoutEl.scrollLeft = 0;\n    }\n  }, [getCanvasDomElement]);\n  const setFitToWidthAndScrollToTopLeft = (0, react_exports.useCallback)(\n    (maxScale = Infinity) => {\n      setFitToWidth(maxScale);\n      scrollToTopLeft();\n    },\n    [scrollToTopLeft]\n  );\n  const zoomIn = (0, react_exports.useCallback)(() => {\n    setScale(currentStepRef.current + ZOOM_STEP_SIZE);\n  }, [setScale]);\n  const zoomOut = (0, react_exports.useCallback)(() => {\n    const nextStep = currentStepRef.current - ZOOM_STEP_SIZE;\n    if (nextStep >= ZOOM_STEP_SIZE) {\n      setScale(nextStep);\n    }\n  }, [setScale]);\n  const handleKeyboardZoom = (0, react_exports.useCallback)(\n    ({ dir, preventDefault }) => {\n      switch (dir) {\n        case \"in\":\n          zoomIn();\n          break;\n        case \"out\":\n          zoomOut();\n          break;\n        case \"reset\":\n          setFitToWidthAndScrollToTopLeft();\n          break;\n        default:\n          break;\n      }\n      preventDefault();\n    },\n    [setFitToWidthAndScrollToTopLeft, zoomIn, zoomOut]\n  );\n  const handleKeyboardMove = (0, react_exports.useCallback)(\n    ({ dir, snap, preventDefault }) => {\n      var _a, _b;\n      const selectedLineItems = findSelectedLineItems({\n        layoutStructure,\n        selectedItems\n      });\n      const selectedBlockItems = findSelectedBlockItems({\n        layoutStructure,\n        selectedItems\n      });\n      const isResizeHandleFocused = ((_a = document.activeElement) == null ? void 0 : _a.tagName) === \"BUTTON\" && ((_b = document.activeElement) == null ? void 0 : _b.hasAttribute(\"direction\"));\n      if (selectedLineItems.length === 0 && selectedBlockItems.length === 0 || mode !== \"edit\" || isResizeHandleFocused) {\n        return;\n      }\n      const updatedLayoutStructure = updateLayoutStructureOnKeyboardMove({\n        selectedBlockItems,\n        selectedLineItems,\n        dir,\n        snap,\n        gridSize: GRID_SIZE,\n        layoutStructure\n      });\n      onLayoutStructureChange(updatedLayoutStructure);\n      preventDefault();\n    },\n    [layoutStructure, mode, onLayoutStructureChange, selectedItems]\n  );\n  const handleLayoutStructureChange = (0, react_exports.useCallback)(() => {\n    const updatedLayoutStructure = layoutStructure.map(\n      (item) => {\n        var _a;\n        return (_a = layoutStructureState[item.item]) != null ? _a : item;\n      }\n    );\n    onLayoutStructureChange(updatedLayoutStructure);\n  }, [layoutStructure, layoutStructureState, onLayoutStructureChange]);\n  const handleLineMove = (0, react_exports.useCallback)(\n    (e, offset) => {\n      const selectedLineItems = findSelectedLineItems({\n        layoutStructure,\n        selectedItems\n      });\n      if (selectedLineItems.length === 0) {\n        return;\n      }\n      const lineId = selectedLineItems[0].item;\n      dispatch({\n        type: \"lineMove\",\n        payload: handleSingleLineMove({\n          layoutStructure,\n          lineId,\n          offset\n        })\n      });\n    },\n    [layoutStructure, selectedItems]\n  );\n  const handleLineMoved = (0, react_exports.useCallback)(() => {\n    handleLayoutStructureChange();\n  }, [handleLayoutStructureChange]);\n  const handleLineDragStart = (0, react_exports.useCallback)(\n    (e, dir) => {\n      const selectedLineItems = findSelectedLineItems({\n        layoutStructure,\n        selectedItems\n      });\n      if (selectedLineItems.length !== 1) {\n        return;\n      }\n      const lineId = selectedLineItems[0].item;\n      const line = handleSingleLineDragStart({\n        lineId,\n        layoutStructure,\n        lineDir: dir\n      });\n      dispatch({\n        type: \"lineDragStart\",\n        payload: line\n      });\n      setActiveLine({ id: lineId, dir });\n    },\n    [layoutStructure, selectedItems]\n  );\n  const handleLineDrag = (0, react_exports.useCallback)(\n    (e, offset) => {\n      if (!activeLine) {\n        return;\n      }\n      const line = layoutStructure.find(\n        (item) => item.item === activeLine.id\n      );\n      const absPos = computeLineAbsPosition({\n        layoutStructure,\n        position: line.position\n      })[activeLine.dir];\n      dispatch({\n        type: \"lineDrag\",\n        payload: {\n          id: activeLine.id,\n          dir: activeLine.dir,\n          absPos: {\n            x: absPos.x + offset.offsetX,\n            y: absPos.y + offset.offsetY\n          }\n        }\n      });\n    },\n    [activeLine, layoutStructure]\n  );\n  const handleLineDragged = (0, react_exports.useCallback)(() => {\n    setActiveLine(null);\n    handleLayoutStructureChange();\n  }, [handleLayoutStructureChange]);\n  const handleLineConnected = (0, react_exports.useCallback)(\n    (itemId, port) => {\n      if (!activeLine) {\n        return;\n      }\n      const lineId = activeLine.id;\n      dispatch({\n        type: \"lineConnect\",\n        payload: { lineId, lineDir: activeLine.dir, itemId, port }\n      });\n    },\n    [activeLine]\n  );\n  const handleLineDisconnected = (0, react_exports.useCallback)(() => {\n    if (!activeLine) {\n      return;\n    }\n    dispatch({\n      type: \"lineDisconnect\",\n      payload: {\n        lineId: activeLine.id,\n        lineDir: activeLine.dir\n      }\n    });\n  }, [activeLine]);\n  const handleItemSelected = (0, react_exports.useCallback)(\n    (e, newSelectedItems = emptySelectedItems) => {\n      onLayoutItemsSelect(newSelectedItems);\n    },\n    [onLayoutItemsSelect]\n  );\n  const handleBlockItemResize = (0, react_exports.useCallback)(\n    (e, itemId, offset, dir) => {\n      const item = layoutStructure.find(\n        (itm) => itm.item === itemId\n      );\n      const snapOffset2 = snapOffsetToWH({\n        position: item.position,\n        offset,\n        gridWidth: GRID_SIZE,\n        gridHeight: GRID_SIZE,\n        spacing: 0,\n        padding: 0\n      });\n      const newItem = updateBlockItemSize({\n        item,\n        offset: snapOffset2,\n        dir,\n        options: {\n          minHeight: MIN_HEIGHT,\n          minWidth: MIN_WIDTH\n        }\n      });\n      if ((0, lodash_exports.isEqual)(\n        newItem.position,\n        layoutStructureState[newItem.item].position\n      )) {\n        return;\n      }\n      profiler == null ? void 0 : profiler.startMeasurement(dashboard_telemetry_exports.VIZ_RESIZE_EVENT);\n      dispatch({\n        type: \"blockResize\",\n        payload: newItem\n      });\n    },\n    [layoutStructure, layoutStructureState, profiler]\n  );\n  const handleBlockItemResized = (0, react_exports.useCallback)(() => {\n    profiler == null ? void 0 : profiler.emitAndClearMeasurements({\n      measurementName: dashboard_telemetry_exports.VIZ_RESIZE_EVENT\n    });\n    handleLayoutStructureChange();\n  }, [handleLayoutStructureChange, profiler]);\n  const handleBlockItemMove = (0, react_exports.useCallback)(\n    (e, offset) => {\n      const selectedBlockItems = findSelectedBlockItems({\n        layoutStructure,\n        selectedItems\n      });\n      if (selectedBlockItems.length === 0) {\n        return;\n      }\n      const firstBlockItem = selectedBlockItems[0];\n      const moveOffset = snapOffsetToXY({\n        position: firstBlockItem.position,\n        offset,\n        gridWidth: GRID_SIZE,\n        gridHeight: GRID_SIZE,\n        spacing: 0,\n        padding: 0\n      });\n      const updatedSelectedBlockItems = selectedBlockItems.map(\n        (blockItem) => updateBlockItemPosition(blockItem, moveOffset)\n      );\n      const firstUpdatedBlockItem = updatedSelectedBlockItems[0];\n      if ((0, lodash_exports.isEqual)(\n        firstUpdatedBlockItem.position,\n        layoutStructureState[firstUpdatedBlockItem.item].position\n      )) {\n        return;\n      }\n      profiler == null ? void 0 : profiler.startMeasurement(dashboard_telemetry_exports.VIZ_MOVE_EVENT);\n      dispatch({\n        type: \"blocksMove\",\n        payload: updatedSelectedBlockItems\n      });\n    },\n    [layoutStructure, layoutStructureState, profiler, selectedItems]\n  );\n  const handleBlockItemMoved = (0, react_exports.useCallback)(() => {\n    profiler == null ? void 0 : profiler.emitAndClearMeasurements({\n      measurementName: dashboard_telemetry_exports.VIZ_MOVE_EVENT,\n      metadata: { numVisualizationsMoved: selectedItems == null ? void 0 : selectedItems.length }\n    });\n    handleLayoutStructureChange();\n  }, [handleLayoutStructureChange, profiler, selectedItems]);\n  const blockItems = (0, react_exports.useMemo)(\n    () => layoutStructure.filter((item) => (0, dashboard_utils_exports.isBlockItem)(item)).map(\n      (block) => {\n        var _a;\n        return (_a = layoutStructureState[block.item]) != null ? _a : block;\n      }\n    ),\n    [layoutStructure, layoutStructureState]\n  );\n  const lineItems = (0, react_exports.useMemo)(\n    () => layoutStructure.filter(({ type }) => type === \"line\").map(\n      (line) => {\n        var _a;\n        return (_a = layoutStructureState[line.item]) != null ? _a : line;\n      }\n    ),\n    [layoutStructure, layoutStructureState]\n  );\n  const optionsRef = (0, react_exports.useRef)(props.options);\n  optionsRef.current = props.options;\n  const bgImageSrcRef = (0, react_exports.useRef)();\n  const realBGImageUrl = useBackgroundImage(backgroundImage == null ? void 0 : backgroundImage.src);\n  bgImageSrcRef.current = realBGImageUrl;\n  const getBgImageSrc = (0, react_exports.useCallback)(() => {\n    return bgImageSrcRef.current;\n  }, []);\n  if (!layoutApi.current) {\n    layoutApi.current = new AbsoluteLayoutApi_default({\n      getZoomObserver,\n      setFitToWidthAndScrollToTopLeft,\n      zoomIn,\n      zoomOut,\n      setScale,\n      optionsRef,\n      layoutStructureRef,\n      getCanvasDomElement,\n      telemetry,\n      getBgImageSrc\n    });\n  }\n  (0, react_exports.useEffect)(() => {\n    if (!(0, lodash_exports.isEqual)(layoutStructure, previousLayoutStructure)) {\n      dispatch({\n        type: \"reset\",\n        payload: layoutStructure\n      });\n    }\n  }, [layoutStructure, previousLayoutStructure]);\n  (0, react_exports.useEffect)(() => {\n    layoutApiRef(layoutApi.current);\n    return () => {\n      layoutApiRef(null);\n    };\n  }, [layoutApiRef]);\n  (0, react_exports.useEffect)(() => {\n    if (!keyboardListener) {\n      return dashboard_utils_exports.noop;\n    }\n    const unsubscribeMove = keyboardListener.subscribe(\n      \"move\",\n      handleKeyboardMove\n    );\n    return () => {\n      unsubscribeMove();\n    };\n  }, [handleKeyboardMove, keyboardListener]);\n  (0, react_exports.useEffect)(() => {\n    if (!keyboardListener) {\n      return dashboard_utils_exports.noop;\n    }\n    const unsubscribeZoom = keyboardListener.subscribe(\n      \"zoom\",\n      handleKeyboardZoom\n    );\n    return () => {\n      unsubscribeZoom();\n    };\n  }, [handleKeyboardZoom, keyboardListener]);\n  (0, react_exports.useEffect)(() => {\n    if (!keyboardListener) {\n      return dashboard_utils_exports.noop;\n    }\n    const unsubscribeCancel = keyboardListener.subscribe(\n      \"cancel\",\n      () => handleItemSelected(null, [])\n    );\n    return () => {\n      unsubscribeCancel();\n    };\n  }, [handleItemSelected, keyboardListener]);\n  (0, react_exports.useEffect)(() => {\n    if (display === \"fit-to-width\" || display === \"auto-scale\") {\n      setFitToWidthAndScrollToTopLeft();\n    } else if (display === \"actual-size\") {\n      setScale(1);\n    } else {\n      setFitToWidthAndScrollToTopLeft(1);\n    }\n  }, [display, setFitToWidthAndScrollToTopLeft, setScale]);\n  if (previousScale != null && previousScale >= 1 && scale < 1 && featureFlags.enableZoomCenter) {\n    const previousLayout = getCanvasDomElement().parentElement;\n    if (previousLayout) {\n      savedScroll.current = {\n        x: previousLayout.scrollLeft + previousLayout.offsetWidth / 2,\n        y: previousLayout.scrollTop + previousLayout.offsetHeight / 2\n      };\n    }\n  }\n  (0, react_exports.useLayoutEffect)(() => {\n    var _a, _b;\n    if (fitToWidth || previousScale == null || previousScale === scale) {\n      return;\n    }\n    const layout = getCanvasDomElement().parentElement;\n    if (!layout) {\n      return;\n    }\n    const { offsetWidth, offsetHeight, scrollTop, scrollLeft } = layout;\n    if (previousScale < 1 && scale > 1 && ((_a = savedScroll == null ? void 0 : savedScroll.current) == null ? void 0 : _a.x) != null && ((_b = savedScroll == null ? void 0 : savedScroll.current) == null ? void 0 : _b.y) != null && featureFlags.enableZoomCenter) {\n      layout.scrollLeft = savedScroll.current.x - layout.offsetWidth / 2;\n      layout.scrollTop = savedScroll.current.y - layout.offsetHeight / 2;\n    } else {\n      const scaleRatio = scale / previousScale;\n      const newScroll = shiftViewportOnZoom({\n        offsetWidth,\n        offsetHeight,\n        scrollTop,\n        scrollLeft,\n        scaleRatio\n      });\n      layout.scrollLeft = newScroll.scrollLeft;\n      layout.scrollTop = newScroll.scrollTop;\n    }\n  }, [\n    featureFlags.enableZoomCenter,\n    fitToWidth,\n    getCanvasDomElement,\n    previousScale,\n    scale\n  ]);\n  (0, react_exports.useEffect)(() => {\n    if (!fitToWidth) {\n      return;\n    }\n    const newScale = computeScaleToFit({\n      canvasWidth: width,\n      canvasHeight: height,\n      containerWidth,\n      containerHeight,\n      max: fitToWidth,\n      scrollbarWidth\n    });\n    getZoomObserver().next(newScale);\n    setScaleInternal(newScale);\n  }, [\n    height,\n    getCanvasDomElement,\n    containerWidth,\n    containerHeight,\n    fitToWidth,\n    scrollbarWidth,\n    getZoomObserver,\n    width\n  ]);\n  (0, react_exports.useEffect)(() => {\n    if (activeLine && layoutStructureState[activeLine.id] == null) {\n      setActiveLine(null);\n    }\n  }, [activeLine, layoutStructureState]);\n  const image = (0, react_exports.useMemo)(\n    () => backgroundImage ? validateBackgroundImage({\n      backgroundImage,\n      canvasWidth: width,\n      canvasHeight: height\n    }) : {},\n    [backgroundImage, height, width]\n  );\n  const modeSpecificProps = (0, react_exports.useMemo)(\n    () => mode === \"edit\" ? {\n      movable: true,\n      showOverflowContent: true,\n      showGrid,\n      showBorder: true,\n      gridLineWidth: 1,\n      gridPadding: GRID_PADDING,\n      onItemMove: handleBlockItemMove,\n      onItemMoved: handleBlockItemMoved,\n      userSelect: false,\n      allowMultiselect: true\n    } : {\n      movable: false,\n      showOverflowContent: false,\n      showGrid: false,\n      showBorder: false,\n      userSelect: true,\n      allowMultiselect: false\n    },\n    [handleBlockItemMove, handleBlockItemMoved, mode, showGrid]\n  );\n  const allBlockItems = (0, react_exports.useMemo)(\n    () => getAllBlockItems({ layoutStructure, layoutStructureState }),\n    [layoutStructure, layoutStructureState]\n  );\n  const blockItemElements = (0, react_exports.useMemo)(() => {\n    return allBlockItems.map(({ item, type, position: { x, y, w, h } }) => /* @__PURE__ */ react_default.createElement(\n      ResponsiveBlockItem_default,\n      {\n        key: item,\n        itemId: item,\n        type,\n        x,\n        y,\n        w,\n        h,\n        canvasHeight: height,\n        renderLayoutItem,\n        onItemSelected: handleItemSelected,\n        isMouseDownEventRef\n      }\n    ));\n  }, [handleItemSelected, height, allBlockItems, renderLayoutItem]);\n  const lineElements = (0, react_exports.useMemo)(() => {\n    const selectedLineItems = findSelectedLineItems({\n      layoutStructure,\n      selectedItems\n    });\n    const selectable = mode === \"edit\";\n    return lineItems.map((line) => {\n      const editable = selectedLineItems.length === 1 && selectedLineItems[0].item === line.item && selectable;\n      let absPos = { from: { x: 0, y: 0 }, to: { x: 0, y: 0 } };\n      try {\n        absPos = computeLineAbsPosition({\n          layoutStructure: Object.values(layoutStructureState),\n          position: line.position\n        });\n      } catch (err) {\n        if (err instanceof Error && err.message.endsWith(InvalidBlockItemError)) {\n          absPos = computeLineAbsPosition({\n            layoutStructure: rawLayoutStructure,\n            position: line.position\n          });\n        }\n      }\n      const fromTestHooks = \"item\" in line.position.from && \"port\" in line.position.from ? {\n        fromItem: line.position.from.item,\n        fromPort: line.position.from.port\n      } : {};\n      const toTestHooks = \"item\" in line.position.to && \"port\" in line.position.to ? {\n        toItem: line.position.to.item,\n        toPort: line.position.to.port\n      } : {};\n      return /* @__PURE__ */ react_default.createElement(\n        ResponsiveLine_default,\n        __spreadValues(__spreadValues({\n          key: line.item,\n          lineId: line.item,\n          scale,\n          selectable,\n          editable,\n          renderLayoutItem,\n          onLineMove: handleLineMove,\n          onLineMoved: handleLineMoved,\n          onLineDragStart: handleLineDragStart,\n          onLineDrag: handleLineDrag,\n          onLineDragged: handleLineDragged,\n          onItemSelected: handleItemSelected,\n          fromX: absPos.from.x,\n          fromY: absPos.from.y,\n          toX: absPos.to.x,\n          toY: absPos.to.y\n        }, fromTestHooks), toTestHooks)\n      );\n    });\n  }, [\n    handleItemSelected,\n    handleLineDrag,\n    handleLineDragStart,\n    handleLineDragged,\n    handleLineMove,\n    handleLineMoved,\n    rawLayoutStructure,\n    layoutStructure,\n    layoutStructureState,\n    lineItems,\n    mode,\n    renderLayoutItem,\n    scale,\n    selectedItems\n  ]);\n  const outlineElements = (0, react_exports.useMemo)(() => {\n    const selectedLineItems = findSelectedLineItems({\n      layoutStructure: Object.values(layoutStructureState),\n      selectedItems\n    });\n    const selectedBlockItems = findSelectedBlockItems({\n      layoutStructure: Object.values(layoutStructureState),\n      selectedItems\n    });\n    return allBlockItems.map((block) => {\n      const connectable = mode === \"edit\" && selectedBlockItems.length === 0 && selectedLineItems.length === 1 && activeLine != null;\n      const resizable = mode === \"edit\" && selectedBlockItems.length === 1 && selectedBlockItems[0].item === block.item;\n      const selected = selectedBlockItems.findIndex((b) => b.item === block.item) >= 0;\n      if (!connectable && !resizable && !selected) {\n        return null;\n      }\n      const definition = dashboard_definition_exports.DashboardDefinition.fromJSON(\n        dashboardApi == null ? void 0 : dashboardApi.getDefinition()\n      );\n      const itemPresetType = definition.getItemPresetType(block.item);\n      const handleDirections = preset.getResizeHandleDirections(itemPresetType);\n      return /* @__PURE__ */ react_default.createElement(\n        ResponsiveBlockOutline_default,\n        {\n          key: block.item,\n          itemId: block.item,\n          x: block.position.x,\n          y: block.position.y,\n          w: block.position.w,\n          h: block.position.h,\n          scale,\n          connectable,\n          resizable,\n          onResize: handleBlockItemResize,\n          onResized: handleBlockItemResized,\n          onLineConnect: handleLineConnected,\n          onLineDisconnect: handleLineDisconnected,\n          handleDirections\n        }\n      );\n    });\n  }, [\n    layoutStructureState,\n    selectedItems,\n    allBlockItems,\n    mode,\n    activeLine,\n    dashboardApi,\n    preset,\n    scale,\n    handleBlockItemResize,\n    handleBlockItemResized,\n    handleLineConnected,\n    handleLineDisconnected\n  ]);\n  const handleMouseDownCapture = (0, react_exports.useCallback)(() => {\n    isMouseDownEventRef.current = true;\n  }, []);\n  const handleMouseUpCapture = (0, react_exports.useCallback)(() => {\n    isMouseDownEventRef.current = false;\n  }, []);\n  return /* @__PURE__ */ react_default.createElement(\n    AbsoluteCanvas_default,\n    __spreadValues({\n      \"data-test\": \"absolute-layout\",\n      blockItems,\n      width,\n      height,\n      scale,\n      gridWidth: GRID_SIZE - 1,\n      gridHeight: GRID_SIZE - 1,\n      backgroundColor,\n      backgroundImageSrc: image.src,\n      backgroundImageSizeType: image.sizeType,\n      backgroundImageWidth: image.w,\n      backgroundImageHeight: image.h,\n      backgroundImagePositionX: image.x,\n      backgroundImagePositionY: image.y,\n      selectedLayoutItems: selectedItems,\n      onItemSelected: handleItemSelected,\n      ref: canvasRef,\n      onMouseDownCapture: handleMouseDownCapture,\n      onMouseUpCapture: handleMouseUpCapture\n    }, modeSpecificProps),\n    /* @__PURE__ */ react_default.createElement(\n      Layer_default,\n      {\n        key: \"block-item-layer\",\n        \"data-test\": \"block-item-layer\",\n        zIndex: 0\n      },\n      lineElements,\n      blockItemElements.map((el, i) => /* @__PURE__ */ react_default.createElement(react_default.Fragment, { key: el.key }, el, /* @__PURE__ */ react_default.createElement(\n        Layer_default,\n        {\n          key: \"outline-layer\",\n          \"data-test\": \"outline-layer\",\n          zIndex: 1\n        },\n        outlineElements[i]\n      )))\n    )\n  );\n};\nvar AbsoluteLayout_default = withLayoutShowHide(AbsoluteLayout, {\n  schema: absoluteLayoutOptionsSchema_default\n});\n\n// src/AbsoluteLayoutViewer.tsx\nvar AbsoluteLayoutViewer = ({\n  containerWidth,\n  containerHeight,\n  layoutStructure = [],\n  renderLayoutItem,\n  options = {}\n}) => {\n  const {\n    width,\n    height,\n    backgroundColor,\n    backgroundImage = {},\n    display\n  } = __spreadValues(__spreadValues({}, absoluteLayoutOptions), options);\n  const scrollbarWidth = (0, react_exports.useMemo)(() => (0, dashboard_utils_exports.getScrollbarWidth)(), []);\n  const scale = (0, react_exports.useMemo)(() => {\n    switch (display) {\n      case \"fit-to-width\":\n      case \"auto-scale\":\n        return computeScaleToFit({\n          canvasWidth: width,\n          canvasHeight: height,\n          containerWidth,\n          containerHeight,\n          scrollbarWidth\n        });\n      case \"actual-size\":\n        return 1;\n      default:\n        return computeScaleToFit({\n          canvasWidth: width,\n          canvasHeight: height,\n          containerWidth,\n          containerHeight,\n          scrollbarWidth,\n          max: 1\n        });\n    }\n  }, [\n    display,\n    height,\n    width,\n    containerWidth,\n    containerHeight,\n    scrollbarWidth\n  ]);\n  const image = (0, react_exports.useMemo)(\n    () => backgroundImage ? validateBackgroundImage({\n      backgroundImage,\n      canvasWidth: width,\n      canvasHeight: height\n    }) : {},\n    [backgroundImage, height, width]\n  );\n  const renderLines = (0, react_exports.useMemo)(() => {\n    const lineItems = layoutStructure.filter(\n      ({ type }) => type === \"line\"\n    );\n    return lineItems.map(({ item, position }) => {\n      const absPosition = computeLineAbsPosition({\n        layoutStructure,\n        position\n      });\n      return /* @__PURE__ */ react_default.createElement(\n        ResponsiveLine_default,\n        {\n          key: item,\n          lineId: item,\n          scale,\n          fromX: absPosition.from.x,\n          toX: absPosition.to.x,\n          fromY: absPosition.from.y,\n          toY: absPosition.to.y,\n          renderLayoutItem\n        }\n      );\n    });\n  }, [layoutStructure, scale, renderLayoutItem]);\n  const renderBlockItems2 = (0, react_exports.useMemo)(() => {\n    const blockItems = layoutStructure.filter(\n      ({ type }) => type !== \"line\"\n    );\n    return blockItems.map(({ item, type, position }) => {\n      const { x, y, w, h } = position;\n      return /* @__PURE__ */ react_default.createElement(\n        AbsoluteItem_default,\n        {\n          itemId: item,\n          type,\n          key: item,\n          x,\n          y,\n          w,\n          h,\n          renderLayoutItem\n        }\n      );\n    });\n  }, [renderLayoutItem, layoutStructure]);\n  return /* @__PURE__ */ react_default.createElement(\n    Canvas_default,\n    {\n      \"data-layout-type\": \"absolute\",\n      width,\n      height,\n      scale,\n      showGrid: false,\n      backgroundColor,\n      backgroundImageSrc: image.src,\n      backgroundImageSizeType: image.sizeType,\n      backgroundImageWidth: image.w,\n      backgroundImageHeight: image.h,\n      backgroundImagePositionX: image.x,\n      backgroundImagePositionY: image.y\n    },\n    renderBlockItems2,\n    renderLines\n  );\n};\nvar AbsoluteLayoutViewer_default = AbsoluteLayoutViewer;\n\n// src/BaseLayout.jsx\nvar BaseLayout = class extends react_exports.Component {\n  render() {\n    return null;\n  }\n};\n__publicField(BaseLayout, \"propTypes\", {\n  /**\n   * dashboard mode\n   */\n  mode: prop_types_default.string,\n  /**\n   * whether gridlines should be displayed in edit mode\n   */\n  showGrid: prop_types_default.bool,\n  /**\n   * layout formatting options\n   */\n  options: prop_types_default.object,\n  /**\n   * layout structure\n   */\n  layoutStructure: prop_types_default.arrayOf(prop_types_default.any),\n  /**\n   * container width in pixel\n   */\n  containerWidth: prop_types_default.number,\n  /**\n   * container height in pixel\n   */\n  containerHeight: prop_types_default.number,\n  /**\n   * list of selected items\n   */\n  selectedItems: prop_types_default.arrayOf(\n    prop_types_default.shape({ id: prop_types_default.string, type: prop_types_default.oneOf([\"block\", \"line\", \"input\"]) })\n  ),\n  /**\n   * layout item render prop\n   */\n  renderLayoutItem: prop_types_default.func,\n  /**\n   * callback when items are selected\n   */\n  onLayoutItemsSelect: prop_types_default.func,\n  /**\n   * callback to trigger event\n   */\n  onEventTrigger: prop_types_default.func,\n  /**\n   * callback when layout structure changed\n   */\n  onLayoutStructureChange: prop_types_default.func,\n  /**\n   * layoutApi ref\n   */\n  layoutApiRef: prop_types_default.func\n});\n__publicField(BaseLayout, \"defaultProps\", {\n  mode: \"view\",\n  options: {},\n  showGrid: true,\n  layoutStructure: [],\n  selectedItems: [],\n  renderLayoutItem: dashboard_utils_exports.noop,\n  onEventTrigger: dashboard_utils_exports.noop,\n  onLayoutStructureChange: dashboard_utils_exports.noop,\n  onLayoutItemsSelect: dashboard_utils_exports.noop,\n  layoutApiRef: dashboard_utils_exports.noop\n});\nvar BaseLayout_default = BaseLayout;\n\n// esm-externals:memoize-one\nvar memoize_one_exports = {};\n__export(memoize_one_exports, {\n  default: () => memoize_one_default\n});\nvar defaultImport16 = __toESM(require(\"memoize-one\"));\n__reExport(memoize_one_exports, require(\"memoize-one\"));\nvar memoize_one_default = \"default\" in defaultImport16 ? defaultImport16.default : defaultImport16;\n\n// src/gridLayoutOptionsSchema.ts\nvar gridLayoutOptionsSchema_default = {\n  gutterSize: {\n    type: \"number\",\n    default: 8,\n    minimum: 8,\n    maximum: 16,\n    description: \"A number that represents the size of the gutter between visualizations in pixels. The minimum value is 8 and maximum value is 16.\"\n  }\n};\n\n// src/utils/gridLayoutUtils.ts\nvar resetLayoutAction = (payload) => ({\n  type: \"structure/reset\",\n  payload\n});\nvar updateItemAction = (payload) => ({\n  type: \"structure/update\",\n  payload\n});\nvar getBlockItems = (state) => Object.values(state);\nvar filterSelectedItems = (state, selectedItems = []) => {\n  const itemKeys = state.map(({ item }) => item);\n  return selectedItems.filter(({ id }) => itemKeys.indexOf(id) >= 0);\n};\nvar getStructureItem = (state, itemId) => state.find(({ item }) => item === itemId);\nvar getItem = (state, itemId) => state[itemId];\nvar hasPreviewItem = (state, itemId = \"preview-old-item\") => !!state[itemId];\nvar getFilteredStructure = (state, layoutStructure) => {\n  const result = [];\n  layoutStructure.forEach((item) => {\n    result.push(state[item.item] || item);\n  });\n  if (hasPreviewItem(state)) {\n    result.push(state[\"preview-old-item\"]);\n  }\n  return result;\n};\nvar initializeGridReducer = (layoutStructure = []) => {\n  const gridLayout = {};\n  layoutStructure.forEach((item) => {\n    gridLayout[item.item] = item;\n  });\n  return gridLayout;\n};\nvar gridReducer = (state, action) => {\n  switch (action.type) {\n    case \"structure/reset\":\n      return initializeGridReducer(action.payload);\n    case \"structure/update\":\n      return __spreadProps(__spreadValues({}, state), {\n        [action.payload.item]: action.payload\n      });\n    default:\n      return state;\n  }\n};\n\n// src/utils/gridOrderUtils.ts\nvar trackItemsByCoordinate = (layout) => {\n  const result = {};\n  layout.forEach((item) => {\n    var _a, _b;\n    (_b = result[_a = item.position.y]) != null ? _b : result[_a] = {};\n    result[item.position.y][item.position.x] = item;\n  });\n  return result;\n};\nvar getItemsInCoordinateRange = ({\n  itemCoordinateMap,\n  range\n}) => {\n  if (!range) {\n    return Object.values(itemCoordinateMap).flatMap(Object.values);\n  }\n  const { x: fromX = 0, y: fromY = 0 } = range.from || {};\n  const {\n    x: toX = Number.POSITIVE_INFINITY,\n    y: toY = Number.POSITIVE_INFINITY\n  } = range.to || {};\n  return Object.keys(itemCoordinateMap).map((key) => parseInt(key, 10)).filter((yPos) => yPos >= fromY && yPos < toY).reduce((acc, yPos) => {\n    Object.keys(itemCoordinateMap[yPos]).forEach((key) => {\n      const xPos = parseInt(key, 10);\n      if (xPos >= fromX && xPos < toX) {\n        acc.push(itemCoordinateMap[yPos][xPos]);\n      }\n    });\n    return acc;\n  }, []);\n};\nvar getVizAtCoord = ({\n  x,\n  y,\n  nodes\n}) => nodes[x][y].find((viz) => viz.position.x === x && viz.position.y === y);\nvar isFullEdge = ({\n  x,\n  y,\n  nodes,\n  gridWidth,\n  gridHeight,\n  type\n}) => {\n  if (x === gridWidth || y === gridHeight) {\n    return true;\n  }\n  const originViz = getVizAtCoord({ x, y, nodes });\n  if (!originViz) {\n    return false;\n  }\n  return isFullEdge({\n    x: type === \"horizontal\" ? x + originViz.position.w : x,\n    y: type === \"vertical\" ? y + originViz.position.h : y,\n    nodes,\n    gridWidth,\n    gridHeight,\n    type\n  });\n};\nvar splitGridByRows = ({\n  nodes,\n  layout,\n  gridWidth,\n  gridHeight,\n  originViz,\n  alwaysIncludeLastRow = false\n}) => {\n  const { x, y, h } = originViz.position;\n  const itemCoordinateMap = trackItemsByCoordinate(layout);\n  const newGrids = [];\n  let lastHorizontalEdgeY = y;\n  let nextViz = getVizAtCoord({ x, y: y + h, nodes });\n  while (nextViz && nextViz.position.y < gridHeight) {\n    if (isFullEdge({\n      x,\n      y: nextViz.position.y,\n      nodes,\n      gridWidth,\n      gridHeight,\n      type: \"horizontal\"\n    })) {\n      const rowItems = getItemsInCoordinateRange({\n        itemCoordinateMap,\n        range: {\n          from: { y: lastHorizontalEdgeY },\n          to: { y: nextViz.position.y }\n        }\n      });\n      newGrids.push({\n        nodes,\n        layout,\n        gridWidth,\n        gridHeight: nextViz.position.y,\n        origin: { x, y: lastHorizontalEdgeY },\n        content: {\n          // the width of the split is the full grid width less the origin of the split\n          width: gridWidth - x,\n          // the height of the split is the top of the next split less the origin of the current split\n          height: nextViz.position.y - lastHorizontalEdgeY,\n          items: rowItems\n        }\n      });\n      lastHorizontalEdgeY = nextViz.position.y;\n    }\n    nextViz = getVizAtCoord({\n      x,\n      y: nextViz.position.y + nextViz.position.h,\n      nodes\n    });\n  }\n  if (newGrids.length === 0 && !alwaysIncludeLastRow) {\n    return [];\n  }\n  const lastRowItems = getItemsInCoordinateRange({\n    itemCoordinateMap,\n    range: {\n      from: { y: lastHorizontalEdgeY }\n    }\n  });\n  newGrids.push({\n    nodes,\n    layout,\n    gridWidth,\n    gridHeight,\n    origin: { x, y: lastHorizontalEdgeY },\n    content: {\n      width: gridWidth - x,\n      height: gridHeight - lastHorizontalEdgeY,\n      items: lastRowItems\n    }\n  });\n  return newGrids;\n};\nvar splitGridByColumns = ({\n  nodes,\n  layout,\n  gridWidth,\n  gridHeight,\n  originViz\n}) => {\n  const { x, y, w } = originViz.position;\n  const itemCoordinateMap = trackItemsByCoordinate(layout);\n  const newGrids = [];\n  let lastVerticalEdgeX = x;\n  let nextViz = getVizAtCoord({ x: x + w, y, nodes });\n  while (nextViz && nextViz.position.x < gridWidth) {\n    if (isFullEdge({\n      x: nextViz.position.x,\n      y,\n      nodes,\n      gridWidth,\n      gridHeight,\n      type: \"vertical\"\n    })) {\n      const colItems = getItemsInCoordinateRange({\n        itemCoordinateMap,\n        range: {\n          from: { x: lastVerticalEdgeX },\n          to: { x: nextViz.position.x }\n        }\n      });\n      newGrids.push({\n        nodes,\n        layout,\n        gridWidth: nextViz.position.x,\n        gridHeight,\n        origin: { x: lastVerticalEdgeX, y },\n        content: {\n          // the width of the split is the left-edge of the next column less the origin of the current column\n          width: nextViz.position.x - lastVerticalEdgeX,\n          // the height of the split is the height of the grid less the origin of the column\n          height: gridHeight - y,\n          items: colItems\n        }\n      });\n      lastVerticalEdgeX = nextViz.position.x;\n    }\n    nextViz = getVizAtCoord({\n      x: nextViz.position.x + nextViz.position.w,\n      y,\n      nodes\n    });\n  }\n  if (newGrids.length === 0) {\n    return [];\n  }\n  const lastColumnItems = getItemsInCoordinateRange({\n    itemCoordinateMap,\n    range: {\n      from: { x: lastVerticalEdgeX }\n    }\n  });\n  newGrids.push({\n    nodes,\n    layout,\n    gridWidth,\n    gridHeight,\n    origin: { x: lastVerticalEdgeX, y },\n    content: {\n      width: gridWidth - lastVerticalEdgeX,\n      height: gridHeight - y,\n      items: lastColumnItems\n    }\n  });\n  return newGrids;\n};\nvar splitGridByRowsAndColumns = ({\n  origin,\n  nodes,\n  layout,\n  newLayout,\n  gridWidth,\n  gridHeight\n}) => {\n  const originViz = getVizAtCoord({ x: origin.x, y: origin.y, nodes });\n  if (!originViz) {\n    throw new Error(\"Getting grid layout order failed\");\n  }\n  if (originViz.position.x + originViz.position.w === gridWidth && originViz.position.y + originViz.position.h === gridHeight) {\n    newLayout.push(originViz);\n    return;\n  }\n  let newGrids = splitGridByRows({\n    nodes,\n    layout,\n    originViz,\n    gridHeight,\n    gridWidth\n  });\n  newGrids.forEach(\n    (gridInfo) => splitGridByRowsAndColumns(__spreadProps(__spreadValues({}, gridInfo), { newLayout }))\n  );\n  if (newGrids.length > 0) {\n    return;\n  }\n  newGrids = splitGridByColumns({\n    nodes,\n    layout,\n    originViz,\n    gridHeight,\n    gridWidth\n  });\n  newGrids.forEach(\n    (gridInfo) => splitGridByRowsAndColumns(__spreadProps(__spreadValues({}, gridInfo), { newLayout }))\n  );\n  if (newGrids.length === 0) {\n    const vizInCurrentGrid = [];\n    layout.forEach((viz) => {\n      const { x, y, w, h } = viz.position;\n      if (x >= origin.x && x + w <= gridWidth && y >= origin.y && y + h <= gridHeight) {\n        vizInCurrentGrid.push(viz);\n      }\n    });\n    const sortedViz = vizInCurrentGrid.sort((viz1, viz2) => {\n      if (viz1.position.y < viz2.position.y) {\n        return -1;\n      }\n      if (viz1.position.y > viz2.position.y) {\n        return 1;\n      }\n      if (viz1.position.x < viz2.position.x) {\n        return -1;\n      }\n      if (viz1.position.x > viz2.position.x) {\n        return 1;\n      }\n      return 0;\n    });\n    newLayout.push(...sortedViz);\n  }\n};\nvar getGridLayoutOrder = ({\n  layout,\n  canvasWidth,\n  canvasHeight\n}) => {\n  const nodes = getNodes(layout);\n  if (nodes === null || nodes[0] === void 0 || nodes[0][0] === void 0) {\n    return layout;\n  }\n  const newLayout = [];\n  try {\n    splitGridByRowsAndColumns({\n      origin: { x: 0, y: 0 },\n      nodes,\n      layout,\n      newLayout,\n      gridWidth: canvasWidth,\n      gridHeight: canvasHeight\n    });\n  } catch (e) {\n    return layout;\n  }\n  if (newLayout.length !== layout.length) {\n    return layout;\n  }\n  return newLayout;\n};\n\n// src/utils/gridUtils.ts\nvar formatEdgeWrapper = ({\n  edge,\n  padding = 0\n}) => {\n  const wrapperStart = __spreadValues({}, edge.edgeStart);\n  const wrapperEnd = __spreadValues({}, edge.edgeEnd);\n  if (edge.orientation === \"horizontal\") {\n    wrapperStart.x += padding;\n    wrapperEnd.x -= padding;\n    wrapperStart.y -= padding;\n    wrapperEnd.y -= padding;\n  } else {\n    wrapperStart.y += padding;\n    wrapperEnd.y -= padding;\n    wrapperStart.x -= padding;\n    wrapperEnd.x -= padding;\n  }\n  return __spreadProps(__spreadValues({}, edge), { edgeStart: wrapperStart, edgeEnd: wrapperEnd });\n};\nvar getDimensions = ({\n  edge,\n  thickness\n}) => {\n  return {\n    width: edge.orientation === \"horizontal\" ? edge.edgeEnd.x - edge.edgeStart.x : thickness,\n    height: edge.orientation === \"vertical\" ? edge.edgeEnd.y - edge.edgeStart.y : thickness\n  };\n};\nvar isMouseOnEdge = ({\n  edge,\n  mousePosition,\n  padding = 0\n}) => {\n  const formattedEdge = formatEdgeWrapper({ edge, padding });\n  const { width, height } = getDimensions({\n    edge: formattedEdge,\n    thickness: 2 * padding\n  });\n  return mousePosition.x <= formattedEdge.edgeStart.x + width && mousePosition.x >= formattedEdge.edgeStart.x && mousePosition.y <= formattedEdge.edgeStart.y + height && mousePosition.y >= formattedEdge.edgeStart.y;\n};\nvar computeNewVizPositionsGutterCase = ({\n  edge,\n  itemToMove,\n  items\n}) => {\n  const updatedVisualizations = [];\n  items.forEach((item) => {\n    if (item.position.y >= edge.edgeStart.y) {\n      const viz = item.item === itemToMove.item ? __spreadProps(__spreadValues({}, item), { item: \"itemToRemove\" }) : item;\n      updatedVisualizations.push(__spreadProps(__spreadValues({}, viz), {\n        position: __spreadProps(__spreadValues({}, viz.position), {\n          y: viz.position.y + itemToMove.position.h\n        })\n      }));\n    }\n  });\n  updatedVisualizations.push(__spreadProps(__spreadValues({}, itemToMove), {\n    position: __spreadProps(__spreadValues({}, itemToMove.position), {\n      // height is preserved\n      y: edge.edgeStart.y,\n      x: edge.edgeStart.x,\n      w: edge.edgeEnd.x - edge.edgeStart.x\n    })\n  }));\n  return updatedVisualizations;\n};\nvar sizeToTakeFromViz = ({\n  amountToTake,\n  edge,\n  minWidth,\n  minHeight\n}) => {\n  const reduction = edge.visualizations.reduce(\n    (acc, viz) => {\n      if (acc === null) {\n        return null;\n      }\n      if (edge.orientation === \"vertical\") {\n        const widthToTake = Math.ceil(viz.position.w * amountToTake);\n        if (viz.position.w - widthToTake < minWidth) {\n          return null;\n        }\n        if (viz.position.x < edge.edgeStart.x) {\n          return __spreadProps(__spreadValues({}, acc), {\n            firstHalf: [...acc.firstHalf, widthToTake]\n          });\n        }\n        return __spreadProps(__spreadValues({}, acc), {\n          secondHalf: [...acc.secondHalf, widthToTake]\n        });\n      }\n      const heightToTake = Math.ceil(viz.position.h * amountToTake);\n      if (viz.position.h - heightToTake < minHeight) {\n        return null;\n      }\n      if (viz.position.y < edge.edgeStart.y) {\n        return __spreadProps(__spreadValues({}, acc), {\n          firstHalf: [...acc.firstHalf, heightToTake]\n        });\n      }\n      return __spreadProps(__spreadValues({}, acc), {\n        secondHalf: [...acc.secondHalf, heightToTake]\n      });\n    },\n    { firstHalf: [], secondHalf: [] }\n  );\n  if (reduction === null) {\n    return {\n      firstHalf: null,\n      secondHalf: null\n    };\n  }\n  return {\n    firstHalf: reduction.firstHalf.length === 0 ? 0 : Math.min(...reduction.firstHalf),\n    secondHalf: reduction.secondHalf.length === 0 ? 0 : Math.min(...reduction.secondHalf)\n  };\n};\nvar computeNewVizPositions = ({\n  edge,\n  itemToMove,\n  firstHalf,\n  secondHalf\n}) => {\n  const updatedVisualizations = [];\n  edge.visualizations.forEach((edgeViz) => {\n    const viz = edgeViz.item === itemToMove.item ? __spreadProps(__spreadValues({}, edgeViz), { item: \"itemToRemove\" }) : edgeViz;\n    if (edge.orientation === \"horizontal\") {\n      if (viz.position.y < edge.edgeStart.y) {\n        updatedVisualizations.push(\n          updateBlockItemSize({\n            item: __spreadValues({}, viz),\n            offset: { offsetY: -1 * firstHalf, offsetX: 0 },\n            dir: \"s\"\n          })\n        );\n      }\n      if (viz.position.y >= edge.edgeStart.y) {\n        updatedVisualizations.push(\n          updateBlockItemSize({\n            item: __spreadValues({}, viz),\n            offset: { offsetY: secondHalf, offsetX: 0 },\n            dir: \"n\"\n          })\n        );\n      }\n    } else {\n      if (viz.position.x < edge.edgeStart.x) {\n        updatedVisualizations.push(\n          updateBlockItemSize({\n            item: __spreadValues({}, viz),\n            offset: { offsetX: -1 * firstHalf, offsetY: 0 },\n            dir: \"e\"\n          })\n        );\n      }\n      if (viz.position.x >= edge.edgeStart.x) {\n        updatedVisualizations.push(\n          updateBlockItemSize({\n            item: __spreadValues({}, viz),\n            offset: { offsetX: secondHalf, offsetY: 0 },\n            dir: \"w\"\n          })\n        );\n      }\n    }\n  });\n  updatedVisualizations.push(__spreadProps(__spreadValues({}, itemToMove), {\n    position: {\n      x: edge.edgeStart.x - (edge.orientation === \"vertical\" ? firstHalf : 0),\n      y: edge.edgeStart.y - (edge.orientation === \"horizontal\" ? firstHalf : 0),\n      w: edge.orientation === \"vertical\" ? firstHalf + secondHalf : edge.edgeEnd.x - edge.edgeStart.x,\n      h: edge.orientation === \"horizontal\" ? firstHalf + secondHalf : edge.edgeEnd.y - edge.edgeStart.y\n    }\n  }));\n  return updatedVisualizations;\n};\nvar isResultingVizSizeGreaterThanMin = ({\n  size,\n  edgeOrientation\n}) => {\n  if (edgeOrientation === \"vertical\") {\n    return size >= MIN_WIDTH_PX;\n  }\n  return size >= MIN_HEIGHT_PX;\n};\nvar updateItems = ({\n  updatedVisualizations,\n  itemToMove,\n  items,\n  canvasWidth\n}) => {\n  const updatedItems = [\n    ...items.filter(\n      (item) => updatedVisualizations.find((viz) => viz.item === item.item) === void 0\n    ),\n    ...updatedVisualizations\n  ];\n  const updatedNeighbors = (0, dashboard_utils_exports.updateRemovedVizNeighbors)({\n    itemToRemove: itemToMove,\n    items: updatedItems,\n    width: canvasWidth\n  });\n  const filteredUpdatedVisualizations = updatedVisualizations.filter(\n    (viz) => updatedNeighbors.find((neighbor) => neighbor.item === viz.item) === void 0 && viz.item !== \"itemToRemove\"\n  );\n  const filteredItems = items.filter(\n    (viz) => updatedNeighbors.find((neighbor) => neighbor.item === viz.item) === void 0 && filteredUpdatedVisualizations.find(\n      (updatedViz) => updatedViz.item === viz.item\n    ) === void 0 && viz.item !== itemToMove.item\n  );\n  return [\n    ...filteredItems,\n    ...filteredUpdatedVisualizations,\n    ...updatedNeighbors\n  ];\n};\nvar isDropOnOwnEdge = ({\n  edge,\n  itemToMove\n}) => edge.visualizations.find((viz) => viz.item === itemToMove.item) != null && (edge.orientation === \"horizontal\" && itemToMove.position.w === edge.edgeEnd.x - edge.edgeStart.x || edge.orientation === \"vertical\" && itemToMove.position.h === edge.edgeEnd.y - edge.edgeStart.y);\nvar updateDropOnEdge = ({\n  edge,\n  itemToMove,\n  items,\n  canvasWidth\n}) => {\n  if (isDropOnOwnEdge({ edge, itemToMove })) {\n    return null;\n  }\n  const amountToTake = 1 / 3;\n  let updatedVisualizations = [];\n  if (edge.orientation === \"horizontal\" && edge.edgeEnd.x - edge.edgeStart.x === canvasWidth) {\n    updatedVisualizations = computeNewVizPositionsGutterCase({\n      edge,\n      itemToMove,\n      items\n    });\n  } else {\n    const { firstHalf, secondHalf } = sizeToTakeFromViz({\n      amountToTake,\n      edge,\n      minWidth: MIN_WIDTH_PX,\n      minHeight: MIN_HEIGHT_PX\n    });\n    if (firstHalf === null || secondHalf === null || // Check if the moved viz resulting size will be greater than the minimum width/height\n    // This particular case occurs when adding to the top and bottom canvas edge\n    !isResultingVizSizeGreaterThanMin({\n      size: firstHalf + secondHalf,\n      edgeOrientation: edge.orientation\n    })) {\n      return null;\n    }\n    updatedVisualizations = computeNewVizPositions({\n      edge,\n      itemToMove,\n      firstHalf,\n      secondHalf\n    });\n  }\n  const updatedItemToMove = updatedVisualizations.find((viz) => viz.item === \"itemToRemove\") || itemToMove;\n  return { updatedVisualizations, updatedItemToMove };\n};\nvar positionInItemBoundary = ({\n  item,\n  position\n}) => {\n  return position.x >= item.position.x && position.x <= item.position.x + item.position.w && position.y >= item.position.y && position.y <= item.position.y + item.position.h;\n};\nvar findQuadrant = ({\n  item,\n  position\n}) => {\n  if (positionInItemBoundary({ item, position })) {\n    let { x, y } = position;\n    x -= item.position.x;\n    y -= item.position.y;\n    const slope = item.position.h / item.position.w;\n    let quadrant;\n    if (y > slope * x) {\n      quadrant = [\"w\", \"s\"];\n    } else {\n      quadrant = [\"n\", \"e\"];\n    }\n    return y < -slope * x + item.position.h ? quadrant[0] : quadrant[1];\n  }\n  return null;\n};\nvar updateDropOnViz = ({\n  itemToMove,\n  itemToDropOn,\n  direction\n}) => {\n  if ((direction === \"e\" || direction === \"w\") && itemToDropOn.position.w < MIN_WIDTH_PX * 2 || (direction === \"n\" || direction === \"s\") && itemToDropOn.position.h < MIN_WIDTH_PX * 2) {\n    return null;\n  }\n  let vizToMove = __spreadProps(__spreadValues({}, itemToMove), {\n    position: itemToDropOn.position\n  });\n  let vizTarget = __spreadValues({}, itemToDropOn);\n  switch (direction) {\n    case \"n\":\n      vizToMove = updateBlockItemSize({\n        item: vizToMove,\n        offset: {\n          offsetY: -Math.floor(vizToMove.position.h / 2),\n          offsetX: 0\n        },\n        dir: \"s\"\n      });\n      vizTarget = updateBlockItemSize({\n        item: vizTarget,\n        offset: {\n          offsetY: Math.ceil(vizTarget.position.h / 2),\n          offsetX: 0\n        },\n        dir: \"n\"\n      });\n      break;\n    case \"s\":\n      vizToMove = updateBlockItemSize({\n        item: vizToMove,\n        offset: {\n          offsetY: Math.floor(vizToMove.position.h / 2),\n          offsetX: 0\n        },\n        dir: \"n\"\n      });\n      vizTarget = updateBlockItemSize({\n        item: vizTarget,\n        offset: {\n          offsetY: -Math.ceil(vizTarget.position.h / 2),\n          offsetX: 0\n        },\n        dir: \"s\"\n      });\n      break;\n    case \"w\":\n      vizToMove = updateBlockItemSize({\n        item: vizToMove,\n        offset: {\n          offsetX: -Math.floor(vizToMove.position.w / 2),\n          offsetY: 0\n        },\n        dir: \"e\"\n      });\n      vizTarget = updateBlockItemSize({\n        item: vizTarget,\n        offset: {\n          offsetX: Math.ceil(vizTarget.position.w / 2),\n          offsetY: 0\n        },\n        dir: \"w\"\n      });\n      break;\n    case \"e\":\n      vizToMove = updateBlockItemSize({\n        item: vizToMove,\n        offset: {\n          offsetX: Math.floor(vizToMove.position.w / 2),\n          offsetY: 0\n        },\n        dir: \"w\"\n      });\n      vizTarget = updateBlockItemSize({\n        item: vizTarget,\n        offset: {\n          offsetX: -Math.ceil(vizTarget.position.w / 2),\n          offsetY: 0\n        },\n        dir: \"e\"\n      });\n      break;\n    default:\n      vizToMove = itemToMove;\n      break;\n  }\n  return [vizToMove, vizTarget];\n};\nvar previewDropOnEdge = ({\n  edge,\n  itemToMove,\n  items,\n  canvasWidth\n}) => {\n  const updatedItems = updateDropOnEdge({\n    edge,\n    itemToMove,\n    items,\n    canvasWidth\n  });\n  if (!updatedItems) {\n    return null;\n  }\n  let { updatedVisualizations } = updatedItems;\n  const { updatedItemToMove } = updatedItems;\n  updatedVisualizations = updatedVisualizations.filter(\n    (viz) => !(0, lodash_exports.isEqual)(viz, updatedItemToMove)\n  );\n  return [\n    ...items.filter(\n      (item) => updatedVisualizations.find((viz) => viz.item === item.item) === void 0\n    ),\n    ...updatedVisualizations,\n    __spreadProps(__spreadValues({}, updatedItemToMove), {\n      item: \"preview-old-item\"\n    })\n  ];\n};\nvar previewDropOnViz = ({\n  itemToDropOn,\n  itemToMove,\n  items,\n  direction\n}) => {\n  const updatedItems = updateDropOnViz({\n    itemToMove,\n    itemToDropOn,\n    direction\n  });\n  if (!updatedItems) {\n    return null;\n  }\n  return [\n    ...items.filter(\n      (item) => updatedItems.find((viz) => viz.item === item.item) === void 0\n    ),\n    ...updatedItems,\n    __spreadProps(__spreadValues({}, itemToMove), {\n      item: \"preview-old-item\"\n    })\n  ];\n};\nvar findItemsOutsideBoundary = ({\n  items,\n  boundary\n}) => {\n  const invalidItems = [];\n  const message = (0, i18n_exports._)(\"is outside of canvas bounds\");\n  items.forEach((item) => {\n    if (item.position.x < boundary.x || item.position.x + item.position.w > boundary.x + boundary.w || item.position.y < boundary.y || item.position.y + item.position.h > boundary.y + boundary.h) {\n      invalidItems.push({\n        itemId: item.item,\n        messages: [`\"${item.item}\" ${message}`]\n      });\n    }\n  });\n  return invalidItems;\n};\nvar getItemEdges = ({\n  item,\n  belongsTo = {}\n}) => {\n  const topEdge = {\n    start: { x: item.x, y: item.y },\n    end: { x: item.x + item.w, y: item.y },\n    orientation: \"horizontal\",\n    type: \"above\",\n    belongsTo\n  };\n  const bottomEdge = {\n    start: { x: item.x, y: item.y + item.h },\n    end: { x: item.x + item.w, y: item.y + item.h },\n    orientation: \"horizontal\",\n    type: \"below\",\n    belongsTo\n  };\n  const leftEdge = {\n    start: { x: item.x, y: item.y },\n    end: { x: item.x, y: item.y + item.h },\n    orientation: \"vertical\",\n    type: \"left\",\n    belongsTo\n  };\n  const rightEdge = {\n    start: { x: item.x + item.w, y: item.y },\n    end: { x: item.x + item.w, y: item.y + item.h },\n    orientation: \"vertical\",\n    type: \"right\",\n    belongsTo\n  };\n  return [topEdge, bottomEdge, leftEdge, rightEdge];\n};\nvar createEdges = ({\n  items,\n  canvasBounds\n}) => {\n  const edges = [];\n  items.forEach((item) => {\n    edges.push(\n      ...getItemEdges({ item: item.position, belongsTo: item.position })\n    );\n  });\n  edges.push(...getItemEdges({ item: canvasBounds }));\n  return edges;\n};\nvar findInvalidItemEdges = ({\n  item,\n  edges\n}) => {\n  const invalidEdges = [];\n  const curEdges = getItemEdges({\n    item: item.position,\n    belongsTo: item.position\n  });\n  curEdges.forEach((curEdge) => {\n    const overlappingEdge = edges.find((edge) => {\n      if (curEdge.orientation !== edge.orientation || (0, lodash_exports.isEqual)(curEdge.belongsTo, edge.belongsTo)) {\n        return false;\n      }\n      if (curEdge.orientation === \"horizontal\" && curEdge.start.y === edge.start.y) {\n        if (curEdge.start.x >= edge.end.x || edge.start.x >= curEdge.end.x) {\n          return false;\n        }\n        return true;\n      }\n      if (curEdge.orientation === \"vertical\" && curEdge.start.x === edge.start.x) {\n        if (curEdge.start.y >= edge.end.y || edge.start.y >= curEdge.end.y) {\n          return false;\n        }\n        return true;\n      }\n      return false;\n    });\n    if (overlappingEdge === void 0) {\n      const positionString = curEdge.orientation === \"horizontal\" ? `y=${curEdge.start.y}` : `x=${curEdge.start.x}`;\n      const positionType = curEdge.type === \"below\" || curEdge.type === \"above\" ? curEdge.type : `to its ${curEdge.type}`;\n      invalidEdges.push(\n        (0, i18n_exports._)(\n          `\"${item.item}\" expected a viz or canvas edge directly ${positionType} at ${positionString}`\n        )\n      );\n    }\n  });\n  return invalidEdges;\n};\nvar findInvalidItems = ({\n  items,\n  canvasBounds\n}) => {\n  const invalidItems = [];\n  const edges = createEdges({ items, canvasBounds });\n  items.forEach((item) => {\n    const invalidEdges = findInvalidItemEdges({ item, edges });\n    if (invalidEdges.length > 0) {\n      invalidItems.push({\n        itemId: item.item,\n        messages: invalidEdges\n      });\n    }\n  });\n  return invalidItems;\n};\nvar validateLayoutStructure = ({\n  layout,\n  canvasBounds\n}) => {\n  if (!layout) {\n    return [];\n  }\n  const res = findItemsOutsideBoundary({\n    items: layout,\n    boundary: canvasBounds\n  });\n  if (!(0, lodash_exports.isEmpty)(res)) {\n    return res;\n  }\n  return findInvalidItems({ items: layout, canvasBounds });\n};\nvar isVerticallyAligned = (viz, another) => viz.position.y === another.position.y && viz.position.h === another.position.h;\nvar isHorizontallyAligned = (viz, another) => viz.position.x === another.position.x && viz.position.w === another.position.w;\nvar isInvalidAdjacentVizDrop = ({\n  itemToMove,\n  itemToDropOn,\n  direction,\n  visualizations\n}) => {\n  if (direction === \"e\" && (0, dashboard_utils_exports.isLeftNeighbor)(itemToMove, itemToDropOn) && isVerticallyAligned(itemToMove, itemToDropOn)) {\n    return true;\n  }\n  if (direction === \"w\" && (0, dashboard_utils_exports.isRightNeighbor)(itemToMove, itemToDropOn) && isVerticallyAligned(itemToMove, itemToDropOn)) {\n    return true;\n  }\n  if (direction === \"e\" || direction === \"w\") {\n    return false;\n  }\n  const { leftNeighbors, rightNeighbors } = (0, dashboard_utils_exports.findHorizontalNeighbors)({\n    item: itemToMove,\n    visualizations\n  });\n  if (leftNeighbors.length > 0 || rightNeighbors.length > 0) {\n    return false;\n  }\n  if (direction === \"n\" && (0, dashboard_utils_exports.isBottomNeighbor)(itemToMove, itemToDropOn) && isHorizontallyAligned(itemToMove, itemToDropOn)) {\n    return true;\n  }\n  if (direction === \"s\" && (0, dashboard_utils_exports.isTopNeighbor)(itemToMove, itemToDropOn) && isHorizontallyAligned(itemToMove, itemToDropOn)) {\n    return true;\n  }\n  return false;\n};\n\n// src/utils/splitGridStructure.ts\nvar DEFAULT_BLOCK_ITEM = {\n  item: \"\",\n  position: { x: -1, y: -1, w: -1, h: -1 }\n};\nvar translateBlockItem = (item, translation) => __spreadProps(__spreadValues({}, item), {\n  position: __spreadProps(__spreadValues({}, item.position), {\n    x: item.position.x + translation.x,\n    y: item.position.y + translation.y\n  })\n});\nvar translateBlockItems = (items, translation) => items.map((item) => translateBlockItem(item, translation));\nvar translateGridSplit = (gridSplit, translation) => __spreadProps(__spreadValues({}, gridSplit), {\n  layout: translateBlockItems(gridSplit.layout, translation),\n  content: __spreadProps(__spreadValues({}, gridSplit.content), {\n    items: translateBlockItems(gridSplit.content.items, translation)\n  }),\n  origin: {\n    x: gridSplit.origin.x + translation.x,\n    y: gridSplit.origin.y + translation.y\n  }\n});\nvar splitGrid = ({\n  layoutStructure,\n  idToRemove,\n  splitConfig = \"both\",\n  alwaysIncludeLastRow = false\n}) => {\n  const gridInfo = {\n    width: 0,\n    height: 0,\n    originItem: DEFAULT_BLOCK_ITEM,\n    nodes: {},\n    splitByRows: [],\n    splitByColumns: [],\n    itemToRemove: DEFAULT_BLOCK_ITEM\n  };\n  if (layoutStructure.length === 0) {\n    return gridInfo;\n  }\n  let originX = Number.MAX_SAFE_INTEGER;\n  let originY = Number.MAX_SAFE_INTEGER;\n  layoutStructure.forEach((item) => {\n    const { x, y, w, h } = item.position;\n    gridInfo.width = Math.max(gridInfo.width, x + w);\n    gridInfo.height = Math.max(gridInfo.height, y + h);\n    if (x <= originX && y <= originY) {\n      originX = x;\n      originY = y;\n      gridInfo.originItem = item;\n    }\n    [\n      [x, y],\n      [x + w, y],\n      [x, y + h],\n      [x + w, y + h]\n    ].forEach(([cornerX, cornerY]) => {\n      var _a, _b, _c, _d;\n      (_b = (_a = gridInfo.nodes)[cornerX]) != null ? _b : _a[cornerX] = {};\n      (_d = (_c = gridInfo.nodes[cornerX])[cornerY]) != null ? _d : _c[cornerY] = [];\n      gridInfo.nodes[cornerX][cornerY].push(item);\n    });\n    if (idToRemove === item.item) {\n      gridInfo.itemToRemove = item;\n    }\n  });\n  gridInfo.width = Math.max(0, gridInfo.width - originX);\n  gridInfo.height = Math.max(0, gridInfo.height - originY);\n  if (splitConfig === \"both\" || splitConfig === \"rows\") {\n    gridInfo.splitByRows = splitGridByRows({\n      nodes: gridInfo.nodes,\n      layout: layoutStructure,\n      gridWidth: gridInfo.width,\n      gridHeight: gridInfo.height,\n      originViz: gridInfo.originItem,\n      alwaysIncludeLastRow\n    });\n  }\n  if (splitConfig === \"both\" || splitConfig === \"columns\") {\n    gridInfo.splitByColumns = splitGridByColumns({\n      nodes: gridInfo.nodes,\n      layout: layoutStructure,\n      gridWidth: gridInfo.width,\n      gridHeight: gridInfo.height,\n      originViz: gridInfo.originItem\n    });\n  }\n  return gridInfo;\n};\n\n// src/utils/getContainingRowColumn.ts\nvar findContainingRow = ({ splits, itemPosition }) => {\n  const edgeTop = itemPosition.y;\n  const edgeBottom = itemPosition.y + itemPosition.h;\n  return splits.find(\n    ({ origin, content }) => (\n      // Find the first row split which starts above the item in question and ends below it\n      origin.y <= edgeTop && origin.y + content.height >= edgeBottom\n    )\n  );\n};\nvar findContainingColumn = ({ splits, itemPosition }) => {\n  const edgeLeft = itemPosition.x;\n  const edgeRight = itemPosition.x + itemPosition.w;\n  return splits.find(\n    ({ origin, content }) => (\n      // Find the first column split which starts before the item in question and ends after it\n      origin.x <= edgeLeft && origin.x + content.width >= edgeRight\n    )\n  );\n};\nvar getContainingRowColumnRecursive = ({\n  findContainerFn,\n  itemToContain,\n  previousResult,\n  structure\n}) => {\n  const splittingByRows = findContainerFn === findContainingRow;\n  const splitGridInfo = splitGrid({\n    layoutStructure: structure,\n    idToRemove: itemToContain.item,\n    splitConfig: splittingByRows ? \"rows\" : \"columns\",\n    alwaysIncludeLastRow: true\n  });\n  const container = findContainerFn({\n    splits: splittingByRows ? splitGridInfo.splitByRows : splitGridInfo.splitByColumns,\n    itemPosition: splitGridInfo.itemToRemove.position\n  });\n  if (!container || container.content.items.length <= 1) {\n    return previousResult;\n  }\n  const containerTranslation = {\n    x: -container.origin.x,\n    y: -container.origin.y\n  };\n  const translatedContainer = translateGridSplit(\n    container,\n    containerTranslation\n  );\n  const nextFindContainerFn = splittingByRows ? findContainingColumn : findContainingRow;\n  return translateGridSplit(\n    getContainingRowColumnRecursive({\n      structure: translatedContainer.content.items,\n      itemToContain,\n      findContainerFn: nextFindContainerFn,\n      previousResult: translatedContainer\n    }),\n    container.origin\n  );\n};\nvar getContainingRowColumn = ({\n  structure,\n  itemToContain\n}) => getContainingRowColumnRecursive({\n  structure,\n  itemToContain,\n  findContainerFn: findContainingRow\n});\n\n// src/utils/gridLayoutAutoResize.ts\nvar recursivelyApplyHorizontalResize = ({\n  container: {\n    content: { items, width: totalWidth },\n    origin\n  },\n  newSize,\n  position,\n  translation\n}) => {\n  const changes = {};\n  const { splitByRows, splitByColumns } = splitGrid({\n    layoutStructure: translateBlockItems(items, {\n      x: -origin.x,\n      y: -origin.y\n    })\n  });\n  splitByRows.forEach((container) => {\n    Object.assign(\n      changes,\n      recursivelyApplyHorizontalResize({\n        container,\n        newSize,\n        position,\n        translation: {\n          x: translation.x + origin.x,\n          y: translation.y + origin.y\n        }\n      })\n    );\n  });\n  let colPosition = position;\n  splitByColumns.forEach((container, idx) => {\n    let newColWidth = Math.floor(\n      newSize * (container.content.width / totalWidth)\n    );\n    if (\n      // If resizing the last column\n      idx === splitByColumns.length - 1 && // and there's a fractional correction needed\n      colPosition + newColWidth !== position + newSize\n    ) {\n      newColWidth = position + newSize - colPosition;\n    }\n    Object.assign(\n      changes,\n      recursivelyApplyHorizontalResize({\n        container,\n        newSize: newColWidth,\n        position: colPosition,\n        translation: {\n          x: translation.x + origin.x,\n          y: translation.y + origin.y\n        }\n      })\n    );\n    colPosition += newColWidth;\n  });\n  if (splitByColumns.length === 0 && splitByRows.length === 0) {\n    items.forEach((item) => {\n      const { position: itemPos } = translateBlockItem(item, translation);\n      changes[item.item] = __spreadProps(__spreadValues({}, item), {\n        position: __spreadProps(__spreadValues({}, itemPos), {\n          x: position,\n          w: newSize\n        })\n      });\n    });\n  }\n  return changes;\n};\nvar recursivelyApplyVerticalResize = ({\n  container: {\n    content: { items, height: totalHeight },\n    origin\n  },\n  newSize,\n  position,\n  translation\n}) => {\n  const changes = {};\n  const { splitByRows, splitByColumns } = splitGrid({\n    layoutStructure: translateBlockItems(items, {\n      x: -origin.x,\n      y: -origin.y\n    })\n  });\n  splitByColumns.forEach((container) => {\n    Object.assign(\n      changes,\n      recursivelyApplyVerticalResize({\n        container,\n        newSize,\n        position,\n        translation: {\n          x: translation.x + origin.x,\n          y: translation.y + origin.y\n        }\n      })\n    );\n  });\n  let rowPosition = position;\n  splitByRows.forEach((container, idx) => {\n    let newRowHeight = Math.floor(\n      newSize * (container.content.height / totalHeight)\n    );\n    if (\n      // If resizing the last row\n      idx === splitByRows.length - 1 && // and there's a fractional correction needed\n      rowPosition + newRowHeight !== position + newSize\n    ) {\n      newRowHeight = position + newSize - rowPosition;\n    }\n    Object.assign(\n      changes,\n      recursivelyApplyVerticalResize({\n        container,\n        newSize: newRowHeight,\n        position: rowPosition,\n        translation: {\n          x: translation.x + origin.x,\n          y: translation.y + origin.y\n        }\n      })\n    );\n    rowPosition += newRowHeight;\n  });\n  if (splitByColumns.length === 0 && splitByRows.length === 0) {\n    items.forEach((item) => {\n      const { position: itemPos } = translateBlockItem(item, translation);\n      changes[item.item] = __spreadProps(__spreadValues({}, item), {\n        position: __spreadProps(__spreadValues({}, itemPos), {\n          y: position,\n          h: newSize\n        })\n      });\n    });\n  }\n  return changes;\n};\nvar HorizontalResizeConfig = {\n  dimension: \"width\",\n  blockSizeDimension: \"w\",\n  blockPosDimension: \"x\",\n  splitGridConfig: \"columns\",\n  splitGridKey: \"splitByColumns\",\n  recursiveResizeFn: recursivelyApplyHorizontalResize\n};\nvar VerticalResizeConfig = {\n  dimension: \"height\",\n  blockSizeDimension: \"h\",\n  blockPosDimension: \"y\",\n  splitGridConfig: \"rows\",\n  splitGridKey: \"splitByRows\",\n  recursiveResizeFn: recursivelyApplyVerticalResize\n};\nvar handleResizing = ({\n  container,\n  itemToRemove,\n  config: {\n    dimension,\n    blockSizeDimension,\n    blockPosDimension,\n    splitGridConfig,\n    splitGridKey,\n    recursiveResizeFn\n  }\n}) => {\n  if (!container) {\n    return {};\n  }\n  const {\n    origin,\n    content: {\n      // Items in the container which are being resized\n      items: impactedItems,\n      // The important container dimension (width or height) being recalculated\n      [dimension]: containerSize\n    }\n  } = container;\n  const negatedOrigin = { x: -origin.x, y: -origin.y };\n  if (impactedItems.length < 2) {\n    return {};\n  }\n  if (impactedItems.length === 2) {\n    const itemToUpdate = impactedItems[0].item !== itemToRemove.item ? impactedItems[0] : impactedItems[1];\n    return {\n      [itemToUpdate.item]: __spreadProps(__spreadValues({}, itemToUpdate), {\n        position: __spreadProps(__spreadValues({}, itemToUpdate.position), {\n          [blockPosDimension]: origin[blockPosDimension],\n          [blockSizeDimension]: containerSize\n        })\n      })\n    };\n  }\n  const pendingChanges = {};\n  const {\n    [splitGridKey]: splitByResizeDimension,\n    itemToRemove: {\n      position: { [blockSizeDimension]: itemToRemoveSize }\n    }\n  } = splitGrid({\n    layoutStructure: translateBlockItems(impactedItems, negatedOrigin),\n    splitConfig: splitGridConfig,\n    idToRemove: itemToRemove.item\n  });\n  const pctToDistribute = itemToRemoveSize / (splitByResizeDimension.length - 1) / containerSize;\n  let itemPosition = origin[blockPosDimension];\n  const containerEdge = origin[blockPosDimension] + containerSize;\n  let lastFRCIdx = splitByResizeDimension.length - 2;\n  splitByResizeDimension.forEach((split, idx) => {\n    if (split.content.items[0].item === itemToRemove.item) {\n      lastFRCIdx += 1;\n      return;\n    }\n    const splitSize = split.content[dimension] / containerSize;\n    let newSize = Math.floor(containerSize * (pctToDistribute + splitSize));\n    if (idx === lastFRCIdx && itemPosition + newSize !== containerEdge) {\n      newSize = containerEdge - itemPosition;\n    }\n    Object.values(\n      recursiveResizeFn({\n        container: split,\n        newSize,\n        position: itemPosition,\n        translation: origin\n      })\n    ).forEach((change) => {\n      pendingChanges[change.item] = change;\n    });\n    itemPosition += newSize;\n  });\n  return pendingChanges;\n};\nvar handleHorizontalResizing = (args) => handleResizing(__spreadProps(__spreadValues({}, args), { config: HorizontalResizeConfig }));\nvar handleVerticalResizing = (args) => handleResizing(__spreadProps(__spreadValues({}, args), { config: VerticalResizeConfig }));\n\n// src/utils/gridLayoutShowHide.ts\nvar cloneLayoutStructure = (source) => {\n  if (!source.length) {\n    return [];\n  }\n  return (0, lodash_exports.cloneDeep)(source);\n};\nvar createStructureMap = (structure) => Object.fromEntries(structure.map((item) => [item.item, item]));\nvar getWidthFromStructure = (structure) => {\n  const [min, max] = structure.reduce(\n    ([minX, maxX], { position: { x, w } }) => [\n      // minX = either block item left or current minX (initial: MAX_SAFE_INTEGER)\n      Math.min(minX, x),\n      // maxX = either block item right or current maxX (initial: 0)\n      Math.max(maxX, x + w)\n    ],\n    [Number.MAX_SAFE_INTEGER, 0]\n  );\n  return Math.max(max - min, 0);\n};\nvar popTopLeftBlock = ({\n  itemsToRemove,\n  itemMap\n}) => {\n  let result = itemMap[itemsToRemove[0].item];\n  let resultIdx = 0;\n  itemsToRemove.forEach(({ item }, idx) => {\n    const itemMapItem = itemMap[item];\n    if (result.position.y > itemMapItem.position.y) {\n      result = itemMapItem;\n      resultIdx = idx;\n      return;\n    }\n    if (result.position.y === itemMapItem.position.y && result.position.x > itemMapItem.position.x) {\n      result = itemMapItem;\n      resultIdx = idx;\n    }\n  });\n  itemsToRemove.splice(resultIdx, 1);\n  return result;\n};\nvar applyUpdatesToStructure = ({\n  structure,\n  itemMap,\n  itemToRemove,\n  updatesMap\n}) => {\n  let idxToRemove = -1;\n  structure.forEach((item, idx) => {\n    if (item.item === itemToRemove.item) {\n      idxToRemove = idx;\n    } else if (item.item in updatesMap) {\n      structure[idx] = updatesMap[item.item];\n      itemMap[item.item] = updatesMap[item.item];\n    }\n  });\n  if (idxToRemove >= 0) {\n    structure.splice(idxToRemove, 1);\n  }\n  delete itemMap[itemToRemove.item];\n};\nvar baseCaseRemoval = ({\n  structure,\n  itemMap,\n  itemToRemove,\n  width\n}) => {\n  const updates = (0, dashboard_utils_exports.updateRemovedVizNeighbors)({\n    items: structure,\n    itemToRemove,\n    width\n  });\n  const updatesMap = createStructureMap(updates);\n  applyUpdatesToStructure({\n    structure,\n    itemMap,\n    itemToRemove,\n    updatesMap\n  });\n};\nvar handleRecursiveItemRemoval = ({\n  structure,\n  itemsToRemove,\n  itemMap\n}) => {\n  var _a, _b;\n  if (itemsToRemove.length === 0) {\n    return;\n  }\n  const itemToRemove = popTopLeftBlock({ itemsToRemove, itemMap });\n  const container = getContainingRowColumn({\n    structure,\n    itemToContain: itemToRemove\n  });\n  if (!container || container.content.items.length <= 1) {\n    baseCaseRemoval({\n      structure,\n      itemMap,\n      width: (_a = container == null ? void 0 : container.gridWidth) != null ? _a : getWidthFromStructure(structure),\n      itemToRemove\n    });\n  } else {\n    const { width, height } = container.content;\n    let updatesMap;\n    if (itemToRemove.position.w === width) {\n      updatesMap = handleVerticalResizing({ container, itemToRemove });\n    } else if (itemToRemove.position.h === height) {\n      updatesMap = handleHorizontalResizing({ container, itemToRemove });\n    } else {\n      baseCaseRemoval({\n        structure,\n        width: (_b = container == null ? void 0 : container.gridWidth) != null ? _b : getWidthFromStructure(structure),\n        itemToRemove,\n        itemMap\n      });\n    }\n    if (updatesMap) {\n      applyUpdatesToStructure({\n        structure,\n        itemMap,\n        itemToRemove,\n        updatesMap\n      });\n    }\n  }\n  handleRecursiveItemRemoval({ structure, itemsToRemove, itemMap });\n};\nvar gridLayoutShowHideReflow = (initialStructure, itemsToRemove) => {\n  if (!itemsToRemove.length) {\n    return initialStructure;\n  }\n  const newStructure = cloneLayoutStructure(\n    initialStructure\n  );\n  const clonedItemsToRemove = cloneLayoutStructure(\n    itemsToRemove\n  );\n  const itemMap = createStructureMap(newStructure);\n  handleRecursiveItemRemoval({\n    structure: newStructure,\n    itemsToRemove: clonedItemsToRemove,\n    itemMap\n  });\n  return newStructure;\n};\n\n// src/GridLayout.tsx\nvar HANDLE_DIRECTIONS = [];\nvar MemoizedBlockItem = react_default.memo(\n  ResponsiveBlockItem_default,\n  (prevProps, nextProps) => {\n    if (nextProps.y + nextProps.h === nextProps.canvasHeight) {\n      return (0, lodash_exports.isEqual)(prevProps, nextProps);\n    }\n    const prevPropsWithoutCanvasHeight = (0, lodash_exports.omit)(prevProps, \"canvasHeight\");\n    const nextPropsWithoutCanvasHeight = (0, lodash_exports.omit)(nextProps, \"canvasHeight\");\n    return (0, lodash_exports.isEqual)(\n      prevPropsWithoutCanvasHeight,\n      nextPropsWithoutCanvasHeight\n    );\n  }\n);\nvar MemoizedBlockOutline = react_default.memo(ResponsiveBlockOutline_default);\nvar MemoizedEdge = react_default.memo(Edge);\nvar renderBlockItems = memoize_one_default(\n  ({\n    layoutStructure,\n    renderLayoutItem,\n    handleItemSelected,\n    isBlockItemMoving,\n    selectedItem,\n    mode,\n    errors,\n    padding,\n    canvasHeight\n  }) => {\n    return layoutStructure.map((item) => {\n      const key = item.item;\n      if (key === \"preview-old-item\") {\n        return null;\n      }\n      const isSelected = (selectedItem == null ? void 0 : selectedItem.id) === key;\n      let appearance = mode === \"view\" || !selectedItem || isSelected ? \"highlighted\" : \"visible\";\n      if (isSelected && isBlockItemMoving) {\n        appearance = \"hidden\";\n      }\n      let errorMessages;\n      if (errors) {\n        const vizErrors = errors.find(({ itemId }) => itemId === key);\n        errorMessages = vizErrors == null ? void 0 : vizErrors.messages;\n      }\n      return /* @__PURE__ */ react_default.createElement(\n        MemoizedBlockItem,\n        {\n          key,\n          itemId: key,\n          type: item.type,\n          x: item.position.x,\n          y: item.position.y,\n          h: item.position.h,\n          w: item.position.w,\n          padding,\n          canvasHeight,\n          renderLayoutItem,\n          onItemSelected: handleItemSelected,\n          appearance,\n          errorMessages\n        }\n      );\n    });\n  },\n  lodash_exports.isEqual\n);\nvar BOTTOM_EDGE_MIN_SPEED = 2;\nvar BOTTOM_EDGE_MAX_SPEED = 4;\nvar BOTTOM_RESIZING_SCROLL_SPEED = 50;\nvar CANVAS_BOTTOM_PADDING = 8;\nvar BaseGridLayout = ({\n  layoutApiRef,\n  onLayoutItemsSelect,\n  selectedItems: selectedLayoutItems,\n  layoutStructure,\n  onLayoutStructureChange,\n  options = {},\n  renderLayoutItem,\n  mode,\n  showGrid,\n  scale,\n  setCanvasHeight,\n  canvasWidth\n}) => {\n  var _a;\n  const canvasRef = (0, react_exports.useRef)(null);\n  const canvasContext = (0, dashboard_context_exports.useCanvas)();\n  const keyboardListener = (0, dashboard_context_exports.useKeyboardListener)();\n  const userMessage = (_a = (0, dashboard_context_exports.useUserMessageAPI)()) != null ? _a : dashboard_utils_exports.noop;\n  const telemetryAPI = (0, dashboard_telemetry_exports.useTelemetryApi)();\n  const { enableGridLayoutErrors, enableGridLayoutCssScaling } = (0, dashboard_context_exports.useFeatureFlags)();\n  const { gutterSize = gridLayoutOptions.gutterSize } = options;\n  const panelPadding = gutterSize / 2;\n  const [gridState, dispatch] = (0, react_exports.useReducer)(\n    gridReducer,\n    layoutStructure,\n    initializeGridReducer\n  );\n  const maxHeight = computeMaxHeight(getBlockItems(gridState));\n  (0, react_exports.useLayoutEffect)(() => {\n    setCanvasHeight(maxHeight);\n  }, [setCanvasHeight, maxHeight]);\n  const [isBlockItemMoving, setIsBlockItemMoving] = (0, react_exports.useState)(false);\n  const [edges, setEdges] = (0, react_exports.useState)(\n    computeEdges({\n      layout: layoutStructure,\n      canvasWidth,\n      canvasHeight: computeMaxHeight(layoutStructure)\n      // need to recompute height on layout change\n    })\n  );\n  const [snappableEdges, setSnappableEdges] = (0, react_exports.useState)([]);\n  const [scrollToBottom, setScrollToBottom] = (0, react_exports.useState)(false);\n  const [mousePosition, setMousePosition] = (0, react_exports.useState)(null);\n  const [isItemAdded, setIsItemAdded] = (0, react_exports.useState)(false);\n  const [edgesBeforeMove, setEdgesBeforeMove] = (0, react_exports.useState)(\n    null\n  );\n  const [invalidEdgeId, setInvalidEdgeId] = (0, react_exports.useState)(null);\n  const [hoveredEdge, setHoveredEdge] = (0, react_exports.useState)(null);\n  const [initialItemToMove, setInitialItemToMove] = (0, react_exports.useState)(null);\n  const [hoveredBlock, setHoveredBlock] = (0, react_exports.useState)(\n    null\n  );\n  const [hoveredQuadrant, setHoveredQuadrant] = (0, react_exports.useState)(\n    null\n  );\n  const [, setForceUpdate] = (0, react_exports.useState)(0);\n  const [selectedItemsForEdge, setSelectedItemsForEdge] = (0, react_exports.useState)(\n    []\n  );\n  const [isInvalidVizDrop, setIsInvalidVizDrop] = (0, react_exports.useState)(false);\n  const [showPreviewPlaceholder, setShowPreviewPlaceholder] = (0, react_exports.useState)(true);\n  const [layoutErrors, setLayoutErrors] = (0, react_exports.useState)([]);\n  const isDraggingEdge = (0, react_exports.useRef)(false);\n  const delayPreviewEdge = (0, react_exports.useRef)(null);\n  const delayPreviewViz = (0, react_exports.useRef)(null);\n  const mouseDownEdge = (0, react_exports.useRef)(null);\n  const edgeMouseDownPosition = (0, react_exports.useRef)(null);\n  const edgeBoundaries = (0, react_exports.useRef)(null);\n  const edgesInBoundary = (0, react_exports.useRef)(null);\n  const cumulativeScrollIncrease = (0, react_exports.useRef)(0);\n  const edgeVelocity = (0, react_exports.useRef)(0);\n  const containsPreviewItem = hasPreviewItem(gridState);\n  const sendTelemetry = (0, react_exports.useCallback)(\n    (eventData) => {\n      telemetryAPI.collect(eventData);\n    },\n    [telemetryAPI]\n  );\n  const onItemAdded = (0, react_exports.useCallback)(() => {\n    setIsItemAdded(true);\n  }, [setIsItemAdded]);\n  const layoutApi = (0, react_exports.useRef)(null);\n  const layoutStructureRef = (0, react_exports.useRef)(layoutStructure);\n  const firstSelectedItemStructure = (0, react_exports.useMemo)(\n    () => (selectedLayoutItems == null ? void 0 : selectedLayoutItems.length) ? getItem(gridState, selectedLayoutItems[0].id) : null,\n    [gridState, selectedLayoutItems]\n  );\n  const initializeLayoutApi = (0, react_exports.useCallback)(() => {\n    const getCanvasDomElement = () => {\n      return canvasRef.current;\n    };\n    if (layoutApi.current === null) {\n      layoutApi.current = new GridLayoutApi_default({\n        layoutStructureRef,\n        options,\n        userMessage,\n        onItemAdded,\n        getCanvasDomElement,\n        telemetry: telemetryAPI\n      });\n    }\n  }, [telemetryAPI, userMessage, onItemAdded, options]);\n  const prevLayoutStructure = (0, dashboard_ui_exports.usePrevious)(layoutStructure);\n  (0, react_exports.useEffect)(() => {\n    if ((0, lodash_exports.isEqual)(prevLayoutStructure, layoutStructure)) {\n      return;\n    }\n    dispatch(resetLayoutAction(layoutStructure));\n    layoutStructureRef.current = enableGridLayoutCssScaling ? layoutStructure : scaleGridLayoutStructureByWidth({\n      scale: 1 / scale,\n      layout: layoutStructure\n    });\n  }, [\n    enableGridLayoutCssScaling,\n    layoutStructure,\n    prevLayoutStructure,\n    scale\n  ]);\n  initializeLayoutApi();\n  (0, react_exports.useEffect)(() => {\n    if (mode === \"edit\" && enableGridLayoutErrors) {\n      const errors = validateLayoutStructure({\n        layout: layoutStructure,\n        canvasBounds: { x: 0, y: 0, w: canvasWidth, h: maxHeight }\n      });\n      setLayoutErrors(errors);\n    } else if (mode === \"view\") {\n      setLayoutErrors([]);\n    }\n  }, [layoutStructure, mode, enableGridLayoutErrors]);\n  (0, react_exports.useLayoutEffect)(() => {\n    layoutApiRef(layoutApi.current);\n    return () => {\n      layoutApiRef(null);\n    };\n  }, [layoutApiRef]);\n  (0, react_exports.useEffect)(() => {\n    if ((0, lodash_exports.isEqual)(prevLayoutStructure, layoutStructure)) {\n      return;\n    }\n    dispatch(resetLayoutAction(layoutStructure));\n    const canvasHeight = computeMaxHeight(layoutStructure);\n    const prevCanvasHeight = computeMaxHeight(prevLayoutStructure || []);\n    setEdges(\n      computeEdges({\n        layout: layoutStructure,\n        canvasWidth,\n        canvasHeight\n        // need to recompute height on layout change\n      })\n    );\n    if (prevLayoutStructure && canvasHeight > prevCanvasHeight && isItemAdded) {\n      setScrollToBottom(true);\n      setIsItemAdded(false);\n    }\n  }, [isItemAdded, layoutStructure, canvasWidth, prevLayoutStructure]);\n  (0, react_exports.useEffect)(() => {\n    if (scrollToBottom) {\n      const layoutContainer = canvasContext.current;\n      if (layoutContainer) {\n        layoutContainer.scrollTop = layoutContainer.scrollHeight;\n      }\n      setScrollToBottom(false);\n    }\n  }, [canvasContext, layoutStructure, scrollToBottom]);\n  const handleLayoutStructureChange = (0, react_exports.useCallback)(() => {\n    const layout = getBlockItems(gridState);\n    onLayoutStructureChange(layout);\n  }, [onLayoutStructureChange, gridState]);\n  const getSelectedItems = (0, react_exports.useMemo)(() => {\n    let itemsCache;\n    return () => {\n      const filteredItems = filterSelectedItems(\n        layoutStructure,\n        selectedLayoutItems\n      );\n      if (!(0, lodash_exports.isEqual)(itemsCache, filteredItems)) {\n        itemsCache = filteredItems;\n      }\n      return itemsCache;\n    };\n  }, [layoutStructure, selectedLayoutItems]);\n  const handleItemSelected = (0, react_exports.useCallback)(\n    (_e, selectedItems = []) => {\n      const selectedItem = selectedItems.length > 0 ? [selectedItems[selectedItems.length - 1]] : [];\n      onLayoutItemsSelect(selectedItem);\n    },\n    [onLayoutItemsSelect]\n  );\n  const mouseScale = enableGridLayoutCssScaling ? scale : 1;\n  (0, react_exports.useEffect)(() => {\n    let delayed;\n    const layoutContainer = canvasContext.current;\n    if (!isBlockItemMoving || !mousePosition || !layoutContainer) {\n      return () => void 0;\n    }\n    const visibleCanvasHeight = layoutContainer.clientHeight / mouseScale;\n    const hasScrolledToBottom = layoutContainer.scrollTop / mouseScale + visibleCanvasHeight >= maxHeight;\n    const isInBottomScrollArea = layoutContainer.scrollTop / mouseScale + visibleCanvasHeight - mousePosition.y < MIN_HEIGHT_PX;\n    const hasScrolledToTop = layoutContainer.scrollTop <= 0;\n    const isInTopScrollArea = mousePosition.y - layoutContainer.scrollTop / mouseScale < MIN_HEIGHT_PX;\n    if (!hasScrolledToBottom && isInBottomScrollArea) {\n      const increment = Math.min(\n        Math.abs(\n          maxHeight - (layoutContainer.scrollTop / mouseScale + visibleCanvasHeight)\n        ),\n        10\n      );\n      delayed = setTimeout(() => {\n        layoutContainer.scrollTop += increment;\n        setMousePosition(\n          (pos) => pos ? __spreadProps(__spreadValues({}, pos), {\n            y: pos.y + increment / mouseScale\n          }) : null\n        );\n      }, 32);\n    } else if (!hasScrolledToTop && isInTopScrollArea) {\n      const decrement = Math.min(layoutContainer.scrollTop, 10);\n      delayed = setTimeout(() => {\n        layoutContainer.scrollTop -= decrement;\n        setMousePosition(\n          (pos) => pos ? __spreadProps(__spreadValues({}, pos), {\n            y: pos.y - decrement / mouseScale\n          }) : null\n        );\n      }, 32);\n    }\n    return () => {\n      clearTimeout(delayed);\n    };\n  }, [\n    isBlockItemMoving,\n    mousePosition,\n    canvasContext,\n    mouseScale,\n    maxHeight\n  ]);\n  const resetEdgePreviewState = (0, react_exports.useCallback)(() => {\n    if (edgesBeforeMove) {\n      if (delayPreviewEdge.current) {\n        clearTimeout(delayPreviewEdge.current);\n      }\n      setEdges(edgesBeforeMove);\n      dispatch(resetLayoutAction(layoutStructure));\n    }\n  }, [edgesBeforeMove, layoutStructure]);\n  const showEdgeDropPreview = (0, react_exports.useCallback)(\n    ({ mousePos }) => {\n      if (edgesBeforeMove === null) {\n        setEdgesBeforeMove(edges);\n      }\n      const validEdges = edgesBeforeMove || edges;\n      const edge = validEdges.find((edgeToFind) => {\n        return isMouseOnEdge({\n          edge: edgeToFind,\n          mousePosition: mousePos,\n          padding: panelPadding\n        });\n      });\n      if (!edge) {\n        if (hoveredEdge) {\n          setHoveredEdge(null);\n          setInvalidEdgeId(null);\n          resetEdgePreviewState();\n        }\n        return;\n      }\n      if (!hoveredEdge || hoveredEdge.item !== edge.item) {\n        let itemToMove = firstSelectedItemStructure;\n        if (!initialItemToMove) {\n          setInitialItemToMove(itemToMove);\n        } else {\n          itemToMove = initialItemToMove;\n        }\n        if (isDropOnOwnEdge({\n          edge,\n          itemToMove\n        })) {\n          return;\n        }\n        const updatedItems = previewDropOnEdge({\n          edge,\n          itemToMove,\n          items: layoutStructure,\n          canvasWidth\n        });\n        if (updatedItems) {\n          setInvalidEdgeId(null);\n          if (delayPreviewEdge.current) {\n            clearTimeout(delayPreviewEdge.current);\n          }\n          setShowPreviewPlaceholder(false);\n          delayPreviewEdge.current = setTimeout(() => {\n            dispatch(resetLayoutAction(updatedItems));\n            setEdges(\n              computeEdges({\n                layout: updatedItems,\n                canvasWidth,\n                canvasHeight: computeMaxHeight(updatedItems)\n              })\n            );\n            setShowPreviewPlaceholder(true);\n          }, EDGE_PREVIEW_DELAY_MS);\n        } else {\n          setShowPreviewPlaceholder(true);\n          setInvalidEdgeId(edge.item);\n          resetEdgePreviewState();\n        }\n      }\n      setHoveredEdge(edge);\n    },\n    [\n      firstSelectedItemStructure,\n      edgesBeforeMove,\n      edges,\n      hoveredEdge,\n      panelPadding,\n      resetEdgePreviewState,\n      initialItemToMove,\n      layoutStructure,\n      canvasWidth\n    ]\n  );\n  const showVizDropPreview = (0, react_exports.useCallback)(\n    ({ mousePos }) => {\n      const block = findTopBlockItemByPosition(\n        layoutStructure,\n        mousePos,\n        panelPadding\n      );\n      let itemToMove = firstSelectedItemStructure;\n      if (!initialItemToMove) {\n        setInitialItemToMove(itemToMove);\n      } else {\n        itemToMove = initialItemToMove;\n      }\n      if (block === void 0 || block.item === (itemToMove == null ? void 0 : itemToMove.item)) {\n        if (delayPreviewViz.current) {\n          clearTimeout(delayPreviewViz.current);\n        }\n        setHoveredQuadrant(null);\n        setHoveredBlock(null);\n        setIsInvalidVizDrop(false);\n        if (hoveredBlock) {\n          dispatch(resetLayoutAction(layoutStructure));\n        }\n        return;\n      }\n      const currentQuadrant = findQuadrant({\n        item: applyVizPadding({ item: block, padding: panelPadding }),\n        position: mousePos\n      });\n      if (!hoveredBlock && !hoveredQuadrant || hoveredQuadrant !== currentQuadrant || (hoveredBlock == null ? void 0 : hoveredBlock.item) !== block.item) {\n        if (isInvalidAdjacentVizDrop({\n          itemToMove,\n          itemToDropOn: block,\n          visualizations: layoutStructure,\n          direction: currentQuadrant\n        })) {\n          return;\n        }\n        const updatedItems = previewDropOnViz({\n          itemToDropOn: block,\n          itemToMove,\n          items: layoutStructure,\n          direction: currentQuadrant\n        });\n        if (delayPreviewViz.current) {\n          clearTimeout(delayPreviewViz.current);\n        }\n        if (updatedItems) {\n          setIsInvalidVizDrop(false);\n          setHoveredQuadrant(currentQuadrant);\n          setHoveredBlock(block);\n          setShowPreviewPlaceholder(false);\n          delayPreviewViz.current = setTimeout(() => {\n            dispatch(resetLayoutAction(updatedItems));\n            setForceUpdate(\n              (prevForceUpdate) => prevForceUpdate + 1\n            );\n            setShowPreviewPlaceholder(true);\n          }, VIZ_PREVIEW_DELAY_MS);\n        } else {\n          setHoveredQuadrant(null);\n          setHoveredBlock(null);\n          setIsInvalidVizDrop(true);\n          if (hoveredBlock) {\n            dispatch(resetLayoutAction(layoutStructure));\n          }\n        }\n      }\n    },\n    [\n      firstSelectedItemStructure,\n      panelPadding,\n      hoveredBlock,\n      hoveredQuadrant,\n      initialItemToMove,\n      layoutStructure\n    ]\n  );\n  const renderItemDropTarget = memoize_one_default(\n    ({\n      position,\n      direction\n    }) => {\n      return /* @__PURE__ */ react_default.createElement(ItemDropTarget, { position, direction });\n    }\n  );\n  const handleRenderItemDropTarget = (0, react_exports.useCallback)(() => {\n    let block = findTopBlockItemByPosition(\n      layoutStructure,\n      mousePosition,\n      panelPadding\n    );\n    const selectedItems = getSelectedItems();\n    if (block !== void 0 && selectedItems.length > 0 && block.item !== selectedItems[0].id && // disables drop targets when showing preview\n    !hoveredQuadrant) {\n      block = applyVizPadding({ item: block, padding: panelPadding });\n      return renderItemDropTarget({\n        position: block.position,\n        direction: findQuadrant({\n          item: block,\n          position: mousePosition\n        })\n      });\n    }\n    return null;\n  }, [\n    layoutStructure,\n    panelPadding,\n    getSelectedItems,\n    hoveredQuadrant,\n    mousePosition,\n    renderItemDropTarget\n  ]);\n  const handleShowPreviewPlaceholder = (0, react_exports.useCallback)(\n    ({ mousePos }) => {\n      const selectedItem = getSelectedItems()[0];\n      if (!selectedItem) {\n        setShowPreviewPlaceholder(false);\n        return;\n      }\n      const hoveredViz = findTopBlockItemByPosition(\n        layoutStructure,\n        mousePos,\n        panelPadding\n      );\n      if (hoveredViz && hoveredViz.item === selectedItem.id) {\n        setShowPreviewPlaceholder(true);\n        return;\n      }\n      if (invalidEdgeId !== null || isInvalidVizDrop) {\n        setShowPreviewPlaceholder(true);\n        return;\n      }\n      if (containsPreviewItem) {\n        setShowPreviewPlaceholder(true);\n        return;\n      }\n      setShowPreviewPlaceholder(false);\n    },\n    [\n      containsPreviewItem,\n      panelPadding,\n      getSelectedItems,\n      invalidEdgeId,\n      isInvalidVizDrop,\n      layoutStructure\n    ]\n  );\n  const handleBlockItemMove = (0, react_exports.useCallback)(\n    (_e, { currentPosition }) => {\n      if (getSelectedItems().length > 0) {\n        handleShowPreviewPlaceholder({ mousePos: currentPosition });\n        setIsBlockItemMoving(true);\n        setMousePosition(currentPosition);\n        showEdgeDropPreview({ mousePos: currentPosition });\n        showVizDropPreview({ mousePos: currentPosition });\n      }\n    },\n    [\n      getSelectedItems,\n      showEdgeDropPreview,\n      showVizDropPreview,\n      handleShowPreviewPlaceholder\n    ]\n  );\n  const handleVizDrop = (0, react_exports.useCallback)(() => {\n    const validEdges = edgesBeforeMove || edges;\n    const selectedItems = getSelectedItems();\n    if (selectedItems.length === 0) {\n      return;\n    }\n    const edge = validEdges.find((e) => {\n      return isMouseOnEdge({\n        edge: e,\n        mousePosition,\n        padding: panelPadding\n      });\n    });\n    const block = findTopBlockItemByPosition(\n      layoutStructure,\n      mousePosition,\n      panelPadding\n    );\n    const itemToMove = layoutStructure.find(\n      ({ item }) => item === selectedItems[0].id\n    );\n    if (block === itemToMove) {\n      sendTelemetry({\n        source: \"canvas\",\n        event: \"viz_drop_on_self_successful\"\n      });\n      return;\n    }\n    const itemsSelected = layoutStructure;\n    let updatedItems = null;\n    if (edge !== void 0) {\n      updatedItems = updateDropOnEdge({\n        edge,\n        itemToMove,\n        items: itemsSelected,\n        canvasWidth\n      });\n      if (updatedItems === null) {\n        sendTelemetry({\n          source: \"canvas\",\n          event: \"viz_drop_on_edge_unsuccessful\"\n        });\n        return;\n      }\n      updatedItems = updateItems({\n        updatedVisualizations: updatedItems.updatedVisualizations,\n        itemToMove: updatedItems.updatedItemToMove,\n        items: itemsSelected,\n        canvasWidth\n      });\n      sendTelemetry({\n        source: \"canvas\",\n        event: \"viz_drop_on_edge_successful\"\n      });\n    } else if (block !== void 0 && block.item !== selectedItems[0].id) {\n      const direction = findQuadrant({\n        item: applyVizPadding({ item: block, padding: panelPadding }),\n        position: mousePosition\n      });\n      if (isInvalidAdjacentVizDrop({\n        itemToMove,\n        itemToDropOn: block,\n        direction,\n        visualizations: layoutStructure\n      })) {\n        return;\n      }\n      const updatedVisualizations = updateDropOnViz({\n        itemToMove,\n        itemToDropOn: block,\n        direction\n      });\n      if (updatedVisualizations === null) {\n        sendTelemetry({\n          source: \"canvas\",\n          event: \"viz_drop_on_viz_unsuccessful\"\n        });\n        return;\n      }\n      updatedItems = updateItems({\n        updatedVisualizations,\n        itemToMove,\n        items: itemsSelected,\n        canvasWidth\n      });\n      sendTelemetry({\n        source: \"canvas\",\n        event: \"viz_drop_on_viz_successful\"\n      });\n    }\n    if (updatedItems != null) {\n      onLayoutStructureChange(updatedItems);\n    }\n  }, [\n    layoutStructure,\n    edgesBeforeMove,\n    edges,\n    getSelectedItems,\n    mousePosition,\n    panelPadding,\n    sendTelemetry,\n    canvasWidth,\n    onLayoutStructureChange\n  ]);\n  const cleanupAfterPreview = (0, react_exports.useCallback)(() => {\n    if (delayPreviewViz.current) {\n      clearTimeout(delayPreviewViz.current);\n    }\n    if (delayPreviewEdge.current) {\n      clearTimeout(delayPreviewEdge.current);\n    }\n    setInvalidEdgeId(null);\n    setIsInvalidVizDrop(false);\n    setInitialItemToMove(null);\n    setHoveredBlock(null);\n    setHoveredQuadrant(null);\n    if (edgesBeforeMove) {\n      setEdges(edgesBeforeMove);\n      setEdgesBeforeMove(null);\n      dispatch(resetLayoutAction(layoutStructure));\n    }\n    if (hoveredBlock) {\n      dispatch(resetLayoutAction(layoutStructure));\n    }\n  }, [edgesBeforeMove, hoveredBlock, layoutStructure]);\n  const handleBlockItemMoved = (0, react_exports.useCallback)(() => {\n    cleanupAfterPreview();\n    if (mousePosition !== null) {\n      handleVizDrop();\n    }\n    setIsBlockItemMoving(false);\n    setMousePosition(null);\n  }, [cleanupAfterPreview, mousePosition, handleVizDrop]);\n  const handleBlockItemPositionUpdate = (0, react_exports.useCallback)(({ item, offset }) => {\n    const newItem = updateBlockItemPosition(item, offset);\n    dispatch(updateItemAction(newItem));\n  }, []);\n  const handleBlockItemResize = (0, react_exports.useCallback)(\n    (e, {\n      itemId,\n      offset,\n      dir\n    }) => {\n      const item = getStructureItem(layoutStructure, itemId);\n      const newItem = updateBlockItemSize({\n        item,\n        offset,\n        dir,\n        options: {\n          minHeight: MIN_HEIGHT_PX,\n          minWidth: MIN_WIDTH_PX\n        }\n      });\n      dispatch(updateItemAction(newItem));\n    },\n    [layoutStructure]\n  );\n  const handleBlockItemResized = (0, react_exports.useCallback)(() => {\n    handleLayoutStructureChange();\n    sendTelemetry({\n      source: \"canvas\",\n      event: \"edge_resize\"\n    });\n  }, [handleLayoutStructureChange, sendTelemetry]);\n  const handleMouseDownOnEdge = (0, react_exports.useCallback)(\n    (e, { id }) => {\n      isDraggingEdge.current = true;\n      const edge = edges.find(({ item }) => item === id);\n      if (!edge) {\n        return;\n      }\n      const visualizationIds = edge.visualizations.map((viz) => viz.item);\n      const newEdgeBoundaries = edge.orientation === \"horizontal\" ? getVerticalBoundaries({\n        visualizations: edge.visualizations,\n        y: edge.edgeStart.y,\n        minHeight: MIN_HEIGHT_PX,\n        isFullWidthEdge: edge.edgeEnd.x - edge.edgeStart.x === canvasWidth\n      }) : getHorizontalBoundaries({\n        visualizations: edge.visualizations,\n        x: edge.edgeStart.x,\n        minWidth: MIN_WIDTH_PX\n      });\n      edgeBoundaries.current = newEdgeBoundaries;\n      edgesInBoundary.current = findEdgesInBoundary({\n        edge,\n        edges,\n        edgeBoundaries: newEdgeBoundaries\n      });\n      edgeMouseDownPosition.current = getClientPosition(e, mouseScale);\n      mouseDownEdge.current = __spreadValues({}, edge);\n      setSelectedItemsForEdge(visualizationIds);\n    },\n    [edges, mouseScale, canvasWidth]\n  );\n  const handleEdgeMove = (0, dashboard_ui_exports.useEventCallback)((e) => {\n    var _a2, _b, _c, _d;\n    e.preventDefault();\n    e.stopPropagation();\n    if (!isDraggingEdge.current || !mouseDownEdge.current) {\n      return;\n    }\n    const currentPosition = getClientPosition(e, mouseScale);\n    const offset = getOffset(\n      currentPosition,\n      edgeMouseDownPosition.current\n    );\n    offset.offsetY += cumulativeScrollIncrease.current;\n    let updatedEdge = ((_a2 = mouseDownEdge == null ? void 0 : mouseDownEdge.current) == null ? void 0 : _a2.orientation) === \"vertical\" ? moveVerticalEdge({\n      edge: mouseDownEdge.current,\n      offset: offset.offsetX,\n      edgeBoundaries: edgeBoundaries.current\n    }) : moveHorizontalEdge({\n      edge: mouseDownEdge.current,\n      offset: offset.offsetY,\n      edgeBoundaries: edgeBoundaries.current\n    });\n    let updatedSnappableEdges = [];\n    if (!e.shiftKey) {\n      const { updatedEdge: ue, snappableEdges: se } = findSnappableEdges({\n        edge: updatedEdge,\n        edges: (_b = edgesInBoundary.current) != null ? _b : [],\n        snapRange: SNAP_RANGE_PX\n      });\n      updatedEdge = ue;\n      updatedSnappableEdges = se;\n    }\n    setEdges(\n      (prevEdges) => prevEdges.map((anEdge) => {\n        if (anEdge.item === updatedEdge.item) {\n          return updatedEdge;\n        }\n        return anEdge;\n      })\n    );\n    const vizOffset = {\n      offsetX: updatedEdge.edgeStart.x - mouseDownEdge.current.edgeStart.x,\n      offsetY: updatedEdge.edgeStart.y - mouseDownEdge.current.edgeStart.y\n    };\n    const isFullWidthEdge = mouseDownEdge.current.edgeEnd.x - mouseDownEdge.current.edgeStart.x === canvasWidth;\n    if (isFullWidthEdge) {\n      layoutStructure.forEach((item) => {\n        if (mouseDownEdge.current && item.position.y >= mouseDownEdge.current.edgeStart.y) {\n          handleBlockItemPositionUpdate({\n            item,\n            offset: vizOffset\n          });\n        }\n      });\n    }\n    if (selectedItemsForEdge.length > 0) {\n      selectedItemsForEdge.forEach((itemId) => {\n        var _a3;\n        const item = getStructureItem(layoutStructure, itemId);\n        if (!mouseDownEdge.current || isFullWidthEdge && item.position.y >= mouseDownEdge.current.edgeStart.y) {\n          return;\n        }\n        let resizeDir;\n        if (((_a3 = mouseDownEdge.current) == null ? void 0 : _a3.orientation) === \"horizontal\") {\n          resizeDir = item.position.y >= mouseDownEdge.current.edgeStart.y ? \"n\" : \"s\";\n        } else {\n          resizeDir = item.position.x >= mouseDownEdge.current.edgeStart.x ? \"w\" : \"e\";\n        }\n        handleBlockItemResize(e, {\n          itemId,\n          offset: vizOffset,\n          dir: resizeDir\n        });\n      });\n    }\n    setSnappableEdges(updatedSnappableEdges);\n    if (((_c = mouseDownEdge == null ? void 0 : mouseDownEdge.current) == null ? void 0 : _c.orientation) === \"horizontal\" && ((_d = mouseDownEdge == null ? void 0 : mouseDownEdge.current) == null ? void 0 : _d.isCanvasEdge)) {\n      const scrollVelocity = e.clientY - window.innerHeight + CANVAS_BOTTOM_PADDING * 2;\n      edgeVelocity.current = scrollVelocity;\n      setMousePosition(getClientPosition(e, mouseScale));\n    }\n  });\n  (0, dashboard_ui_exports.useMouseMoveHandler)({\n    onMouseMove: handleEdgeMove,\n    isEnabled: mode === \"edit\",\n    throttledMs: 32\n  });\n  (0, react_exports.useEffect)(() => {\n    if (mode !== \"edit\" || edgeVelocity.current <= 0 || !mouseDownEdge.current || !edgeMouseDownPosition.current || !mousePosition) {\n      return void 0;\n    }\n    const currEdge = mouseDownEdge.current;\n    const isFullWidthEdge = currEdge.edgeEnd.x - currEdge.edgeStart.x === canvasWidth;\n    if (!isFullWidthEdge) {\n      return void 0;\n    }\n    const offset = edgeVelocity.current > 8 ? BOTTOM_EDGE_MAX_SPEED : BOTTOM_EDGE_MIN_SPEED;\n    const edgeMousePos = edgeMouseDownPosition.current;\n    const interval = setInterval(() => {\n      cumulativeScrollIncrease.current += offset;\n      const mouseOffset = getOffset(mousePosition, edgeMousePos);\n      const updatedEdge = moveHorizontalEdge({\n        edge: currEdge,\n        offset: mouseOffset.offsetY + cumulativeScrollIncrease.current,\n        edgeBoundaries: edgeBoundaries.current\n      });\n      setEdges(\n        (prevEdges) => prevEdges.map((anEdge) => {\n          if (anEdge.item === currEdge.item) {\n            return __spreadProps(__spreadValues({}, anEdge), {\n              edgeStart: {\n                x: anEdge.edgeStart.x,\n                y: updatedEdge.edgeStart.y\n              },\n              edgeEnd: {\n                x: anEdge.edgeEnd.x,\n                y: updatedEdge.edgeStart.y\n              }\n            });\n          }\n          return anEdge;\n        })\n      );\n      const vizOffset = {\n        offsetX: 0,\n        offsetY: updatedEdge.edgeStart.y - currEdge.edgeStart.y\n      };\n      if (selectedItemsForEdge.length > 0) {\n        selectedItemsForEdge.forEach((itemId) => {\n          const resizeDir = \"s\";\n          handleBlockItemResize(mousePosition, {\n            itemId,\n            offset: vizOffset,\n            dir: resizeDir\n          });\n        });\n      }\n      if (canvasContext.current) {\n        canvasContext.current.scrollTop += BOTTOM_RESIZING_SCROLL_SPEED;\n      }\n    }, 32);\n    return () => {\n      clearInterval(interval);\n    };\n  }, [\n    mode,\n    edgeVelocity,\n    mousePosition,\n    cumulativeScrollIncrease,\n    canvasContext,\n    canvasWidth,\n    handleBlockItemResize,\n    layoutStructure,\n    selectedItemsForEdge\n  ]);\n  const handleEdgeMoved = (0, dashboard_ui_exports.useEventCallback)((e) => {\n    e.preventDefault();\n    mouseDownEdge.current = null;\n    edgeMouseDownPosition.current = null;\n    edgeBoundaries.current = null;\n    edgesInBoundary.current = null;\n    cumulativeScrollIncrease.current = 0;\n    edgeVelocity.current = 0;\n    if (isDraggingEdge.current) {\n      isDraggingEdge.current = false;\n      setSelectedItemsForEdge([]);\n      handleBlockItemResized();\n    }\n    if (snappableEdges.length > 0) {\n      setSnappableEdges([]);\n    }\n  });\n  (0, react_exports.useEffect)(() => {\n    if (mode !== \"edit\") {\n      return void 0;\n    }\n    document.addEventListener(\"mouseup\", handleEdgeMoved);\n    return () => {\n      document.removeEventListener(\"mouseup\", handleEdgeMoved);\n    };\n  }, [handleEdgeMoved, mode]);\n  (0, react_exports.useEffect)(() => {\n    if (!keyboardListener) {\n      return () => void 0;\n    }\n    const unsubscribeKeyboardListener = keyboardListener.subscribe(\n      \"cancel\",\n      () => {\n        if (isBlockItemMoving) {\n          cleanupAfterPreview();\n          setIsBlockItemMoving(false);\n          setMousePosition(null);\n        } else {\n          onLayoutItemsSelect([]);\n        }\n      }\n    );\n    return () => {\n      unsubscribeKeyboardListener();\n    };\n  }, [\n    cleanupAfterPreview,\n    isBlockItemMoving,\n    onLayoutItemsSelect,\n    keyboardListener\n  ]);\n  const renderOutline = () => {\n    const selectedItems = selectedItemsForEdge.length > 0 ? selectedItemsForEdge : getSelectedItems().map(({ id }) => id);\n    const blockItems = getBlockItems(gridState);\n    return blockItems.map((item) => {\n      const displayOutline = selectedItems.includes(item.item) && (!isBlockItemMoving || showPreviewPlaceholder);\n      if (displayOutline) {\n        const paddedItem = applyVizPadding({\n          item,\n          padding: panelPadding\n        });\n        return /* @__PURE__ */ react_default.createElement(\n          MemoizedBlockOutline,\n          {\n            handleDirections: HANDLE_DIRECTIONS,\n            key: item.item,\n            itemId: item.item,\n            scale: mouseScale,\n            x: paddedItem.position.x,\n            y: paddedItem.position.y,\n            w: paddedItem.position.w,\n            h: paddedItem.position.h\n          }\n        );\n      }\n      return null;\n    });\n  };\n  const getEdgeAppearance = (0, react_exports.useCallback)(\n    ({ edge }) => {\n      var _a2;\n      const renderAllEdges = !mouseDownEdge.current;\n      let appearance = renderAllEdges || edge.item === ((_a2 = mouseDownEdge.current) == null ? void 0 : _a2.item) || snappableEdges.find((e) => e.item === edge.item) ? \"normal\" : \"hidden\";\n      if (isBlockItemMoving) {\n        const itemToMove = layoutStructure.find(\n          ({ item }) => {\n            var _a3;\n            return item === ((_a3 = getSelectedItems()[0]) == null ? void 0 : _a3.id);\n          }\n        );\n        if (itemToMove && isDropOnOwnEdge({ edge, itemToMove })) {\n          appearance = \"hidden\";\n        } else {\n          appearance = \"dropTarget\";\n        }\n      }\n      if (invalidEdgeId === edge.item) {\n        appearance = \"invalid\";\n      }\n      return appearance;\n    },\n    [\n      invalidEdgeId,\n      isBlockItemMoving,\n      mouseDownEdge,\n      snappableEdges,\n      getSelectedItems,\n      layoutStructure\n    ]\n  );\n  const edgeItems = (0, react_exports.useMemo)(() => {\n    if (mode !== \"edit\") {\n      return null;\n    }\n    return edges.map((edge) => {\n      const formattedEdge = formatEdgeWrapper({\n        edge,\n        padding: panelPadding\n      });\n      const { width, height } = getDimensions({\n        edge: formattedEdge,\n        thickness: 2 * panelPadding\n      });\n      const { x, y } = formattedEdge.edgeStart;\n      return /* @__PURE__ */ react_default.createElement(\n        MemoizedEdge,\n        {\n          key: edge.item,\n          itemId: edge.item,\n          x,\n          y,\n          w: width,\n          h: height,\n          padding: panelPadding,\n          orientation: edge.orientation,\n          isCanvasEdge: edge.isCanvasEdge,\n          appearance: getEdgeAppearance({ edge }),\n          onMouseDown: handleMouseDownOnEdge,\n          \"data-test-edge-position\": `${edge.edgeStart.x},${edge.edgeStart.y}-${edge.edgeEnd.x},${edge.edgeEnd.y}`\n        }\n      );\n    });\n  }, [mode, edges, getEdgeAppearance, panelPadding, handleMouseDownOnEdge]);\n  const handleRenderPreviewPlaceholderItem = (0, react_exports.useCallback)(() => {\n    if (!firstSelectedItemStructure || !showPreviewPlaceholder) {\n      return null;\n    }\n    const item = applyVizPadding({\n      item: firstSelectedItemStructure,\n      padding: panelPadding\n    });\n    return /* @__PURE__ */ react_default.createElement(\n      PreviewPlaceholderItem,\n      {\n        key: `${firstSelectedItemStructure.item}-preview`,\n        position: item.position\n      }\n    );\n  }, [firstSelectedItemStructure, panelPadding, showPreviewPlaceholder]);\n  const filteredState = (0, react_exports.useMemo)(\n    () => getFilteredStructure(gridState, layoutStructure),\n    [gridState, layoutStructure]\n  );\n  const items = getSelectedItems();\n  const commonProps = {\n    width: canvasWidth,\n    height: maxHeight,\n    scale,\n    selectable: true,\n    selectedLayoutItems: items,\n    onItemSelected: handleItemSelected,\n    panelPadding,\n    ref: canvasRef\n  };\n  const modeSpecificProps = mode === \"edit\" ? {\n    movable: true,\n    showOverflowContent: false,\n    showGrid,\n    showBorder: true,\n    gridWidth: GRID_SIZE_PX - 1,\n    gridHeight: GRID_SIZE_PX - 1,\n    gridLineWidth: 1,\n    gridPadding: GRID_PADDING_PX,\n    onItemMove: handleBlockItemMove,\n    onItemMoved: handleBlockItemMoved,\n    userSelect: false\n  } : {\n    movable: false,\n    showOverflowContent: false,\n    showGrid: false,\n    showBorder: false,\n    userSelect: true\n  };\n  return /* @__PURE__ */ react_default.createElement(\n    GridCanvas_default,\n    __spreadValues(__spreadValues({\n      \"data-test\": \"grid-layout\",\n      blockItems: filteredState,\n      \"data-test-scale\": scale\n    }, commonProps), modeSpecificProps),\n    /* @__PURE__ */ react_default.createElement(Layer_default, { key: \"block-item-layer\", \"data-test\": \"block-item-layer\" }, renderBlockItems({\n      layoutStructure: filteredState,\n      renderLayoutItem,\n      handleItemSelected,\n      isBlockItemMoving,\n      selectedItem: getSelectedItems()[0],\n      mode,\n      errors: layoutErrors,\n      padding: panelPadding,\n      canvasHeight: maxHeight\n    })),\n    edgeItems,\n    /* @__PURE__ */ react_default.createElement(Layer_default, { key: \"outline-layer\", \"data-test\": \"outline-layer\" }, renderOutline()),\n    mousePosition && isBlockItemMoving && handleRenderItemDropTarget(),\n    mousePosition && isBlockItemMoving && handleRenderPreviewPlaceholderItem(),\n    mousePosition && isBlockItemMoving && /* @__PURE__ */ react_default.createElement(\n      ItemDragPlaceholder,\n      {\n        position: mousePosition,\n        size: PLACEHOLDER_SIZE_PX\n      }\n    )\n  );\n};\nvar GridLayout = (props) => {\n  const {\n    containerWidth,\n    containerHeight,\n    options: { width: canvasWidth = gridLayoutOptions.width } = {},\n    onLayoutStructureChange,\n    layoutStructure\n  } = props;\n  const { enableGridLayoutCssScaling } = (0, dashboard_context_exports.useFeatureFlags)();\n  const scrollbarWidth = (0, dashboard_utils_exports.getScrollbarWidth)();\n  const [canvasHeight, setCanvasHeight] = (0, react_exports.useState)(\n    () => computeMaxHeight(layoutStructure)\n  );\n  const scale = (0, react_exports.useMemo)(\n    () => computeScaleToFit({\n      canvasWidth,\n      canvasHeight,\n      containerWidth,\n      containerHeight,\n      scrollbarWidth,\n      enableGridLayoutCssScaling\n    }),\n    [\n      enableGridLayoutCssScaling,\n      canvasWidth,\n      canvasHeight,\n      containerWidth,\n      containerHeight,\n      scrollbarWidth\n    ]\n  );\n  const handleLayoutStructureChange = (0, react_exports.useCallback)(\n    (layout) => {\n      onLayoutStructureChange(\n        scaleGridLayoutStructureByWidth({\n          layout,\n          scale: 1 / scale\n        })\n      );\n    },\n    [scale, onLayoutStructureChange]\n  );\n  const scaledLayoutStructure = (0, react_exports.useMemo)(\n    () => !enableGridLayoutCssScaling ? scaleGridLayoutStructureByWidth({\n      layout: layoutStructure,\n      scale\n    }) : layoutStructure,\n    [enableGridLayoutCssScaling, layoutStructure, scale]\n  );\n  const sortedLayoutStructure = (0, react_exports.useMemo)(\n    () => getGridLayoutOrder({\n      layout: scaledLayoutStructure,\n      canvasWidth,\n      canvasHeight: computeMaxHeight(scaledLayoutStructure)\n    }),\n    [canvasWidth, scaledLayoutStructure]\n  );\n  return /* @__PURE__ */ react_default.createElement(\n    BaseGridLayout,\n    __spreadValues(__spreadProps(__spreadValues({}, props), {\n      scale,\n      canvasWidth,\n      layoutStructure: sortedLayoutStructure,\n      setCanvasHeight\n    }), !enableGridLayoutCssScaling ? {\n      canvasWidth: containerWidth - scrollbarWidth,\n      onLayoutStructureChange: handleLayoutStructureChange\n    } : null)\n  );\n};\nvar GridLayout_default = withLayoutShowHide(GridLayout, {\n  schema: gridLayoutOptionsSchema_default,\n  reflowFn: gridLayoutShowHideReflow\n});\n\n// src/utils/gridLayoutViewerUtils.ts\nvar getTemplateItems = ([currGridLine, nextGridLine, ...rest], axisLength, templateItems = []) => {\n  templateItems.push(`[${currGridLine.names.join(\" \")}]`);\n  if (!nextGridLine) {\n    return templateItems.join(\" \");\n  }\n  const gridTrackWidth = Math.round(\n    (nextGridLine.pos - currGridLine.pos) / axisLength * 100\n  );\n  templateItems.push(`minmax(0, ${gridTrackWidth}fr)`);\n  return getTemplateItems([nextGridLine, ...rest], axisLength, templateItems);\n};\nvar getTemplateItemsFromGridLines = (gridLines, axisLength) => {\n  if (gridLines.length === 0) {\n    return \"\";\n  }\n  return getTemplateItems(gridLines, axisLength);\n};\nvar getCSSGridTemplate = ({\n  layoutStructure,\n  width,\n  height\n}) => {\n  const xCoords = [];\n  const yCoords = [];\n  layoutStructure.forEach(({ position: { x, y, w, h }, item }) => {\n    var _a, _b, _c, _d;\n    xCoords[x] = (_a = xCoords[x]) != null ? _a : [];\n    xCoords[x + w] = (_b = xCoords[x + w]) != null ? _b : [];\n    yCoords[y] = (_c = yCoords[y]) != null ? _c : [];\n    yCoords[y + h] = (_d = yCoords[y + h]) != null ? _d : [];\n    xCoords[x].push(`${item}-start`);\n    xCoords[x + w].push(`${item}-end`);\n    yCoords[y].push(`${item}-start`);\n    yCoords[y + h].push(`${item}-end`);\n  });\n  const xGridLines = Object.entries(xCoords).map(([pos, names]) => ({\n    pos: Number(pos),\n    names\n  }));\n  const yGridLines = Object.entries(yCoords).map(([pos, names]) => ({\n    pos: Number(pos),\n    names\n  }));\n  const gridRowTemplate = getTemplateItemsFromGridLines(yGridLines, height);\n  const gridColTemplate = getTemplateItemsFromGridLines(xGridLines, width);\n  return { gridRowTemplate, gridColTemplate };\n};\n\n// src/GridLayoutViewer.tsx\nvar GridCanvas2 = styled_components_default.div`\n    ${themes_exports.mixins.reset(\"grid\")};\n    height: ${(props) => props.height}px;\n    width: 100%;\n    padding: ${(props) => props.gutterSize / 2}px;\n    box-sizing: border-box;\n    grid-template-columns: ${(props) => props.colTemplate};\n    grid-template-rows: ${(props) => props.rowTemplate};\n    gap: ${(props) => props.gutterSize}px;\n    background: ${dashboard_ui_exports.customThemeVariables.dashboardBackgroundColor};\n`;\nGridCanvas2.displayName = \"GridCanvas\";\nvar GridLayoutViewer = ({\n  layoutStructure,\n  renderLayoutItem,\n  options\n}) => {\n  const { width, gutterSize } = __spreadValues(__spreadValues({}, gridLayoutOptions), options);\n  const { height, gridItems, rowTemplate, colTemplate } = (0, react_exports.useMemo)(() => {\n    const filteredStructure = removeInvalidItems(\n      layoutStructure\n    );\n    const structureHeight = computeMaxHeight(filteredStructure);\n    const { gridRowTemplate, gridColTemplate } = getCSSGridTemplate({\n      layoutStructure: filteredStructure,\n      width,\n      height: structureHeight\n    });\n    const items = filteredStructure.map(({ item: itemId, type }) => /* @__PURE__ */ react_default.createElement(\n      GridItem_default,\n      {\n        itemId,\n        type,\n        key: itemId,\n        renderLayoutItem\n      }\n    ));\n    return {\n      height: structureHeight,\n      gridItems: items,\n      rowTemplate: gridRowTemplate,\n      colTemplate: gridColTemplate\n    };\n  }, [layoutStructure, width, renderLayoutItem]);\n  return /* @__PURE__ */ react_default.createElement(\n    GridCanvas2,\n    {\n      \"data-test\": \"grid-layout-canvas\",\n      \"data-layout-type\": \"grid\",\n      height,\n      gutterSize,\n      rowTemplate,\n      colTemplate\n    },\n    gridItems\n  );\n};\nGridLayoutViewer.propTypes = __spreadValues({}, BaseLayout_default.propTypes);\nGridLayoutViewer.defaultProps = __spreadValues({}, BaseLayout_default.defaultProps);\nvar GridLayoutViewer_default = GridLayoutViewer;\n\n// esm-externals:@dnd-kit/core\nvar core_exports = {};\n__export(core_exports, {\n  default: () => core_default\n});\nvar defaultImport17 = __toESM(require(\"@dnd-kit/core\"));\n__reExport(core_exports, require(\"@dnd-kit/core\"));\nvar core_default = \"default\" in defaultImport17 ? defaultImport17.default : defaultImport17;\n\n// src/InputLayoutViewer.tsx\nvar InputContainer = styled_components_default.div`\n    ${themes_exports.mixins.reset(\"block\")};\n    padding: 8px 0px;\n    background: ${(prop) => prop.backgroundColor || dashboard_ui_exports.customThemeVariables.dashboardBackgroundColor};\n    &:empty {\n        padding: 0;\n    }\n`;\nvar defaultInputRender = () => null;\nvar defaultStructure = [];\nvar InputLayout = (0, react_exports.forwardRef)(\n  ({\n    submitButton = false,\n    submitButtonDisabled = false,\n    inputStructure = defaultStructure,\n    renderInput = defaultInputRender,\n    onSubmitButtonClick = dashboard_utils_exports.noop\n  }, ref) => {\n    const { setNodeRef } = (0, core_exports.useDroppable)({\n      id: \"__dnd-inputs-dropzone__\"\n    });\n    const composedRef = (0, react_exports.useCallback)(\n      (element) => {\n        if (ref) {\n          if (typeof ref === \"function\") {\n            ref(element);\n          } else {\n            ref.current = element;\n          }\n        }\n        setNodeRef(element);\n      },\n      [ref, setNodeRef]\n    );\n    const submit = (0, react_exports.useMemo)(\n      () => inputStructure.length && submitButton ? /* @__PURE__ */ react_default.createElement(\n        dashboard_ui_exports.SubmitButton,\n        {\n          \"data-test\": \"input-item-submit-button\",\n          key: \"submit_button\",\n          disabled: submitButtonDisabled,\n          onClick: onSubmitButtonClick\n        }\n      ) : null,\n      [\n        inputStructure.length,\n        submitButton,\n        submitButtonDisabled,\n        onSubmitButtonClick\n      ]\n    );\n    if (inputStructure.length === 0) {\n      return null;\n    }\n    return /* @__PURE__ */ react_default.createElement(\n      InputContainer,\n      {\n        ref: composedRef,\n        \"data-test\": \"input-layout-container\"\n      },\n      inputStructure.map(\n        (inputId, index) => renderInput({ inputId, index })\n      ),\n      submit\n    );\n  }\n);\nvar InputLayoutViewer_default = InputLayout;\n\n// esm-externals:@splunk/react-icons/Line\nvar Line_exports = {};\n__export(Line_exports, {\n  default: () => Line_default\n});\nvar defaultImport18 = __toESM(require(\"@splunk/react-icons/Line\"));\n__reExport(Line_exports, require(\"@splunk/react-icons/Line\"));\nvar Line_default = \"default\" in defaultImport18 ? defaultImport18.default : defaultImport18;\n\n// esm-externals:@splunk/visualization-encoding/Options\nvar Options_exports = {};\n__export(Options_exports, {\n  default: () => Options_default\n});\nvar defaultImport19 = __toESM(require(\"@splunk/visualization-encoding/Options\"));\n__reExport(Options_exports, require(\"@splunk/visualization-encoding/Options\"));\nvar Options_default = \"default\" in defaultImport19 ? defaultImport19.default : defaultImport19;\n\n// esm-externals:@splunk/visualizations-shared/schemaUtils\nvar schemaUtils_exports = {};\n__export(schemaUtils_exports, {\n  default: () => schemaUtils_default\n});\nvar defaultImport20 = __toESM(require(\"@splunk/visualizations-shared/schemaUtils\"));\n__reExport(schemaUtils_exports, require(\"@splunk/visualizations-shared/schemaUtils\"));\nvar schemaUtils_default = \"default\" in defaultImport20 ? defaultImport20.default : defaultImport20;\n\n// src/visualizations/ConnectedLineOptionsSchema.ts\nvar ConnectedLineOptionsSchema_default = {\n  toArrow: {\n    type: \"boolean\",\n    default: false,\n    description: \"Specify whether the line begins with an arrow.\"\n  },\n  fromArrow: {\n    type: \"boolean\",\n    default: false,\n    description: \"Specify whether the line ends in an arrow.\"\n  },\n  strokeColor: {\n    anyOf: [\n      {\n        type: \"string\",\n        pattern: schemaUtils_exports.COLOR_OR_TOKEN_PATTERN,\n        description: 'Specify the color of the line. The default for light mode is \"#000000\". The default for dark mode is \"#FFFFFF\"'\n      },\n      {\n        type: \"string\",\n        pattern: \"^>.*\"\n      }\n    ]\n  },\n  strokeDataSeries: {\n    type: \"string\",\n    pattern: \"^>.*\",\n    description: \"Data series for dynamic line coloring.\",\n    default: '> primary | seriesByType(\"number\")'\n  },\n  strokeDataPoint: {\n    type: \"string\",\n    pattern: \"^>.*\",\n    description: \"Data point that will map to the line color.\",\n    default: \"> strokeDataSeries | lastPoint()\"\n  },\n  strokeDasharray: {\n    type: \"number\",\n    default: 0,\n    description: \"Specify the length, in pixels, of both the line segments and the spaces between the line segments when you choose break up a line so that it is not solid.\"\n  },\n  strokeWidth: {\n    type: \"number\",\n    default: 1,\n    description: \"Specify the thickness, in pixels, of the line.\"\n  },\n  strokeOpacity: {\n    type: \"number\",\n    default: 1,\n    description: \"Specify a number less than one to increase the opacity of the line. For example, if you specify 0.50, the line will have an opacity that is half that of no opacity.\"\n  }\n};\n\n// esm-externals:@splunk/visualization-color-palettes/editors/PresetPalettes\nvar PresetPalettes_exports = {};\n__export(PresetPalettes_exports, {\n  default: () => PresetPalettes_default\n});\nvar defaultImport21 = __toESM(require(\"@splunk/visualization-color-palettes/editors/PresetPalettes\"));\n__reExport(PresetPalettes_exports, require(\"@splunk/visualization-color-palettes/editors/PresetPalettes\"));\nvar PresetPalettes_default = \"default\" in defaultImport21 ? defaultImport21.default : defaultImport21;\n\n// esm-externals:@splunk/visualizations/common/utils/configUtils\nvar configUtils_exports = {};\n__export(configUtils_exports, {\n  default: () => configUtils_default\n});\nvar defaultImport22 = __toESM(require(\"@splunk/visualizations/common/utils/configUtils\"));\n__reExport(configUtils_exports, require(\"@splunk/visualizations/common/utils/configUtils\"));\nvar configUtils_default = \"default\" in defaultImport22 ? defaultImport22.default : defaultImport22;\n\n// src/visualizations/ConnectedLineEditorConfig.ts\nvar defaultContext = {\n  defaultRangeValue: [\n    { to: 20, value: \"#D41F1F\" },\n    { from: 20, to: 40, value: \"#D94E17\" },\n    { from: 40, to: 60, value: \"#CBA700\" },\n    { from: 60, to: 80, value: \"#669922\" },\n    { from: 80, value: \"#118832\" }\n  ]\n};\nvar basePresetContext = {\n  strokeColorEditorConfig: void 0\n};\nvar basePresetOptions = {\n  strokeColor: void 0\n};\nvar presets = [\n  {\n    label: (0, i18n_exports._)(\"Static\"),\n    name: \"lineColor.static\",\n    value: {\n      context: __spreadValues({}, basePresetContext),\n      options: __spreadValues({}, basePresetOptions)\n    }\n  },\n  {\n    label: (0, i18n_exports._)(\"Dynamic\"),\n    name: \"lineColor.dynamic\",\n    value: {\n      context: __spreadProps(__spreadValues({}, basePresetContext), {\n        strokeColorEditorConfig: defaultContext.defaultRangeValue\n      }),\n      options: __spreadProps(__spreadValues({}, basePresetOptions), {\n        strokeColor: \"> strokeDataPoint | rangeValue(strokeColorEditorConfig)\"\n      })\n    }\n  }\n];\nvar StaticColorEditor = {\n  label: (0, i18n_exports._)(\"Color value\"),\n  option: \"strokeColor\",\n  editor: \"editor.color\",\n  showEditor: ({ options }) => !(0, configUtils_exports.isDynamicOption)(options == null ? void 0 : options.strokeColor),\n  editorProps: {\n    labelPosition: \"left\",\n    themeVariable: \"@splunk/dashboard-layouts/ConnectedLine.strokeColor\"\n  }\n};\nvar DynamicColorEditor = {\n  label: (0, i18n_exports._)(\"Color range\"),\n  option: \"strokeColor\",\n  context: \"defaultContext\",\n  editor: \"editor.dynamicColor\",\n  showEditor: ({ options }) => (0, configUtils_exports.isDynamicOption)(options == null ? void 0 : options.strokeColor),\n  editorProps: {\n    labelPosition: \"left\",\n    flyoutTitle: (0, i18n_exports._)(\"Dynamic line color\"),\n    formatters: [\n      {\n        label: (0, i18n_exports._)(\"Ranges\"),\n        value: \"rangeValue\",\n        isDefault: true,\n        // show it by default when open dynamic color flyout\n        defaults: {\n          strokeDataPoint: defaultContext.defaultRangeValue\n        }\n      }\n    ],\n    dataSelectors: [\n      {\n        label: (0, i18n_exports._)(\"Color field\"),\n        value: \"strokeDataPoint\"\n      }\n    ],\n    defaultPalettesConfig: PresetPalettes_exports.defaultPalettesConfig\n  }\n};\nvar editorConfig = [\n  {\n    label: (0, i18n_exports._)(\"Stroke\"),\n    layout: [\n      [\n        {\n          label: (0, i18n_exports._)(\"Opacity\"),\n          option: \"strokeOpacity\",\n          editor: \"editor.percent\"\n        },\n        {\n          label: (0, i18n_exports._)(\"Thickness (px)\"),\n          option: \"strokeWidth\",\n          editor: \"editor.number\",\n          editorProps: {\n            min: 1\n          }\n        },\n        {\n          label: (0, i18n_exports._)(\"Dash style\"),\n          option: \"strokeDasharray\",\n          editor: \"editor.number\",\n          editorProps: {\n            min: 0\n          }\n        }\n      ]\n    ]\n  },\n  {\n    label: (0, i18n_exports._)(\"Arrows\"),\n    layout: [\n      [\n        {\n          label: (0, i18n_exports._)(\"Starting point\"),\n          option: \"fromArrow\",\n          editor: \"editor.toggle\",\n          editorProps: {\n            labelPosition: \"right\"\n          }\n        },\n        {\n          label: (0, i18n_exports._)(\"Ending point\"),\n          option: \"toArrow\",\n          editor: \"editor.toggle\",\n          editorProps: {\n            labelPosition: \"right\"\n          }\n        }\n      ]\n    ]\n  },\n  {\n    label: (0, i18n_exports._)(\"Selected data field\"),\n    layout: [\n      [\n        {\n          label: (0, i18n_exports._)(\"Data field\"),\n          editor: \"editor.columnSelector\",\n          option: \"strokeDataSeries\",\n          context: \"strokeDataContext\",\n          editorProps: {\n            dataSourceKey: \"primary\",\n            prepareValue: (definition) => {\n              const {\n                options: { strokeDataSeries }\n              } = definition;\n              return {\n                context: {},\n                options: {\n                  strokeDataPoint: `> strokeDataSeries | lastPoint()`,\n                  strokeDataSeries\n                }\n              };\n            }\n          }\n        }\n      ]\n    ]\n  },\n  {\n    label: (0, i18n_exports._)(\"Coloring\"),\n    layout: [\n      [\n        {\n          label: (0, i18n_exports._)(\"Mode\"),\n          key: \"presetSelector\",\n          editor: \"editor.presetSelector\",\n          editorProps: {\n            presets,\n            value: ({\n              context,\n              options\n            }) => {\n              const initialPreset = (0, configUtils_exports.getInitialPreset)(\n                context,\n                options,\n                presets\n              );\n              return (initialPreset == null ? void 0 : initialPreset.label) || null;\n            }\n          }\n        }\n      ],\n      [\n        __spreadValues({}, StaticColorEditor)\n      ],\n      [\n        __spreadValues({}, DynamicColorEditor)\n      ]\n    ]\n  }\n];\nvar ConnectedLineEditorConfig_default = editorConfig;\n\n// src/visualizations/utils/lineUtils.ts\nvar computeArrowTriangle = (w, h, l, L) => {\n  if (l === 0) {\n    return { arrowW: 0, arrowH: 0, arrowL: 0 };\n  }\n  const arrowW = w * L / l;\n  const arrowH = h * L / l;\n  return { arrowW, arrowH, arrowL: L };\n};\nvar computeFromArrowAngle = (from, to) => {\n  if (to.x - from.x === 0) {\n    return from.y > to.y ? 90 : 270;\n  }\n  const angle = Math.atan((to.y - from.y) / (to.x - from.x)) * (180 / Math.PI);\n  return from.x > to.x ? angle : 180 + angle;\n};\nvar computeToArrowAngle = (from, to) => {\n  if (to.x - from.x === 0) {\n    return from.y > to.y ? 270 : 90;\n  }\n  const angle = Math.atan((to.y - from.y) / (to.x - from.x)) * (180 / Math.PI);\n  return from.x > to.x ? 180 + angle : angle;\n};\nvar getNewFrom = (from, to, arrowW, arrowH, fromArrow) => {\n  let newFromX;\n  let newFromY;\n  if (fromArrow) {\n    newFromX = from.x > to.x ? from.x - arrowW : from.x + arrowW;\n    newFromY = from.y > to.y ? from.y - arrowH : from.y + arrowH;\n  } else {\n    newFromX = from.x;\n    newFromY = from.y;\n  }\n  return { newFrom: { x: newFromX, y: newFromY } };\n};\nvar getNewTo = (from, to, arrowW, arrowH, toArrow) => {\n  let newToX;\n  let newToY;\n  if (toArrow) {\n    newToX = from.x > to.x ? to.x + arrowW : to.x - arrowW;\n    newToY = from.y > to.y ? to.y + arrowH : to.y - arrowH;\n  } else {\n    newToX = to.x;\n    newToY = to.y;\n  }\n  return { newTo: { x: newToX, y: newToY } };\n};\nvar computePathTriangle = (from, to) => {\n  const w = Math.abs(from.x - to.x);\n  const h = Math.abs(from.y - to.y);\n  const l = Math.sqrt(w * w + h * h);\n  return { w, h, l };\n};\n\n// src/visualizations/ConnectedLine.tsx\nvar rootSvgStyle = {\n  pointerEvents: \"none\",\n  overflow: \"visible\"\n};\nvar lineStyle = {\n  pointerEvents: \"auto\"\n};\nvar dataContract = {\n  requiredDataSources: [\"primary\"],\n  initialRequestParams: {}\n};\nvar vizConfig = {\n  optionsSchema: ConnectedLineOptionsSchema_default,\n  editorConfig: ConnectedLineEditorConfig_default,\n  dataContract,\n  key: \"abslayout.line\",\n  name: (0, i18n_exports._)(\"Connected Line\"),\n  category: dashboard_context_exports.vizCategories.get(\"shapes\"),\n  icon: Line_default,\n  events: {},\n  // no onEventTrigger called by connected line\n  supports: [\"dynamic-options\"],\n  // what capabilities are supported?\n  requiredProps: []\n};\nvar defaultOptions = {\n  strokeOpacity: 1,\n  strokeWidth: 1,\n  strokeDasharray: 0,\n  strokeDataSeries: '> primary | seriesByType(\"number\")',\n  strokeDataPoint: \"> strokeDataSeries | lastPoint()\",\n  fromArrow: false,\n  toArrow: false\n};\nvar defaultFrom = {\n  x: 0,\n  y: 0\n};\nvar defaultTo = {\n  x: 150,\n  y: 0\n};\nvar empty2 = {};\nvar ConnectedLine = ({\n  from = defaultFrom,\n  to = defaultTo,\n  onLineSelect = dashboard_utils_exports.noop,\n  options = defaultOptions,\n  dataSources = empty2,\n  context = empty2\n}) => {\n  const { colorScheme } = (0, themes_exports.useSplunkTheme)();\n  const renderOptions = (0, react_exports.useMemo)(() => {\n    try {\n      return Options_exports.Options.evaluate(\n        {\n          context,\n          options: __spreadValues(__spreadValues({}, defaultOptions), options)\n        },\n        dataSources\n      );\n    } catch (e) {\n      if (e instanceof Error) {\n        dashboard_utils_exports.console.error(\n          `Unexpected error evaluating line options: ${e.message}`\n        );\n      }\n    }\n    return defaultOptions;\n  }, [context, options, dataSources]);\n  const themeStrokeColor = colorScheme === \"light\" ? \"#000000\" : \"#ffffff\";\n  const { w, h, l } = computePathTriangle(from, to);\n  const arrowL = 5 * renderOptions.strokeWidth;\n  const { arrowW, arrowH } = computeArrowTriangle(w, h, l, arrowL);\n  const squashedArrows = arrowL > l && renderOptions.fromArrow && renderOptions.toArrow;\n  const fromArrowAngle = computeFromArrowAngle(from, to);\n  const toArrowAngle = computeToArrowAngle(from, to);\n  const fromArrowId = (0, dashboard_utils_exports.uniqueId)();\n  const toArrowId = (0, dashboard_utils_exports.uniqueId)();\n  const newW = w + arrowL;\n  const newH = h + 2 * arrowL + 10;\n  const { newFrom } = getNewFrom(\n    from,\n    to,\n    arrowW,\n    arrowH,\n    renderOptions.fromArrow\n  );\n  const { newTo } = getNewTo(from, to, arrowW, arrowH, renderOptions.toArrow);\n  return /* @__PURE__ */ react_default.createElement(\"svg\", { width: newW, height: newH, style: rootSvgStyle }, /* @__PURE__ */ react_default.createElement(\n    \"path\",\n    {\n      \"data-test\": \"arrows\",\n      d: squashedArrows ? `M${newTo.x} ${newTo.y} L${newFrom.x} ${newFrom.y}` : `M${newFrom.x} ${newFrom.y} L${newTo.x} ${newTo.y}`,\n      stroke: renderOptions.strokeColor || themeStrokeColor,\n      strokeOpacity: `${renderOptions.strokeOpacity}`,\n      strokeWidth: `${renderOptions.strokeWidth}`,\n      strokeDasharray: `${renderOptions.strokeDasharray}`,\n      fill: \"none\",\n      markerStart: renderOptions.fromArrow ? `url(#${fromArrowId})` : \"\",\n      markerEnd: renderOptions.toArrow ? `url(#${toArrowId})` : \"\"\n    }\n  ), /* @__PURE__ */ react_default.createElement(\n    \"path\",\n    {\n      \"data-test\": \"line\",\n      onMouseDown: onLineSelect,\n      d: `M${from.x} ${from.y} L${to.x} ${to.y}`,\n      strokeWidth: `${renderOptions.strokeWidth + 20}`,\n      fill: \"none\",\n      stroke: \"white\",\n      strokeOpacity: 0,\n      style: lineStyle\n    }\n  ), /* @__PURE__ */ react_default.createElement(\"defs\", null, /* @__PURE__ */ react_default.createElement(\n    \"marker\",\n    {\n      id: `${fromArrowId}`,\n      markerWidth: \"10\",\n      markerHeight: \"10\",\n      refX: squashedArrows ? \"5\" : \"0\",\n      refY: \"2\",\n      orient: `${fromArrowAngle}deg`,\n      markerUnits: \"strokeWidth\"\n    },\n    /* @__PURE__ */ react_default.createElement(\n      \"path\",\n      {\n        d: \"M0,0 L0,4 L5,2 z\",\n        fill: renderOptions.strokeColor || themeStrokeColor,\n        fillOpacity: `${renderOptions.strokeOpacity}`\n      }\n    )\n  ), /* @__PURE__ */ react_default.createElement(\n    \"marker\",\n    {\n      id: `${toArrowId}`,\n      markerWidth: \"10\",\n      markerHeight: \"10\",\n      refX: squashedArrows ? \"5\" : \"0\",\n      refY: \"2\",\n      orient: `${toArrowAngle}deg`,\n      markerUnits: \"strokeWidth\"\n    },\n    /* @__PURE__ */ react_default.createElement(\n      \"path\",\n      {\n        d: \"M0,0 L0,4 L5,2 z\",\n        fill: renderOptions.strokeColor || themeStrokeColor,\n        fillOpacity: `${renderOptions.strokeOpacity}`\n      }\n    )\n  )));\n};\nConnectedLine.config = vizConfig;\nvar ConnectedLine_default = ConnectedLine;\n\n// src/commonLayoutOptionsSchema.ts\nvar commonLayoutOptionsSchema_default = {\n  showTitleAndDescription: {\n    type: \"boolean\",\n    default: true,\n    description: \"A Boolean value to determine whether to display the Canvas Title and Description or not.\"\n  },\n  submitButton: {\n    type: \"boolean\",\n    description: 'You can also specify the layout option \"submitButton\". When set to true, a user must click a Submit button in order for the change in input selection to take effect (e.g. rerun searches with new dropdown values). If set to false, or if not specified at all, the dashboard will immediately refresh when a user makes a change in input selection.',\n    default: false\n  },\n  submitOnDashboardLoad: {\n    type: \"boolean\",\n    default: false,\n    description: \"A Boolean value to determine whether inputs should submit their default values (if they exist) on initial dashboard load in order to allow searches to run once before requiring submit button to be used. To be used when `submitButton` is set to true.\"\n  }\n};\n//# sourceMappingURL=index.js.map\n","/* Copyright © 2020 Splunk Inc.\nSPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or\nin part without a valid written license from Splunk Inc. is PROHIBITED. */\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  AbsoluteItemContainer: () => AbsoluteItemContainer,\n  ActionMenuContainer: () => ActionMenuContainer_default,\n  ActualSizeWrapper: () => ActualSizeWrapper,\n  CheckboxEditor: () => CheckboxEditor,\n  ComboBoxEditor: () => ComboBoxEditor_default,\n  ConnectedDashboardHeader: () => ConnectedDashboardHeader,\n  ControlGroup: () => ControlGroup,\n  DEFAULT_REQUEST_PARAMS: () => DEFAULT_REQUEST_PARAMS,\n  DataSourceContext: () => DataSourceContext_default,\n  DataSourceContextProvider: () => DataSourceContextProvider,\n  EVENT_MOUSE_DOWN_ON_HANDLE: () => EVENT_MOUSE_DOWN_ON_HANDLE,\n  EVENT_MOUSE_DOWN_ON_VIZ_WITH_HANDLE: () => EVENT_MOUSE_DOWN_ON_VIZ_WITH_HANDLE,\n  EditableListItem: () => EditableListItem_default,\n  EnterprisePopoverContentFactory: () => EnterprisePopoverContentFactory_default,\n  ErrorBoundary: () => ErrorBoundary_default,\n  ExportVisualizationModal: () => ExportVisualizationModal,\n  FlyoutPane: () => FlyoutPane,\n  Gallery: () => Gallery_default,\n  GalleryDeletionModal: () => GalleryDeletionModal_default,\n  GalleryMessage: () => GalleryMessage_default,\n  GallerySearch: () => GallerySearch_default,\n  GalleryUpload: () => GalleryUpload_default,\n  GalleryUploadWarningText: () => warningText,\n  Header: () => Header_default,\n  IconGallery: () => IconGallery_default,\n  ImageGallery: () => ImageGallery_default,\n  InlineCode: () => InlineCode,\n  InputTitle: () => InputTitle,\n  LastUpdateTime: () => LastUpdateTime_default,\n  LoadingIndicator: () => LoadingIndicator_default,\n  Message: () => Message_default2,\n  Option: () => Option2,\n  OptionContainer: () => OptionContainer,\n  OptionContent: () => OptionContent,\n  OptionGroup: () => OptionGroup_default,\n  OptionLabel: () => OptionLabel,\n  PaddedContainer: () => PaddedContainer,\n  PopoverContentFactory: () => PopoverContentFactory_default,\n  PopoverStatusIcon: () => PopoverStatusIcon_default,\n  ProtectedUrlModal: () => ProtectedUrlModal,\n  RISKY_WARNING_MESSAGE: () => RISKY_WARNING_MESSAGE,\n  RISKY_WARNING_POPOVER_DESCRIPTION: () => RISKY_WARNING_POPOVER_DESCRIPTION,\n  RiskyWarningPopoverContent: () => RiskyWarningPopoverContent_default,\n  SelectableContainer: () => SelectableContainer,\n  Separator: () => Separator_default,\n  SidebarCollapsiblePanel: () => SidebarCollapsiblePanel,\n  SimpleStatusIcon: () => SimpleStatusIcon_default,\n  SizeAwareWrapper: () => SizeAwareWrapper_default,\n  SizeWrapper: () => SizeWrapper,\n  SubmitButton: () => SubmitButton_default,\n  TabListMenu: () => TabListMenu,\n  TextEditor: () => TextEditor_default,\n  ThemeMenu: () => ThemeMenu,\n  VisualizationContent: () => VisualizationContent_default,\n  VisualizationFilter: () => VisualizationFilter_default,\n  VisualizationWaitingForInput: () => VisualizationWaitingForInput_default,\n  applyTranslucence: () => applyTranslucence,\n  createSubscribe: () => createSubscribe,\n  customThemeVariables: () => customThemeVariables,\n  emitRiskyWarningMessage: () => emitRiskyWarningMessage,\n  getBorderStyle: () => getBorderStyle,\n  getIconStatus: () => getIconStatus,\n  getInflection: () => getInflection,\n  getStatusMessage: () => getStatusMessage,\n  getWarningTextForDataSource: () => getWarningTextForDataSource,\n  isColor: () => isColor,\n  mapWithRiskySearchToast: () => mapWithRiskySearchToast,\n  monacoColors: () => monacoColors,\n  namedColors: () => namedColors_default,\n  sanitizeColor: () => sanitizeColor,\n  useBatchSubscribeToSearches: () => useBatchSubscribeToSearches,\n  useDragHandleComponent: () => useDragHandleComponent,\n  useEventCallback: () => useEventCallback_default,\n  useEventListener: () => useEventListener,\n  useGetFlyoutHeaderHeight: () => useGetFlyoutHeaderHeight,\n  useGetFlyoutHeaderPadding: () => useGetFlyoutHeaderPadding,\n  useInterval: () => useInterval,\n  useMouseMoveHandler: () => useMouseMoveHandler_default,\n  usePassiveEventsCheck: () => usePassiveEventsCheck,\n  usePopoverBlurCallback: () => usePopoverBlurCallback_default,\n  usePopoverState: () => usePopoverState,\n  usePrevious: () => usePrevious_default,\n  useRiskySearchToast: () => useRiskySearchToast,\n  useSearchBNF: () => useSearchBNF,\n  useSubscribeToSearches: () => useSubscribeToSearches,\n  useTabListMenu: () => useTabListMenu,\n  useTextInput: () => useTextInput,\n  withRiskySearchToast: () => withRiskySearchToast\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// esm-externals:styled-components\nvar styled_components_exports = {};\n__export(styled_components_exports, {\n  default: () => styled_components_default\n});\nvar defaultImport = __toESM(require(\"styled-components\"));\n__reExport(styled_components_exports, require(\"styled-components\"));\nvar styled_components_default = \"default\" in defaultImport ? defaultImport.default : defaultImport;\n\n// src/AbsoluteItemContainer.tsx\nvar AbsoluteItemContainer = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"absolute-item-container\"\n}))``;\n\n// esm-externals:react\nvar react_exports = {};\n__export(react_exports, {\n  default: () => react_default\n});\nvar defaultImport2 = __toESM(require(\"react\"));\n__reExport(react_exports, require(\"react\"));\nvar react_default = \"default\" in defaultImport2 ? defaultImport2.default : defaultImport2;\n\n// esm-externals:@splunk/themes\nvar themes_exports = {};\n__export(themes_exports, {\n  default: () => themes_default\n});\nvar defaultImport3 = __toESM(require(\"@splunk/themes\"));\n__reExport(themes_exports, require(\"@splunk/themes\"));\nvar themes_default = \"default\" in defaultImport3 ? defaultImport3.default : defaultImport3;\n\n// esm-externals:@splunk/ui-utils/i18n\nvar i18n_exports = {};\n__export(i18n_exports, {\n  default: () => i18n_default\n});\nvar defaultImport4 = __toESM(require(\"@splunk/ui-utils/i18n\"));\n__reExport(i18n_exports, require(\"@splunk/ui-utils/i18n\"));\nvar i18n_default = \"default\" in defaultImport4 ? defaultImport4.default : defaultImport4;\n\n// esm-externals:@splunk/moment\nvar moment_exports = {};\n__export(moment_exports, {\n  default: () => moment_default\n});\nvar defaultImport5 = __toESM(require(\"@splunk/moment\"));\n__reExport(moment_exports, require(\"@splunk/moment\"));\nvar moment_default = \"default\" in defaultImport5 ? defaultImport5.default : defaultImport5;\n\n// src/hooks/useInterval.js\nfunction useInterval(callback, delay) {\n  const savedCallback = (0, react_exports.useRef)();\n  (0, react_exports.useEffect)(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n  (0, react_exports.useEffect)(() => {\n    function tick() {\n      savedCallback.current();\n    }\n    let id;\n    if (delay !== null) {\n      id = setInterval(tick, delay);\n    }\n    return () => clearInterval(id);\n  }, [delay]);\n}\n\n// src/LastUpdateTime.tsx\nvar Container = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"last-update-time\"\n}))`\n    padding-left: 20px;\n    padding-right: 10px;\n    white-space: nowrap;\n    font-size: 12px;\n    color: ${themes_exports.variables.contentColorMuted};\n`;\nvar RelativeTime = styled_components_default.span`\n    font-weight: bold;\n`;\nvar prefix = (0, i18n_exports._)(\"As of\");\nvar getPrefix = ({\n  status,\n  lastUpdated,\n  isRealTimeSearch = false\n}) => {\n  if (isRealTimeSearch) {\n    return status === \"pause\" ? (0, i18n_exports._)(\"Paused\") : (0, i18n_exports._)(\"Updating live\");\n  }\n  switch (status) {\n    case \"failed\":\n      return (0, i18n_exports._)(\"Failed to update\");\n    case \"running\":\n    case \"finalizing\":\n      return lastUpdated ? prefix : (0, i18n_exports._)(\"Updating\");\n    default:\n      return lastUpdated ? prefix : \"\";\n  }\n};\nvar convertTime = (isRealTimeSearch, lastUpdated) => !isRealTimeSearch && lastUpdated ? moment_default(lastUpdated).fromNow() : null;\nvar LastUpdateTime = (props) => {\n  const { isRealTimeSearch = false, lastUpdated, status } = props;\n  const [update, triggerUpdate] = (0, react_exports.useState)(false);\n  const relativeTime = convertTime(isRealTimeSearch, lastUpdated);\n  const timePrefix = getPrefix(props);\n  useInterval(\n    () => {\n      return triggerUpdate(!update);\n    },\n    status ? 6e4 : null\n  );\n  if (!status) {\n    return null;\n  }\n  if (!timePrefix && !relativeTime) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(Container, null, timePrefix, timePrefix === prefix ? /* @__PURE__ */ react_default.createElement(RelativeTime, null, \" \", relativeTime) : null);\n};\nvar LastUpdateTime_default = LastUpdateTime;\n\n// src/ActionMenuContainer.tsx\nvar Container2 = styled_components_default.div.attrs(({ itemId }) => ({\n  /**\n   * As a child of a viz, data-id is probably not needed for tests as the viz already has that,\n   * and the action menu should be a child of that ancestor.\n   * It is left here for consistency with previous implementation\n   */\n  \"data-id\": itemId,\n  \"data-test\": \"action-menus\"\n}))`\n    display: inline-flex;\n    flex-direction: row;\n    justify-content: flex-end;\n    flex-shrink: 1;\n    align-items: center;\n    border-radius: 6px;\n    padding: 3px;\n    background-color: ${themes_exports.variables.backgroundColorPopup};\n    color: ${themes_exports.variables.contentColorDefault};\n    box-shadow: ${themes_exports.variables.overlayShadow};\n\n    /* hide me when there are no child elements (no buttons or time displayed) */\n    &:empty {\n        display: none;\n    }\n`;\nvar handleClick = (e) => {\n  e.stopPropagation();\n};\nvar ActionMenuContainer = ({\n  actionButtons,\n  lastUpdated,\n  status,\n  isRealTimeSearch,\n  showLastUpdated,\n  itemId,\n  children\n}) => {\n  return /* @__PURE__ */ react_default.createElement(\n    Container2,\n    {\n      itemId,\n      onMouseDown: handleClick,\n      onClick: handleClick,\n      onMouseUp: handleClick\n    },\n    actionButtons,\n    children,\n    showLastUpdated && /* @__PURE__ */ react_default.createElement(\n      LastUpdateTime_default,\n      {\n        status,\n        lastUpdated,\n        isRealTimeSearch\n      }\n    )\n  );\n};\nvar ActionMenuContainer_default = ActionMenuContainer;\n\n// esm-externals:@splunk/dashboard-state\nvar dashboard_state_exports = {};\n__export(dashboard_state_exports, {\n  default: () => dashboard_state_default\n});\nvar defaultImport6 = __toESM(require(\"@splunk/dashboard-state\"));\n__reExport(dashboard_state_exports, require(\"@splunk/dashboard-state\"));\nvar dashboard_state_default = \"default\" in defaultImport6 ? defaultImport6.default : defaultImport6;\n\n// src/ActualSizeWrapper.ts\nvar ActualSizeWrapper = ({ children }) => {\n  const { width, height } = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectLayoutDimensions);\n  return (children == null ? void 0 : children({ width, height })) || null;\n};\n\n// esm-externals:@splunk/react-ui/ComboBox\nvar ComboBox_exports = {};\n__export(ComboBox_exports, {\n  default: () => ComboBox_default\n});\nvar defaultImport7 = __toESM(require(\"@splunk/react-ui/ComboBox\"));\n__reExport(ComboBox_exports, require(\"@splunk/react-ui/ComboBox\"));\nvar ComboBox_default = \"default\" in defaultImport7 ? defaultImport7.default : defaultImport7;\n\n// src/ComboBoxEditor.tsx\nvar identity = ({ currOptions }) => currOptions;\nvar ComboBoxEditor = ({\n  value: initialValue = \"\",\n  options: initialOptions = [],\n  placeholder,\n  onChange,\n  generateOptions = identity,\n  error,\n  footerMessage\n}) => {\n  const [currValue, setValue] = (0, react_exports.useState)(initialValue);\n  const safeHandleChange = (0, react_exports.useCallback)(\n    (evt, updatedValue) => {\n      if (updatedValue !== initialValue) {\n        onChange(evt, updatedValue.trim());\n      }\n      setValue(updatedValue);\n    },\n    [onChange, initialValue]\n  );\n  const handleInputKeyPress = (0, react_exports.useCallback)(\n    (evt) => {\n      if (evt.key === \"Enter\") {\n        safeHandleChange(evt, currValue);\n      }\n    },\n    [safeHandleChange, currValue]\n  );\n  const handleInputBlur = (0, react_exports.useCallback)(\n    (evt) => {\n      safeHandleChange(evt, currValue);\n    },\n    [safeHandleChange, currValue]\n  );\n  const handleInputChange = (0, react_exports.useCallback)(\n    (evt, { value }) => {\n      if (!value) {\n        safeHandleChange(evt, value);\n      }\n      setValue(value);\n    },\n    [safeHandleChange]\n  );\n  const options = (0, react_exports.useMemo)(\n    () => generateOptions({\n      currValue,\n      currOptions: initialOptions\n    }).map((_a) => {\n      var _b = _a, { value: v } = _b, others = __objRest(_b, [\"value\"]);\n      return /* @__PURE__ */ react_default.createElement(ComboBox_default.Option, __spreadValues({ key: v, value: v }, others));\n    }),\n    [currValue, initialOptions, generateOptions]\n  );\n  return /* @__PURE__ */ react_default.createElement(\n    ComboBox_default,\n    {\n      value: currValue,\n      onChange: handleInputChange,\n      onKeyPress: handleInputKeyPress,\n      onBlur: handleInputBlur,\n      placeholder,\n      error,\n      footerMessage\n    },\n    options\n  );\n};\nvar ComboBoxEditor_default = ComboBoxEditor;\n\n// esm-externals:@splunk/dashboard-context\nvar dashboard_context_exports = {};\n__export(dashboard_context_exports, {\n  default: () => dashboard_context_default\n});\nvar defaultImport8 = __toESM(require(\"@splunk/dashboard-context\"));\n__reExport(dashboard_context_exports, require(\"@splunk/dashboard-context\"));\nvar dashboard_context_default = \"default\" in defaultImport8 ? defaultImport8.default : defaultImport8;\n\n// src/customThemeVariables.ts\nvar commonUIBackgroundColor = (0, themes_exports.pick)({\n  enterprise: {\n    light: themes_exports.variables.white,\n    dark: themes_exports.variables.black\n  },\n  prisma: themes_exports.variables.backgroundColorNavigation\n});\nvar commonUIBorderColor = (0, themes_exports.pick)({\n  enterprise: themes_exports.variables.borderColor,\n  prisma: themes_exports.variables.contentColorDisabled\n});\nvar monacoColors = {\n  background: {\n    light: \"#FFFFFE\",\n    dark: \"#222222\"\n  },\n  popup: {\n    light: \"#DDDDDD\",\n    dark: \"#000000\"\n  }\n};\nvar customThemeVariables = {\n  invalidDropTargetBackgroundColor: \"#8A393B\",\n  validDropTargetBackgroundColor: (0, themes_exports.pick)({\n    light: \"#80EC9F\",\n    dark: \"#117E32\"\n  }),\n  invalidDropTargetBorderColor: (0, themes_exports.pick)({\n    enterprise: \"#FE3A3A\",\n    prisma: themes_exports.variables.accentColorNegative\n  }),\n  validDropTargetBorderColor: (0, themes_exports.pick)({\n    enterprise: {\n      light: \"#07BA39\",\n      dark: \"#08E045\"\n    },\n    prisma: themes_exports.variables.accentColorPositive\n  }),\n  dashboardBackgroundColor: (0, themes_exports.pick)({\n    enterprise: {\n      light: themes_exports.variables.gray96,\n      dark: themes_exports.variables.gray20\n    },\n    prisma: themes_exports.variables.backgroundColorSection\n  }),\n  selectedInputBackgroundColor: (0, themes_exports.pick)({\n    enterprise: {\n      light: themes_exports.variables.gray92,\n      dark: themes_exports.variables.gray30\n    },\n    prisma: themes_exports.variables.backgroundColorPopup\n  }),\n  selectedInputBorderColor: (0, themes_exports.pick)({\n    enterprise: {\n      light: themes_exports.variables.borderColor,\n      dark: themes_exports.variables.gray45\n    },\n    prisma: themes_exports.variables.contentColorDisabled\n  }),\n  vizPanelBackgroundColor: (0, themes_exports.pick)({\n    enterprise: {\n      light: themes_exports.variables.white,\n      dark: themes_exports.variables.black\n    },\n    prisma: themes_exports.variables.backgroundColorSidebar\n  }),\n  toolbarBackgroundColor: commonUIBackgroundColor,\n  toolbarBorderColor: commonUIBorderColor,\n  sidebarPanelBackgroundColor: commonUIBackgroundColor,\n  sidebarPanelBorderColor: commonUIBorderColor,\n  monacoBackgroundColor: (0, themes_exports.pick)(monacoColors.background),\n  monacoBorder: \"1px solid rgba(0, 0, 0, 0.15)\"\n};\n\n// src/header/Title.tsx\nvar LINE_HEIGHT = \"28px\";\nvar fontSize = \"24px\";\nvar Title = styled_components_default.div`\n    ${themes_exports.mixins.reset(\"block\")};\n    ${(props) => props.isExpanded ? \"min-height\" : \"height\"}: LINE_HEIGHT;\n    max-width: 100%;\n    margin: 0;\n    padding: 1px 12px 0px 9px;\n    box-sizing: inherit;\n    line-height: ${LINE_HEIGHT};\n    font-size: ${fontSize};\n    font-weight: 500;\n    color: ${(0, themes_exports.pick)({\n  enterprise: {\n    light: themes_exports.variables.contentColorActive,\n    dark: themes_exports.variables.gray96\n  },\n  prisma: themes_exports.variables.contentColorActive\n})};\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: ${(props) => props.isExpanded ? \"normal\" : \"nowrap\"};\n`;\nvar TitleInput = styled_components_default.input`\n    ${themes_exports.mixins.reset(\"block\")};\n    height: ${LINE_HEIGHT};\n    width: 100%;\n    margin: 0;\n    padding: 3px 16px 0px 8px; // Left & Top Padding is intentionally different than the above component for alignment.\n    line-height: ${LINE_HEIGHT};\n    box-sizing: inherit;\n    font-size: ${fontSize};\n    font-weight: 500;\n    color: ${(0, themes_exports.pick)({\n  enterprise: {\n    light: themes_exports.variables.contentColorActive,\n    dark: themes_exports.variables.gray96\n  },\n  prisma: themes_exports.variables.contentColorActive\n})};\n    box-shadow: none;\n    outline: none;\n    background-color: 1px solid transparent;\n    border: transparent;\n\n    &:hover,\n    &:focus {\n        background-color: ${customThemeVariables.selectedInputBackgroundColor};\n        border-style: solid;\n        border-width: 1px;\n        border-color: ${customThemeVariables.selectedInputBorderColor};\n        border-radius: 4px;\n    }\n`;\nvar DashboardTitle = react_default.forwardRef(\n  ({\n    handleBlur,\n    handleChange,\n    handleKeyDown,\n    isExpanded = false,\n    mode,\n    value = \"\"\n  }, ref) => {\n    if (mode === \"edit\") {\n      return /* @__PURE__ */ react_default.createElement(\n        TitleInput,\n        {\n          ref,\n          \"data-test\": \"dashboard-title-input\",\n          onBlur: handleBlur,\n          onChange: handleChange,\n          onKeyDown: handleKeyDown,\n          placeholder: (0, i18n_exports._)(\"Untitled Dashboard\"),\n          value,\n          \"aria-label\": (0, i18n_exports._)(\"Dashboard title\")\n        }\n      );\n    }\n    return /* @__PURE__ */ react_default.createElement(\n      Title,\n      {\n        ref,\n        isExpanded,\n        \"data-test\": \"dashboard-title\"\n      },\n      value\n    );\n  }\n);\nvar Title_default = react_default.memo(DashboardTitle);\n\n// src/header/Description.tsx\nvar Description = styled_components_default.div`\n    ${themes_exports.mixins.reset(\"block\")};\n    min-height: 22px;\n    max-width: 100%;\n    margin: 0;\n    padding: 2px 12px 0px 9px;\n    box-sizing: inherit;\n    line-height: 15px;\n    font-size: 14px;\n    font-weight: 300;\n    color: ${(0, themes_exports.pick)({\n  enterprise: {\n    light: themes_exports.variables.contentColorDefault,\n    dark: themes_exports.variables.gray96\n  },\n  prisma: themes_exports.variables.contentColorDefault\n})};\n    text-overflow: ellipsis;\n`;\nvar DescriptionInput = styled_components_default.input`\n    ${themes_exports.mixins.reset(\"block\")};\n    height: 22px;\n    width: 100%;\n    margin: 0;\n    padding: 2px 12px 2px 8px; // Left & Bottom Padding is intentionally different than the above component for alignment.\n    box-sizing: inherit;\n    line-height: 15px;\n    font-size: 14px;\n    font-weight: 300;\n    flex-grow: 0;\n    color: ${(0, themes_exports.pick)({\n  enterprise: {\n    light: themes_exports.variables.contentColorDefault,\n    dark: themes_exports.variables.gray96\n  },\n  prisma: themes_exports.variables.contentColorDefault\n})};\n    outline: none;\n    background-color: 1px solid transparent;\n    border: transparent;\n\n    &:hover,\n    &:focus {\n        background-color: ${customThemeVariables.selectedInputBackgroundColor};\n        border-color: ${customThemeVariables.selectedInputBorderColor};\n        border-style: solid;\n        border-width: 1px;\n        border-radius: 4px;\n    }\n`;\nvar DashboardDescription = react_default.forwardRef(\n  ({\n    handleBlur,\n    handleChange,\n    handleKeyDown,\n    showInViewMode,\n    mode,\n    value\n  }, ref) => {\n    if (mode === \"view\" && !showInViewMode) {\n      return null;\n    }\n    if (mode === \"edit\") {\n      return /* @__PURE__ */ react_default.createElement(\n        DescriptionInput,\n        {\n          ref,\n          \"data-test\": \"dashboard-description-input\",\n          onBlur: handleBlur,\n          onChange: handleChange,\n          onKeyDown: handleKeyDown,\n          placeholder: (0, i18n_exports._)(\"Enter dashboard description.\"),\n          value,\n          \"aria-label\": (0, i18n_exports._)(\"Dashboard description\")\n        }\n      );\n    }\n    return /* @__PURE__ */ react_default.createElement(\n      Description,\n      {\n        ref,\n        \"data-test\": \"dashboard-description\"\n      },\n      value\n    );\n  }\n);\nvar Description_default = react_default.memo(DashboardDescription);\n\n// esm-externals:lodash/isString\nvar isString_exports = {};\n__export(isString_exports, {\n  default: () => isString_default\n});\nvar defaultImport9 = __toESM(require(\"lodash/isString\"));\n__reExport(isString_exports, require(\"lodash/isString\"));\nvar isString_default = \"default\" in defaultImport9 ? defaultImport9.default : defaultImport9;\n\n// src/hooks/useTextInput.ts\nvar empty = Object.freeze({});\nvar useTextInput = ({\n  initialValue = \"\",\n  handleCommit,\n  uniqKey = empty,\n  defaultValue = \"\",\n  controlledValue\n}) => {\n  const [value, setValue] = (0, react_exports.useState)(initialValue);\n  (0, react_exports.useEffect)(() => {\n    if (typeof controlledValue === \"string\") {\n      setValue(controlledValue);\n    }\n  }, [controlledValue]);\n  (0, react_exports.useEffect)(() => {\n    setValue(initialValue);\n  }, [uniqKey]);\n  const safeHandleChange = (0, react_exports.useCallback)(\n    (val) => {\n      if (val !== initialValue) {\n        const v = val.trim();\n        handleCommit(v);\n        if (v === \"\") {\n          setValue(defaultValue);\n        } else {\n          setValue(v);\n        }\n      }\n    },\n    [handleCommit, initialValue, defaultValue]\n  );\n  const onHandleKeyDown = (0, react_exports.useCallback)(\n    (evt) => {\n      if (isString_default(evt.key) && evt.key.toLowerCase() === \"enter\") {\n        safeHandleChange(\n          evt.target.value\n        );\n      }\n      if (isString_default(evt.key) && evt.key.toLowerCase() === \"escape\") {\n        setValue(initialValue);\n      }\n    },\n    [initialValue, safeHandleChange]\n  );\n  const onHandleBlur = (0, react_exports.useCallback)(\n    (evt) => {\n      safeHandleChange(evt.target.value);\n    },\n    [safeHandleChange]\n  );\n  const onHandleChange = (0, react_exports.useCallback)(\n    (evt) => {\n      const { value: evtVal } = evt.target;\n      if (typeof evtVal === \"undefined\") {\n        safeHandleChange(\"\");\n        return;\n      }\n      setValue(evtVal || \"\");\n    },\n    [safeHandleChange]\n  );\n  return {\n    onHandleBlur,\n    onHandleChange,\n    onHandleKeyDown,\n    value\n  };\n};\n\n// esm-externals:@splunk/react-icons/enterprise/TriangleRightSmall\nvar TriangleRightSmall_exports = {};\n__export(TriangleRightSmall_exports, {\n  default: () => TriangleRightSmall_default\n});\nvar defaultImport10 = __toESM(require(\"@splunk/react-icons/enterprise/TriangleRightSmall\"));\n__reExport(TriangleRightSmall_exports, require(\"@splunk/react-icons/enterprise/TriangleRightSmall\"));\nvar TriangleRightSmall_default = \"default\" in defaultImport10 ? defaultImport10.default : defaultImport10;\n\n// esm-externals:@splunk/react-icons/enterprise/TriangleDownSmall\nvar TriangleDownSmall_exports = {};\n__export(TriangleDownSmall_exports, {\n  default: () => TriangleDownSmall_default\n});\nvar defaultImport11 = __toESM(require(\"@splunk/react-icons/enterprise/TriangleDownSmall\"));\n__reExport(TriangleDownSmall_exports, require(\"@splunk/react-icons/enterprise/TriangleDownSmall\"));\nvar TriangleDownSmall_default = \"default\" in defaultImport11 ? defaultImport11.default : defaultImport11;\n\n// src/ConnectedDashboardHeader/CollapseHandle.tsx\nvar TriangleContainer = styled_components_default.button`\n    display: flex;\n    align-items: center;\n    height: ${LINE_HEIGHT};\n    box-sizing: inherit;\n    color: ${themes_exports.variables.contentColorDefault};\n    background: none;\n    cursor: pointer;\n    border: 0;\n    padding: 0;\n`;\nvar CollapseHandle = (0, react_exports.forwardRef)(({ isExpanded, mode, description, onClick }, ref) => {\n  if (mode !== \"view\" || !description) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(TriangleContainer, { ref, onClick }, isExpanded ? /* @__PURE__ */ react_default.createElement(\n    TriangleDownSmall_default,\n    {\n      \"data-test\": \"triangle-header-expanded\",\n      screenReaderText: (0, i18n_exports._)(\"Show less\")\n    }\n  ) : /* @__PURE__ */ react_default.createElement(\n    TriangleRightSmall_default,\n    {\n      \"data-test\": \"triangle-header-collapsed\",\n      screenReaderText: (0, i18n_exports._)(\"Show more\")\n    }\n  ));\n});\n\n// src/ConnectedDashboardHeader/ConnectedDashboardHeader.tsx\nvar HeaderContainer = styled_components_default.div`\n    padding: 8px 8px 0px 8px;\n    background-color: ${customThemeVariables.dashboardBackgroundColor};\n    box-sizing: border-box;\n`;\nvar TitleContainer = styled_components_default.div`\n    display: flex;\n    align-items: flex-start;\n    min-height: ${LINE_HEIGHT};\n    box-sizing: inherit;\n`;\nvar ConnectedDashboardHeader = () => {\n  const [isExpanded, setIsExpanded] = (0, react_exports.useState)(true);\n  const dispatch = (0, dashboard_state_exports.useDispatch)();\n  const mode = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectMode);\n  const title = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectTitle);\n  const description = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectDescription);\n  const { showTitleAndDescription = true } = (0, dashboard_state_exports.useSelector)(\n    dashboard_state_exports.selectLayoutGlobalOptions\n  );\n  const containerRef = (0, dashboard_context_exports.useHeaderRef)(\"container\");\n  const titleRef = (0, dashboard_context_exports.useHeaderRef)(\"title\");\n  const descRef = (0, dashboard_context_exports.useHeaderRef)(\"description\");\n  const handleRef = (0, dashboard_context_exports.useHeaderRef)(\"collapseHandle\");\n  const handleExpandToggle = (0, react_exports.useCallback)(() => {\n    setIsExpanded((isExpandedVal) => !isExpandedVal);\n  }, []);\n  const handleTitleCommit = (0, react_exports.useCallback)(\n    (val) => dispatch((0, dashboard_state_exports.updateTitle)(val)),\n    [dispatch]\n  );\n  const {\n    onHandleBlur: onHandleBlurTitle,\n    onHandleChange: onHandleChangeTitle,\n    onHandleKeyDown: onHandleKeyDownTitle,\n    value: valueTitle\n  } = useTextInput({\n    initialValue: title,\n    handleCommit: handleTitleCommit,\n    uniqKey: title != null ? title : \"\"\n  });\n  const handleDescCommit = (0, react_exports.useCallback)(\n    (val) => dispatch((0, dashboard_state_exports.updateDescription)(val)),\n    [dispatch]\n  );\n  const {\n    onHandleBlur: onHandleBlurDesc,\n    onHandleChange: onHandleChangeDesc,\n    onHandleKeyDown: onHandleKeyDownDesc,\n    value: valueDesc\n  } = useTextInput({\n    initialValue: description,\n    handleCommit: handleDescCommit,\n    uniqKey: description != null ? description : \"\"\n  });\n  if (!showTitleAndDescription || !valueTitle && !valueDesc && mode === \"view\") {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(HeaderContainer, { \"data-test\": \"dashboard-header\", ref: containerRef }, (mode !== \"view\" || !!valueTitle) && /* @__PURE__ */ react_default.createElement(TitleContainer, { \"data-test\": \"dashboard-header-title\" }, /* @__PURE__ */ react_default.createElement(\n    Title_default,\n    {\n      ref: titleRef,\n      handleBlur: onHandleBlurTitle,\n      handleChange: onHandleChangeTitle,\n      handleKeyDown: onHandleKeyDownTitle,\n      isExpanded,\n      mode,\n      value: valueTitle\n    }\n  ), /* @__PURE__ */ react_default.createElement(\n    CollapseHandle,\n    {\n      ref: handleRef,\n      isExpanded,\n      mode,\n      description: valueDesc,\n      onClick: handleExpandToggle\n    }\n  )), (mode !== \"view\" || !!valueDesc) && /* @__PURE__ */ react_default.createElement(\n    Description_default,\n    {\n      ref: descRef,\n      handleBlur: onHandleBlurDesc,\n      handleChange: onHandleChangeDesc,\n      handleKeyDown: onHandleKeyDownDesc,\n      showInViewMode: isExpanded,\n      mode,\n      value: valueDesc\n    }\n  ));\n};\n\n// esm-externals:@splunk/react-ui/ControlGroup\nvar ControlGroup_exports = {};\n__export(ControlGroup_exports, {\n  default: () => ControlGroup_default\n});\nvar defaultImport12 = __toESM(require(\"@splunk/react-ui/ControlGroup\"));\n__reExport(ControlGroup_exports, require(\"@splunk/react-ui/ControlGroup\"));\nvar ControlGroup_default = \"default\" in defaultImport12 ? defaultImport12.default : defaultImport12;\n\n// src/ControlGroup.tsx\nvar ControlGroup = styled_components_default(ControlGroup_default)`\n    margin-top: 0;\n    padding: 0;\n    margin-bottom: ${(0, themes_exports.pick)({\n  enterprise: themes_exports.variables.spacingMedium,\n  prisma: {\n    compact: themes_exports.variables.spacingMedium,\n    comfortable: themes_exports.variables.spacingLarge\n  }\n})};\n    width: 100%;\n\n    &:first-child {\n        margin-top: 0;\n    }\n\n    &:last-child {\n        margin-bottom: 0;\n    }\n\n    [data-test='label']:first-of-type {\n        padding-top: 0;\n    }\n    [data-test='tooltip'] {\n        margin-bottom: ${(0, themes_exports.pick)({\n  enterprise: {\n    compact: \"4px\",\n    comfortable: \"6px\"\n  },\n  prisma: \"0px\"\n})};\n    }\n`;\n\n// esm-externals:@splunk/visualization-context/DataSourceContext\nvar DataSourceContext_exports = {};\n__export(DataSourceContext_exports, {\n  default: () => DataSourceContext_default\n});\nvar defaultImport13 = __toESM(require(\"@splunk/visualization-context/DataSourceContext\"));\n__reExport(DataSourceContext_exports, require(\"@splunk/visualization-context/DataSourceContext\"));\nvar DataSourceContext_default = \"default\" in defaultImport13 ? defaultImport13.default : defaultImport13;\n\n// esm-externals:lodash\nvar lodash_exports = {};\n__export(lodash_exports, {\n  default: () => lodash_default\n});\nvar defaultImport14 = __toESM(require(\"lodash\"));\n__reExport(lodash_exports, require(\"lodash\"));\nvar lodash_default = \"default\" in defaultImport14 ? defaultImport14.default : defaultImport14;\n\n// src/hooks/usePrevious.ts\nvar usePrevious = (value) => {\n  const ref = (0, react_exports.useRef)(null);\n  (0, react_exports.useEffect)(() => {\n    ref.current = value;\n  });\n  return ref.current;\n};\nvar usePrevious_default = usePrevious;\n\n// src/hooks/useEventCallback.ts\nvar useEventCallback = (fn) => {\n  const ref = (0, react_exports.useRef)(() => {\n    throw new Error(\"Cannot call an event handler while rendering.\");\n  });\n  ref.current = fn;\n  return (0, react_exports.useCallback)((...args) => {\n    const f = ref.current;\n    return f(...args);\n  }, []);\n};\nvar useEventCallback_default = useEventCallback;\n\n// esm-externals:@splunk/dashboard-definition\nvar dashboard_definition_exports = {};\n__export(dashboard_definition_exports, {\n  default: () => dashboard_definition_default\n});\nvar defaultImport15 = __toESM(require(\"@splunk/dashboard-definition\"));\n__reExport(dashboard_definition_exports, require(\"@splunk/dashboard-definition\"));\nvar dashboard_definition_default = \"default\" in defaultImport15 ? defaultImport15.default : defaultImport15;\n\n// esm-externals:@splunk/datasource-utils\nvar datasource_utils_exports = {};\n__export(datasource_utils_exports, {\n  default: () => datasource_utils_default\n});\nvar defaultImport16 = __toESM(require(\"@splunk/datasource-utils\"));\n__reExport(datasource_utils_exports, require(\"@splunk/datasource-utils\"));\nvar datasource_utils_default = \"default\" in defaultImport16 ? defaultImport16.default : defaultImport16;\n\n// src/hooks/useHandleItemTypeChange.ts\nvar useHandleItemTypeChange = ({\n  consumerId,\n  bindings,\n  updateRequestParams,\n  clearResults\n}) => {\n  const preset = (0, dashboard_context_exports.usePreset)();\n  const definition = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectDefinition);\n  const definitionClass = (0, react_exports.useMemo)(\n    () => dashboard_definition_exports.DashboardDefinition.fromJSON(definition),\n    [definition]\n  );\n  const itemType = definitionClass.getItemPresetType(consumerId);\n  const prevItemType = usePrevious_default(itemType);\n  (0, react_exports.useEffect)(() => {\n    if (prevItemType && itemType !== prevItemType) {\n      Object.keys(bindings).forEach((bindingType) => {\n        clearResults(bindingType);\n        const itemLayoutType = definitionClass.getItemType(consumerId);\n        const newRequestParams = (0, datasource_utils_exports.findInitialRequestParams)({\n          bindingType,\n          consumerModule: preset.findItem(\n            itemType,\n            itemLayoutType\n          )\n        });\n        updateRequestParams(bindingType, newRequestParams);\n      });\n    }\n  }, [\n    bindings,\n    clearResults,\n    consumerId,\n    definitionClass,\n    itemType,\n    preset,\n    prevItemType,\n    updateRequestParams\n  ]);\n};\n\n// src/hooks/useSubscribeToSearches.tsx\nvar EMPTY_STATE = {};\nvar getUnneededConsumers = ({\n  previousBindings,\n  newBindings,\n  isNewConsumerId\n}) => {\n  const previousBindingTypes = Object.keys(previousBindings);\n  if (isNewConsumerId) {\n    return previousBindingTypes;\n  }\n  const unneededConsumers = [];\n  previousBindingTypes.forEach((prevBindingType) => {\n    const prevDsId = previousBindings[prevBindingType];\n    const newDsId = newBindings[prevBindingType];\n    if (typeof newDsId === \"undefined\" || prevDsId !== newDsId) {\n      unneededConsumers.push(prevBindingType);\n    }\n  });\n  return unneededConsumers;\n};\nvar reducer = (state, action) => {\n  switch (action.type) {\n    case \"binding/remove\": {\n      const { bindingType } = action;\n      return (0, lodash_exports.omit)(state, [bindingType]);\n    }\n    case \"binding/reset\": {\n      const { bindingType } = action;\n      return __spreadProps(__spreadValues({}, state), {\n        [bindingType]: {\n          error: void 0,\n          data: void 0,\n          meta: void 0,\n          requestParams: void 0\n        }\n      });\n    }\n    case \"binding/update\": {\n      const { bindingType, payload } = action;\n      return __spreadProps(__spreadValues({}, state), {\n        [bindingType]: payload\n      });\n    }\n    default:\n      return state != null ? state : EMPTY_STATE;\n  }\n};\nvar useSubscribeToSearches = ({\n  consumerId,\n  bindings,\n  subscribeFn\n}) => {\n  const [results, dispatch] = (0, react_exports.useReducer)(reducer, {});\n  const prevProps = usePrevious_default({ consumerId, bindings });\n  const searchApi = (0, dashboard_context_exports.useSearchContext)();\n  const subscribe = subscribeFn != null ? subscribeFn : searchApi.subscribe;\n  const unsubscribeCallbacksRef = (0, react_exports.useRef)(\n    {}\n  );\n  (0, react_exports.useEffect)(() => {\n    var _a;\n    const isNewConsumerId = (prevProps == null ? void 0 : prevProps.consumerId) !== consumerId;\n    const unneededConsumers = getUnneededConsumers({\n      previousBindings: (_a = prevProps == null ? void 0 : prevProps.bindings) != null ? _a : {},\n      newBindings: bindings,\n      isNewConsumerId\n    });\n    unneededConsumers.forEach((bindingType) => {\n      var _a2, _b;\n      (_b = (_a2 = unsubscribeCallbacksRef.current)[bindingType]) == null ? void 0 : _b.call(_a2);\n      delete unsubscribeCallbacksRef.current[bindingType];\n      dispatch({ type: \"binding/remove\", bindingType });\n    });\n    Object.entries(bindings).forEach(([bindingType, dsId]) => {\n      if (typeof unsubscribeCallbacksRef.current[bindingType] !== \"undefined\") {\n        return;\n      }\n      dispatch({\n        type: \"binding/reset\",\n        bindingType\n      });\n      const unsubscribe = subscribe({\n        dsId,\n        consumerId,\n        bindingType,\n        subscriberId: consumerId,\n        onUpdate: (payload) => {\n          dispatch({\n            type: \"binding/update\",\n            bindingType,\n            payload\n          });\n        }\n      });\n      unsubscribeCallbacksRef.current[bindingType] = unsubscribe;\n    });\n  }, [\n    bindings,\n    consumerId,\n    prevProps == null ? void 0 : prevProps.bindings,\n    prevProps == null ? void 0 : prevProps.consumerId,\n    subscribe\n  ]);\n  (0, react_exports.useEffect)(() => {\n    return () => {\n      Object.values(unsubscribeCallbacksRef.current).forEach(\n        (unsubscribe) => unsubscribe == null ? void 0 : unsubscribe()\n      );\n    };\n  }, []);\n  const updateRequestParams = (0, react_exports.useCallback)(\n    (bindingType, newRequestParams) => {\n      searchApi.updateRequestParams({\n        consumerId,\n        dsId: bindings[bindingType],\n        bindingType,\n        requestParams: newRequestParams\n      });\n    },\n    [bindings, consumerId, searchApi]\n  );\n  const refresh = (0, react_exports.useCallback)(\n    (options) => {\n      Object.entries(bindings).forEach(([bindingType, dsId]) => {\n        dispatch({\n          type: \"binding/reset\",\n          bindingType\n        });\n        searchApi.refresh({ consumerId, bindingType, dsId, options });\n      });\n      return Promise.resolve();\n    },\n    [bindings, consumerId, searchApi]\n  );\n  const handleClearResults = (0, react_exports.useCallback)(\n    (bindingType) => dispatch({\n      type: \"binding/reset\",\n      bindingType\n    }),\n    []\n  );\n  const control = (0, react_exports.useCallback)(\n    (action) => __async(void 0, null, function* () {\n      return Object.entries(bindings).reduce(\n        (_0, _1) => __async(void 0, [_0, _1], function* (previousControlAction, [bindingType, dsId]) {\n          yield previousControlAction;\n          return searchApi.control({\n            consumerId,\n            bindingType,\n            dsId,\n            action\n          });\n        }),\n        Promise.resolve()\n      );\n    }),\n    [bindings, consumerId, searchApi]\n  );\n  useHandleItemTypeChange({\n    consumerId,\n    bindings,\n    updateRequestParams,\n    clearResults: handleClearResults\n  });\n  const loading = (0, react_exports.useMemo)(() => {\n    var _a, _b;\n    if (Object.keys(bindings).length) {\n      return results.primary ? !((_a = results.primary) == null ? void 0 : _a.error) && !((_b = results.primary) == null ? void 0 : _b.data) : true;\n    }\n    return false;\n  }, [results.primary, bindings]);\n  return {\n    loading,\n    dataSources: results,\n    // by using useEventCallback, we avoid triggering multiple re-renders when these callbacks change\n    updateRequestParams: useEventCallback_default(updateRequestParams),\n    refresh: useEventCallback_default(refresh),\n    control: useEventCallback_default(control)\n  };\n};\n\n// esm-externals:@splunk/dashboard-icons\nvar dashboard_icons_exports = {};\n__export(dashboard_icons_exports, {\n  default: () => dashboard_icons_default\n});\nvar defaultImport17 = __toESM(require(\"@splunk/dashboard-icons\"));\n__reExport(dashboard_icons_exports, require(\"@splunk/dashboard-icons\"));\nvar dashboard_icons_default = \"default\" in defaultImport17 ? defaultImport17.default : defaultImport17;\n\n// esm-externals:react-dom\nvar react_dom_exports = {};\n__export(react_dom_exports, {\n  default: () => react_dom_default\n});\nvar defaultImport18 = __toESM(require(\"react-dom\"));\n__reExport(react_dom_exports, require(\"react-dom\"));\nvar react_dom_default = \"default\" in defaultImport18 ? defaultImport18.default : defaultImport18;\n\n// src/hooks/useDragHandleComponent.tsx\nvar DRAG_HANDLE_WIDTH_ON_INPUT = \"65px\";\nvar DRAG_HANDLE_HEIGHT_ON_INPUT = \"24px\";\nvar DRAG_HANDLE_MARGIN_ON_INPUT = \"0 auto\";\nvar DRAG_HANDLE_WIDTH_ON_VIZ = \"88px\";\nvar DRAG_HANDLE_HEIGHT_ON_VIZ = \"36px\";\nvar DRAG_HANDLE_MARGIN_ON_VIZ = \"9px auto 0\";\nvar DragHandleContainer = styled_components_default.div.attrs({\n  \"data-test\": \"visualization-drag-handle\"\n})`\n    display: none;\n    position: absolute;\n    left: 0;\n    right: 0;\n    margin: ${(0, themes_exports.pickVariant)(\"type\", {\n  input: DRAG_HANDLE_MARGIN_ON_INPUT,\n  block: DRAG_HANDLE_MARGIN_ON_VIZ\n})};\n    min-width: 36px;\n    min-height: 20px;\n    max-width: ${(0, themes_exports.pickVariant)(\"type\", {\n  input: DRAG_HANDLE_WIDTH_ON_INPUT,\n  block: DRAG_HANDLE_WIDTH_ON_VIZ\n})};\n    max-height: ${(0, themes_exports.pickVariant)(\"type\", {\n  input: DRAG_HANDLE_HEIGHT_ON_INPUT,\n  block: DRAG_HANDLE_HEIGHT_ON_VIZ\n})};\n    z-index: 2;\n    cursor: move;\n    background-color: ${(0, themes_exports.pick)({\n  enterprise: {\n    dark: themes_exports.variables.gray22,\n    light: themes_exports.variables.white\n  },\n  prisma: themes_exports.variables.backgroundColorPopup\n})};\n    border-radius: 4px;\n    box-shadow: 0px 10px 103px rgba(0, 0, 0, 0.64),\n        0px 5px 18px rgba(0, 0, 0, 0.15), 0px 3px 6px rgba(0, 0, 0, 0.3);\n    // show drag handle when hovering over the item it is attached to\n    ${AbsoluteItemContainer}:hover &,\n    // and always show when the parent item is selected\n    ${AbsoluteItemContainer}[data-selected='true'] & {\n        display: block;\n    }\n`;\nvar EVENT_MOUSE_DOWN_ON_HANDLE = \"mousedownVizHandle\";\nvar EVENT_MOUSE_DOWN_ON_VIZ_WITH_HANDLE = \"mousedownVizWithHandle\";\nvar useDragHandleComponent = ({\n  id,\n  shouldShowDragHandle,\n  type,\n  portalRef\n}) => {\n  const handleMouseDown = (0, react_exports.useCallback)(\n    (event) => {\n      const passedDetail = {\n        initialEvent: event,\n        vizId: id,\n        type\n      };\n      document.dispatchEvent(\n        new CustomEvent(EVENT_MOUSE_DOWN_ON_HANDLE, {\n          detail: passedDetail\n        })\n      );\n      event.stopPropagation();\n    },\n    [id, type]\n  );\n  const Handle = (0, react_exports.useMemo)(\n    () => shouldShowDragHandle ? /* @__PURE__ */ react_default.createElement(\n      DragHandleContainer,\n      {\n        type,\n        onMouseDownCapture: handleMouseDown,\n        itemId: id\n      },\n      /* @__PURE__ */ react_default.createElement(dashboard_icons_exports.DragHandle, null)\n    ) : null,\n    [handleMouseDown, type, shouldShowDragHandle, id]\n  );\n  return (0, react_exports.useMemo)(\n    () => (portalRef == null ? void 0 : portalRef.current) ? (0, react_dom_exports.createPortal)(Handle, portalRef == null ? void 0 : portalRef.current) : null,\n    [portalRef, Handle]\n  );\n};\n\n// esm-externals:@splunk/dashboard-utils\nvar dashboard_utils_exports = {};\n__export(dashboard_utils_exports, {\n  default: () => dashboard_utils_default\n});\nvar defaultImport19 = __toESM(require(\"@splunk/dashboard-utils\"));\n__reExport(dashboard_utils_exports, require(\"@splunk/dashboard-utils\"));\nvar dashboard_utils_default = \"default\" in defaultImport19 ? defaultImport19.default : defaultImport19;\n\n// esm-externals:lodash/noop\nvar noop_exports = {};\n__export(noop_exports, {\n  default: () => noop_default\n});\nvar defaultImport20 = __toESM(require(\"lodash/noop\"));\n__reExport(noop_exports, require(\"lodash/noop\"));\nvar noop_default = \"default\" in defaultImport20 ? defaultImport20.default : defaultImport20;\n\n// src/hooks/usePassiveEventsCheck.ts\nvar usePassiveEventsCheck = () => {\n  const passiveEventsSupported = (0, react_exports.useRef)(false);\n  (0, react_exports.useEffect)(() => {\n    try {\n      const options = {\n        get passive() {\n          passiveEventsSupported.current = true;\n          return false;\n        }\n      };\n      window.addEventListener(\"test\", noop_default, options);\n      window.removeEventListener(\"test\", noop_default);\n    } catch (error) {\n    }\n  }, []);\n  return (0, react_exports.useCallback)(() => passiveEventsSupported.current, []);\n};\n\n// src/hooks/useEventListener.ts\nvar isFunctionFactory = (func) => {\n  if (typeof func !== \"function\") {\n    return false;\n  }\n  try {\n    if (typeof func() === \"function\") {\n      return true;\n    }\n  } catch (_error) {\n  }\n  return false;\n};\nvar isRefObject = (target) => {\n  const castTarget = target;\n  const objKeys = Object.keys(castTarget != null ? castTarget : {});\n  return objKeys.length === 1 && objKeys[0] === \"current\";\n};\nvar eventListenerObjectToFunc = (listenerOrObject) => typeof listenerOrObject !== \"function\" ? listenerOrObject == null ? void 0 : listenerOrObject.handleEvent : listenerOrObject;\nvar useEventListener = ({\n  eventName,\n  listener,\n  target: targetProp,\n  options: optionsProp\n}) => {\n  var _a;\n  const passiveEventsSupported = usePassiveEventsCheck();\n  const memoizedOptions = (0, react_exports.useMemo)(\n    () => JSON.stringify(optionsProp),\n    [optionsProp]\n  );\n  const memoizedListener = (0, react_exports.useMemo)(\n    () => eventListenerObjectToFunc(\n      isFunctionFactory(listener) ? listener() : listener\n    ),\n    [listener]\n  );\n  const eventHandlerRef = (0, react_exports.useRef)();\n  const eventHandler = (0, react_exports.useCallback)((...args) => {\n    var _a2;\n    (_a2 = eventHandlerRef.current) == null ? void 0 : _a2.call(eventHandlerRef, ...args);\n  }, []);\n  const target = isRefObject(targetProp) ? (_a = targetProp.current) != null ? _a : void 0 : targetProp != null ? targetProp : void 0;\n  eventHandlerRef.current = memoizedListener;\n  (0, react_exports.useLayoutEffect)(() => {\n    var _a2;\n    const eventTarget = target;\n    const options = (_a2 = JSON.parse(memoizedOptions || \"null\")) != null ? _a2 : void 0;\n    if (eventTarget) {\n      if (typeof eventTarget.addEventListener !== \"function\") {\n        throw Error(\n          \"Provided target does not support adding event listeners\"\n        );\n      }\n      if (typeof options === \"undefined\") {\n        eventTarget.addEventListener(eventName, eventHandler);\n      } else if (typeof options === \"boolean\") {\n        eventTarget.addEventListener(eventName, eventHandler, options);\n      } else if (!passiveEventsSupported()) {\n        dashboard_utils_exports.console.warn(\n          \"Attempted to create event listener with unsupported options\"\n        );\n        eventTarget.addEventListener(eventName, eventHandler);\n      } else {\n        eventTarget.addEventListener(eventName, eventHandler, options);\n      }\n    }\n    return () => {\n      if (eventTarget) {\n        eventTarget.removeEventListener(eventName, eventHandler);\n      }\n    };\n  }, [\n    eventName,\n    target,\n    memoizedOptions,\n    eventHandler,\n    passiveEventsSupported\n  ]);\n};\n\n// src/hooks/useMouseMoveHandler.ts\nvar useMouseMoveHandler = ({\n  onMouseMove,\n  isEnabled = true,\n  throttledMs\n}) => {\n  (0, react_exports.useEffect)(() => {\n    if (!isEnabled) {\n      return void 0;\n    }\n    let throttledCallback;\n    if (throttledMs) {\n      throttledCallback = (0, lodash_exports.throttle)(onMouseMove, throttledMs, {\n        trailing: false\n      });\n      document.addEventListener(\"mousemove\", throttledCallback);\n    } else {\n      document.addEventListener(\"mousemove\", onMouseMove);\n    }\n    return () => {\n      if (throttledCallback) {\n        throttledCallback.cancel();\n        document.removeEventListener(\"mousemove\", throttledCallback);\n      } else {\n        document.removeEventListener(\"mousemove\", onMouseMove);\n      }\n    };\n  }, [isEnabled, onMouseMove, throttledMs]);\n};\nvar useMouseMoveHandler_default = useMouseMoveHandler;\n\n// src/hooks/usePopoverState.ts\nvar usePopoverState = ({\n  initialOpen = false,\n  preventDefault = false,\n  stopPropagation = false,\n  anchor\n} = {}) => {\n  const [open, setOpen] = (0, react_exports.useState)(initialOpen);\n  const onRequestOpen = (0, react_exports.useCallback)(\n    (event) => {\n      if (preventDefault) {\n        event == null ? void 0 : event.preventDefault();\n      }\n      if (stopPropagation) {\n        event == null ? void 0 : event.stopPropagation();\n      }\n      setOpen(true);\n    },\n    [preventDefault, stopPropagation]\n  );\n  const onRequestClose = (0, react_exports.useCallback)(() => {\n    setOpen(false);\n    if (anchor == null ? void 0 : anchor.current) {\n      anchor.current.focus();\n    }\n  }, [anchor]);\n  return (0, react_exports.useMemo)(\n    () => ({ open, onRequestOpen, onRequestClose }),\n    [open, onRequestOpen, onRequestClose]\n  );\n};\n\n// src/hooks/usePopoverBlurCallback.ts\nvar usePopoverBlurCallback = (onBlur) => {\n  return (0, react_exports.useCallback)(\n    (e) => {\n      var _a;\n      if (((_a = e.relatedTarget) == null ? void 0 : _a.getAttribute(\"role\")) === \"menuitem\") {\n        return;\n      }\n      onBlur(e);\n    },\n    [onBlur]\n  );\n};\nvar usePopoverBlurCallback_default = usePopoverBlurCallback;\n\n// esm-externals:prop-types\nvar prop_types_exports = {};\n__export(prop_types_exports, {\n  default: () => prop_types_default\n});\nvar defaultImport21 = __toESM(require(\"prop-types\"));\n__reExport(prop_types_exports, require(\"prop-types\"));\nvar prop_types_default = \"default\" in defaultImport21 ? defaultImport21.default : defaultImport21;\n\n// esm-externals:@splunk/react-ui/Button\nvar Button_exports = {};\n__export(Button_exports, {\n  default: () => Button_default\n});\nvar defaultImport22 = __toESM(require(\"@splunk/react-ui/Button\"));\n__reExport(Button_exports, require(\"@splunk/react-ui/Button\"));\nvar Button_default = \"default\" in defaultImport22 ? defaultImport22.default : defaultImport22;\n\n// esm-externals:@splunk/react-ui/Link\nvar Link_exports = {};\n__export(Link_exports, {\n  default: () => Link_default\n});\nvar defaultImport23 = __toESM(require(\"@splunk/react-ui/Link\"));\n__reExport(Link_exports, require(\"@splunk/react-ui/Link\"));\nvar Link_default = \"default\" in defaultImport23 ? defaultImport23.default : defaultImport23;\n\n// esm-externals:@splunk/react-ui/Scroll\nvar Scroll_exports = {};\n__export(Scroll_exports, {\n  default: () => Scroll_default\n});\nvar defaultImport24 = __toESM(require(\"@splunk/react-ui/Scroll\"));\n__reExport(Scroll_exports, require(\"@splunk/react-ui/Scroll\"));\nvar Scroll_default = \"default\" in defaultImport24 ? defaultImport24.default : defaultImport24;\n\n// esm-externals:@splunk/react-icons/enterprise/Close\nvar Close_exports = {};\n__export(Close_exports, {\n  default: () => Close_default\n});\nvar defaultImport25 = __toESM(require(\"@splunk/react-icons/enterprise/Close\"));\n__reExport(Close_exports, require(\"@splunk/react-icons/enterprise/Close\"));\nvar Close_default = \"default\" in defaultImport25 ? defaultImport25.default : defaultImport25;\n\n// esm-externals:@splunk/react-search/components/Input\nvar Input_exports = {};\n__export(Input_exports, {\n  default: () => Input_default\n});\nvar defaultImport26 = __toESM(require(\"@splunk/react-search/components/Input\"));\n__reExport(Input_exports, require(\"@splunk/react-search/components/Input\"));\nvar Input_default = \"default\" in defaultImport26 ? defaultImport26.default : defaultImport26;\n\n// esm-externals:@splunk/splunk-utils/url\nvar url_exports = {};\n__export(url_exports, {\n  default: () => url_default\n});\nvar defaultImport27 = __toESM(require(\"@splunk/splunk-utils/url\"));\n__reExport(url_exports, require(\"@splunk/splunk-utils/url\"));\nvar url_default = \"default\" in defaultImport27 ? defaultImport27.default : defaultImport27;\n\n// esm-externals:@splunk/dashboard-telemetry\nvar dashboard_telemetry_exports = {};\n__export(dashboard_telemetry_exports, {\n  default: () => dashboard_telemetry_default\n});\nvar defaultImport28 = __toESM(require(\"@splunk/dashboard-telemetry\"));\n__reExport(dashboard_telemetry_exports, require(\"@splunk/dashboard-telemetry\"));\nvar dashboard_telemetry_default = \"default\" in defaultImport28 ? defaultImport28.default : defaultImport28;\n\n// src/RiskyWarningPopoverContent.tsx\nvar RISKY_WARNING_MESSAGE = (0, i18n_exports._)(\n  \"Some visualizations and/or inputs have not loaded since we detected potential security risks. To learn more, click on the icon in the top-right corner of the visualization and/or in the input.\"\n);\nvar RISKY_WARNING_POPOVER_DESCRIPTION = (0, i18n_exports._)(\n  \"The search that you are about to run contains commands that might present a security risk.\"\n);\nvar emitRiskyWarningMessage = (0, lodash_exports.once)(\n  ({\n    userMessage\n  }) => {\n    if (typeof userMessage !== \"function\") {\n      return;\n    }\n    userMessage({\n      message: RISKY_WARNING_MESSAGE,\n      level: \"warning\",\n      sender: \"RiskyWarningPopover\"\n    });\n  }\n);\nvar WarningContainer = styled_components_default.div`\n    width: 400px;\n    max-height: 375px;\n    padding: 24px;\n    color: ${themes_exports.variables.contentColorDefault};\n    font-size: 14px;\n    background-color: ${themes_exports.variables.backgroundColorPopup};\n`;\nvar BodyContainer = styled_components_default(Scroll_default)`\n    width: 100%;\n    max-height: 280px;\n    margin-bottom: 12px;\n`;\nvar HeaderContainer2 = styled_components_default.div`\n    display: flex;\n    justify-content: space-between;\n`;\nvar TitleContainer2 = styled_components_default.div`\n    height: 28px;\n    font-size: 17px;\n    font-weight: 500;\n`;\nvar CloseButton = styled_components_default(Button_default)`\n    width: 32px;\n    height: 32px;\n    flex-grow: 0;\n    margin-top: -8px;\n`;\nvar FooterContainer = styled_components_default.div`\n    text-align: right;\n    margin-top: 16px;\n`;\nvar RiskyCommandsList = styled_components_default.div`\n    font-weight: 500;\n    color: ${(0, themes_exports.pick)({\n  light: themes_exports.variables.focusColor,\n  dark: themes_exports.variables.linkColor\n})};\n    text-indent: 24px;\n    word-break: break-word;\n`;\nvar RiskyCommands = ({ message = \"\" }) => /* @__PURE__ */ react_default.createElement(RiskyCommandsList, { \"data-test\": \"risky-command-list\" }, (0, dashboard_utils_exports.getRiskyCommands)(message).join(\", \"));\nvar getRiskyCommandDocsUrl = () => {\n  const instanceType = (0, lodash_exports.get)(window, [\n    \"__splunkd_partials__\",\n    `/services/server/info`,\n    \"entry\",\n    0,\n    \"content\",\n    \"instance_type\"\n  ]);\n  return instanceType === \"cloud\" ? (0, url_exports.createDocsURL)(\"sds.cloud-risky\") : (0, url_exports.createDocsURL)(\"sds.ent-risky\");\n};\nvar DescriptionText = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"risky-description-text\"\n}))`\n    padding-top: 16px;\n    padding-bottom: 8px;\n`;\nvar Description2 = () => /* @__PURE__ */ react_default.createElement(DescriptionText, null, RISKY_WARNING_POPOVER_DESCRIPTION, \" \", /* @__PURE__ */ react_default.createElement(Link_default, { to: getRiskyCommandDocsUrl(), openInNewContext: true }, (0, i18n_exports._)(\"Learn more\")));\nvar WarningText = styled_components_default.div`\n    font-weight: 500;\n    margin-top: 8px;\n    margin-bottom: 16px;\n`;\nvar Warning = () => /* @__PURE__ */ react_default.createElement(WarningText, null, (0, i18n_exports._)(\n  \"If the commands seem unusual, do not run the query without further investigation or contact your Splunk administrator.\"\n));\nvar InputContainer = styled_components_default.div`\n    .disabled .ace_content {\n        opacity: 1;\n    }\n`;\nvar SearchView = ({ search }) => /* @__PURE__ */ react_default.createElement(InputContainer, null, /* @__PURE__ */ react_default.createElement(\n  Input_default,\n  {\n    syntax: dashboard_utils_exports.defaultSPLSyntax,\n    showLineNumbers: false,\n    maxLines: 4,\n    value: search,\n    enabled: false\n  }\n));\nvar RiskyWarningPopoverContent = ({\n  dataSource,\n  componentId,\n  onRequestClose,\n  type = \"visualization\"\n}) => {\n  var _a, _b, _c;\n  const message = (_a = dataSource == null ? void 0 : dataSource.error) == null ? void 0 : _a.message;\n  const riskySearch = ((_b = dataSource == null ? void 0 : dataSource.meta) == null ? void 0 : _b.completeSearchQuery) || ((_c = dataSource == null ? void 0 : dataSource.meta) == null ? void 0 : _c.search);\n  const dashboardApi = (0, dashboard_context_exports.useDashboardCoreApi)();\n  const telemetry = (0, dashboard_telemetry_exports.useTelemetryApi)();\n  const handleClick2 = (0, react_exports.useCallback)(() => {\n    if (dashboardApi) {\n      telemetry.emit({\n        pageAction: \"riskyWarningDialog.runSearch\",\n        source: \"riskyWarningDialog\",\n        metadata: { type }\n      });\n      if (type === \"input\") {\n        dashboardApi.refreshInput(componentId, {\n          checkRiskyCommand: false\n        });\n      } else {\n        dashboardApi.refreshVisualization(componentId, {\n          checkRiskyCommand: false\n        });\n      }\n      onRequestClose();\n    }\n  }, [dashboardApi, componentId, type, telemetry, onRequestClose]);\n  const handleRequestClose = (0, react_exports.useCallback)(() => {\n    telemetry.emit({\n      pageAction: \"riskyWarningDialog.cancel\",\n      source: \"riskyWarningDialog\",\n      metadata: { type }\n    });\n    onRequestClose();\n  }, [telemetry, type, onRequestClose]);\n  (0, react_exports.useEffect)(() => {\n    telemetry.emit({\n      pageAction: \"riskyWarningDialog.open\",\n      source: \"riskyWarningDialog\",\n      metadata: { type }\n    });\n  }, [telemetry, type]);\n  const Header = (0, react_exports.useMemo)(\n    () => /* @__PURE__ */ react_default.createElement(HeaderContainer2, null, /* @__PURE__ */ react_default.createElement(TitleContainer2, null, type === \"input\" ? (0, i18n_exports._)(\"This input has a potential security risk\") : (0, i18n_exports._)(\"This visualization has a potential security risk\")), /* @__PURE__ */ react_default.createElement(\n      CloseButton,\n      {\n        appearance: \"pill\",\n        prepend: true,\n        icon: /* @__PURE__ */ react_default.createElement(Close_default, null),\n        onClick: handleRequestClose,\n        \"data-test\": \"risky-warning-close-button\"\n      }\n    )),\n    [type, handleRequestClose]\n  );\n  const Body = (0, react_exports.useMemo)(\n    () => /* @__PURE__ */ react_default.createElement(BodyContainer, { stopScrollPropagation: true }, /* @__PURE__ */ react_default.createElement(Description2, null), /* @__PURE__ */ react_default.createElement(RiskyCommands, { message }), /* @__PURE__ */ react_default.createElement(Warning, null), /* @__PURE__ */ react_default.createElement(SearchView, { search: riskySearch })),\n    [message, riskySearch]\n  );\n  const Footer = (0, react_exports.useMemo)(\n    () => /* @__PURE__ */ react_default.createElement(FooterContainer, null, /* @__PURE__ */ react_default.createElement(\n      Button_default,\n      {\n        label: (0, i18n_exports._)(\"Run Query\"),\n        appearance: \"primary\",\n        onClick: handleClick2,\n        \"data-test\": \"risky-warning-run-button\"\n      }\n    ), /* @__PURE__ */ react_default.createElement(\n      Button_default,\n      {\n        label: (0, i18n_exports._)(\"Cancel\"),\n        appearance: \"secondary\",\n        onClick: handleRequestClose,\n        \"data-test\": \"risky-warning-cancel-button\"\n      }\n    )),\n    [handleClick2, handleRequestClose]\n  );\n  return /* @__PURE__ */ react_default.createElement(WarningContainer, null, Header, Body, (0, i18n_exports._)(\"Do you want to run the search string?\"), Footer);\n};\nRiskyWarningPopoverContent.propTypes = {\n  dataSource: prop_types_default.object,\n  onRequestClose: prop_types_default.func,\n  componentId: prop_types_default.string.isRequired,\n  type: prop_types_default.oneOf([\"visualization\", \"input\"])\n};\nvar RiskyWarningPopoverContent_default = react_default.memo(RiskyWarningPopoverContent);\n\n// src/hooks/useRiskySearchToast.ts\nvar useRiskySearchToast = ({\n  dataSource\n} = {}) => {\n  var _a;\n  const userMessageApi = (0, dashboard_context_exports.useUserMessageAPI)();\n  const hasRiskyCommand = (0, react_exports.useMemo)(() => {\n    var _a2;\n    const errorMessage = (_a2 = dataSource == null ? void 0 : dataSource.error) == null ? void 0 : _a2.message;\n    return errorMessage ? (0, dashboard_utils_exports.isRiskyCommandError)(errorMessage) : false;\n  }, [(_a = dataSource == null ? void 0 : dataSource.error) == null ? void 0 : _a.message]);\n  (0, react_exports.useEffect)(() => {\n    if (userMessageApi && hasRiskyCommand) {\n      emitRiskyWarningMessage({ userMessage: userMessageApi });\n    }\n  }, [hasRiskyCommand, userMessageApi]);\n};\n\n// src/hooks/useBatchSubscribeToSearches.ts\nvar initialState = {};\nvar initialBindings = {};\nvar throttleTimeout = 500;\nvar useBatchSubscribeToSearches = ({\n  consumerId\n}) => {\n  const definition = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectDefinition);\n  const structure = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectLayoutStructure);\n  const prevBindings = (0, react_exports.useRef)(initialBindings);\n  const searchApi = (0, dashboard_context_exports.useSearchContext)();\n  const [results, setResults] = (0, react_exports.useState)(initialState);\n  const setThrottledResults = (0, react_exports.useMemo)(\n    () => (0, lodash_exports.debounce)(setResults, throttleTimeout, { maxWait: throttleTimeout }),\n    []\n  );\n  (0, react_exports.useEffect)(\n    () => () => {\n      setThrottledResults.cancel();\n    },\n    [setThrottledResults]\n  );\n  const dsBindings = (0, react_exports.useMemo)(() => {\n    const bindings = {};\n    const { inputs, visualizations } = definition;\n    if (!Array.isArray(structure)) {\n      return prevBindings.current;\n    }\n    structure.forEach(({ item, type }) => {\n      var _a, _b, _c, _d;\n      const primaryDS = type === \"input\" ? (_b = (_a = inputs == null ? void 0 : inputs[item]) == null ? void 0 : _a.dataSources) == null ? void 0 : _b.primary : (_d = (_c = visualizations == null ? void 0 : visualizations[item]) == null ? void 0 : _c.dataSources) == null ? void 0 : _d.primary;\n      if (primaryDS) {\n        bindings[item] = primaryDS;\n      }\n    });\n    if (!(0, lodash_exports.isEqual)(bindings, prevBindings.current)) {\n      prevBindings.current = bindings;\n    }\n    return prevBindings.current;\n  }, [definition, structure]);\n  const subscribeFn = (0, react_exports.useCallback)(\n    ({ dsId, consumerId: subscriberId, bindingType, onUpdate }) => searchApi.subscribe({\n      dsId,\n      consumerId: bindingType,\n      bindingType: \"primary\",\n      subscriberId,\n      onUpdate\n    }),\n    [searchApi]\n  );\n  const { dataSources } = useSubscribeToSearches({\n    consumerId,\n    bindings: dsBindings,\n    subscribeFn\n  });\n  setThrottledResults(dataSources);\n  return results;\n};\n\n// esm-externals:@splunk/splunk-utils/config\nvar config_exports = {};\n__export(config_exports, {\n  default: () => config_default\n});\nvar defaultImport29 = __toESM(require(\"@splunk/splunk-utils/config\"));\n__reExport(config_exports, require(\"@splunk/splunk-utils/config\"));\nvar config_default = \"default\" in defaultImport29 ? defaultImport29.default : defaultImport29;\n\n// esm-externals:@splunk/react-search/utils/searchBNFs\nvar searchBNFs_exports = {};\n__export(searchBNFs_exports, {\n  default: () => searchBNFs_default\n});\nvar defaultImport30 = __toESM(require(\"@splunk/react-search/utils/searchBNFs\"));\n__reExport(searchBNFs_exports, require(\"@splunk/react-search/utils/searchBNFs\"));\nvar searchBNFs_default = \"default\" in defaultImport30 ? defaultImport30.default : defaultImport30;\n\n// src/hooks/useSearchBNF.ts\nvar memoizedFetchBNF = (0, lodash_exports.memoize)(\n  (parseSyntax) => __async(void 0, null, function* () {\n    if (config_exports.isAvailable) {\n      return searchBNFs_default(parseSyntax);\n    }\n    return Promise.resolve(void 0);\n  })\n);\nvar useSearchBNF = ({\n  parseSyntax = true\n} = {}) => {\n  const [searchBNF2, setSearchBNF] = (0, react_exports.useState)(dashboard_utils_exports.defaultSPLSyntax);\n  (0, react_exports.useEffect)(() => {\n    const abortController = new AbortController();\n    (() => __async(void 0, null, function* () {\n      try {\n        const syntax = yield memoizedFetchBNF(parseSyntax);\n        if (syntax && !abortController.signal.aborted) {\n          setSearchBNF(syntax);\n        }\n      } catch (e) {\n      }\n    }))();\n    return () => {\n      abortController.abort();\n    };\n  }, [parseSyntax]);\n  return searchBNF2;\n};\n\n// src/DataSourceContext.tsx\nvar DEFAULT_REQUEST_PARAMS = { count: 100, offset: 0 };\nvar createSubscribe = (subscribers, results) => (bindingType, callback) => {\n  var _a;\n  if (!subscribers.current[bindingType]) {\n    subscribers.current[bindingType] = [];\n  }\n  subscribers.current[bindingType].push(callback);\n  const dataSource = (_a = results.current) == null ? void 0 : _a[bindingType];\n  if (dataSource && dataSource.error) {\n    callback({ binding: bindingType, error: dataSource.error });\n  } else if (dataSource && dataSource.data !== null && dataSource.meta !== null && dataSource.requestParams !== null) {\n    callback({\n      binding: bindingType,\n      data: dataSource.data,\n      meta: dataSource.meta,\n      requestParams: dataSource.requestParams\n    });\n  }\n  return () => {\n    const idx = subscribers.current[bindingType].indexOf(callback);\n    if (idx === -1) {\n      return;\n    }\n    subscribers.current[bindingType].splice(idx, 1);\n  };\n};\nvar DataSourceContextProvider = ({\n  consumerId,\n  bindings,\n  children\n}) => {\n  const subscribers = (0, react_exports.useRef)({});\n  const results = (0, react_exports.useRef)({});\n  const searchApi = (0, dashboard_context_exports.useSearchContext)();\n  const subscribeFn = (0, react_exports.useCallback)(\n    ({ dsId, consumerId: id, bindingType, subscriberId, onUpdate }) => {\n      return searchApi.createSearchAndSubscribe({\n        dsId,\n        consumerId: id,\n        bindingType,\n        subscriberId,\n        onUpdate,\n        initialRequestParams: DEFAULT_REQUEST_PARAMS\n      });\n    },\n    [searchApi]\n  );\n  const { dataSources } = useSubscribeToSearches({\n    consumerId,\n    bindings,\n    subscribeFn\n  });\n  (0, react_exports.useEffect)(() => {\n    Object.entries(dataSources).forEach(([binding, searchData]) => {\n      var _a;\n      const subs = (_a = subscribers.current[binding]) != null ? _a : [];\n      subs.forEach((cb) => cb(__spreadValues({ binding }, searchData)));\n    });\n  }, [dataSources]);\n  results.current = dataSources;\n  const dataSourceApi = (0, react_exports.useMemo)(() => {\n    return {\n      subscribe: createSubscribe(subscribers, results)\n    };\n  }, []);\n  return /* @__PURE__ */ react_default.createElement(DataSourceContext_default.Provider, { value: dataSourceApi }, children);\n};\n\n// esm-externals:@splunk/react-ui/Tooltip\nvar Tooltip_exports = {};\n__export(Tooltip_exports, {\n  default: () => Tooltip_default\n});\nvar defaultImport31 = __toESM(require(\"@splunk/react-ui/Tooltip\"));\n__reExport(Tooltip_exports, require(\"@splunk/react-ui/Tooltip\"));\nvar Tooltip_default = \"default\" in defaultImport31 ? defaultImport31.default : defaultImport31;\n\n// esm-externals:@splunk/react-ui/Clickable\nvar Clickable_exports = {};\n__export(Clickable_exports, {\n  default: () => Clickable_default\n});\nvar defaultImport32 = __toESM(require(\"@splunk/react-ui/Clickable\"));\n__reExport(Clickable_exports, require(\"@splunk/react-ui/Clickable\"));\nvar Clickable_default = \"default\" in defaultImport32 ? defaultImport32.default : defaultImport32;\n\n// src/EditableListItem.tsx\nvar RemoveIconI18n = () => /* @__PURE__ */ react_default.createElement(dashboard_icons_exports.Remove, { screenReaderText: (0, i18n_exports._)(\"Remove\"), size: \"16px\" });\nvar Item = styled_components_default.div.attrs(({ dataTest, dataTestId }) => ({\n  \"data-test\": dataTest,\n  \"data-test-id\": dataTestId\n}))`\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    color: ${themes_exports.variables.contentColorDefault};\n    line-height: ${themes_exports.variables.inputHeight};\n    height: ${themes_exports.variables.inputHeight};\n    &:hover {\n        cursor: ${(prop) => prop.isItemClickable ? \"pointer\" : \"default\"};\n        background-color: ${themes_exports.variables.backgroundColorHover};\n    }\n`;\nvar NameWrapper = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"item-name-wrapper\"\n}))`\n    width: calc(100% - 70px);\n    border: 2px solid transparent;\n`;\nvar ClickableNameWrapper = styled_components_default(Clickable_default).attrs(() => ({\n  \"data-test\": \"item-name-wrapper\"\n}))`\n    width: calc(100% - 70px);\n    border: 2px solid transparent;\n    &:focus {\n        border: 2px solid ${themes_exports.variables.focusColor};\n        color: ${themes_exports.variables.contentColorDefault};\n        background-color: ${themes_exports.variables.backgroundColorHover};\n    }\n`;\nvar Wrapper = ({ onClick, children }) => {\n  return onClick ? /* @__PURE__ */ react_default.createElement(ClickableNameWrapper, { onClick }, children) : /* @__PURE__ */ react_default.createElement(NameWrapper, null, children);\n};\nvar Row = styled_components_default.div`\n    line-height: 35px;\n    display: flex;\n    flex-direction: row;\n    color: ${(0, themes_exports.pickVariant)(\"isUsed\", {\n  true: themes_exports.variables.contentColorDefault,\n  false: themes_exports.variables.contentColorMuted\n})};\n`;\nvar Name = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"item-name\"\n}))`\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n`;\nvar unusedText = (0, i18n_exports._)(\"(Unused)\");\nvar Unused = styled_components_default.div`\n    margin-left: 5px;\n`;\nvar NameText = ({ name, isUsed }) => /* @__PURE__ */ react_default.createElement(Row, { isUsed }, /* @__PURE__ */ react_default.createElement(Name, null, name), !isUsed && /* @__PURE__ */ react_default.createElement(Unused, null, unusedText));\nvar Icon = styled_components_default(Clickable_default).attrs(({ type }) => ({\n  \"data-test\": `item-${type}`\n}))`\n    width: 35px;\n    text-align: center;\n    border-radius: ${(0, themes_exports.pick)({\n  enterprise: \"0px\",\n  prisma: \"24px\"\n})};\n    color: ${themes_exports.variables.contentColorMuted};\n    &:hover {\n        cursor: pointer;\n        color: ${themes_exports.variables.contentColorDefault};\n        background-color: ${themes_exports.variables.backgroundColorHover};\n    }\n    &:focus {\n        border: 2px solid ${themes_exports.variables.focusColor};\n        color: ${themes_exports.variables.contentColorDefault};\n        background-color: ${themes_exports.variables.backgroundColorHover};\n    }\n`;\nvar ItemStyle = { padding: \"0 10px\" };\nvar EditableListItem = ({\n  name,\n  onItemClick,\n  onEditClick,\n  onRemoveClick,\n  itemStyle = ItemStyle,\n  RemoveIcon = RemoveIconI18n,\n  \"data-test\": dataTest = \"editable-list-item\",\n  \"data-test-id\": dataTestId,\n  isUsed = true\n}) => {\n  const [showTooltip, setShowTooltip] = (0, react_exports.useState)(false);\n  const timer = (0, react_exports.useRef)(null);\n  (0, react_exports.useEffect)(() => {\n    return () => {\n      if (timer.current) {\n        clearTimeout(timer.current);\n      }\n    };\n  }, []);\n  const textOverflow = name.length > 15;\n  const handleRequestOpen = (0, react_exports.useCallback)(() => {\n    if (timer.current) {\n      clearTimeout(timer.current);\n    }\n    timer.current = setTimeout(() => setShowTooltip(true), 250);\n  }, []);\n  const handleRequestClosed = (0, react_exports.useCallback)(() => {\n    if (timer.current) {\n      clearTimeout(timer.current);\n    }\n    timer.current = setTimeout(() => setShowTooltip(false), 100);\n  }, []);\n  const editButton = (0, react_exports.useMemo)(() => {\n    if (!onEditClick) {\n      return null;\n    }\n    return /* @__PURE__ */ react_default.createElement(Icon, { type: \"edit\", onClick: onEditClick }, /* @__PURE__ */ react_default.createElement(dashboard_icons_exports.Edit, { screenReaderText: (0, i18n_exports._)(\"Edit\"), size: \"16px\" }));\n  }, [onEditClick]);\n  const removeButton = (0, react_exports.useMemo)(() => {\n    if (!onRemoveClick) {\n      return null;\n    }\n    return /* @__PURE__ */ react_default.createElement(Icon, { type: \"remove\", onClick: onRemoveClick }, /* @__PURE__ */ react_default.createElement(RemoveIcon, { size: \"24px\" }));\n  }, [onRemoveClick, RemoveIcon]);\n  return /* @__PURE__ */ react_default.createElement(Item, { style: itemStyle, dataTest, dataTestId }, /* @__PURE__ */ react_default.createElement(Wrapper, { onClick: onItemClick }, /* @__PURE__ */ react_default.createElement(\n    Tooltip_default,\n    {\n      \"data-test-disabled\": !textOverflow,\n      content: name,\n      open: showTooltip && textOverflow,\n      onRequestOpen: handleRequestOpen,\n      onRequestClose: handleRequestClosed,\n      inline: false\n    },\n    /* @__PURE__ */ react_default.createElement(NameText, { name, isUsed })\n  )), editButton, removeButton);\n};\nvar EditableListItem_default = EditableListItem;\n\n// esm-externals:@splunk/react-ui/Paragraph\nvar Paragraph_exports = {};\n__export(Paragraph_exports, {\n  default: () => Paragraph_default\n});\nvar defaultImport33 = __toESM(require(\"@splunk/react-ui/Paragraph\"));\n__reExport(Paragraph_exports, require(\"@splunk/react-ui/Paragraph\"));\nvar Paragraph_default = \"default\" in defaultImport33 ? defaultImport33.default : defaultImport33;\n\n// esm-externals:@splunk/react-ui/List\nvar List_exports = {};\n__export(List_exports, {\n  default: () => List_default\n});\nvar defaultImport34 = __toESM(require(\"@splunk/react-ui/List\"));\n__reExport(List_exports, require(\"@splunk/react-ui/List\"));\nvar List_default = \"default\" in defaultImport34 ? defaultImport34.default : defaultImport34;\n\n// src/utils/getStatusMessage.ts\nfunction getStatusMessage(dataSource) {\n  var _a, _b, _c, _d, _e, _f;\n  if (!dataSource) {\n    return void 0;\n  }\n  if (((_a = dataSource.meta) == null ? void 0 : _a.status) === \"done\" && ((_b = dataSource.meta) == null ? void 0 : _b.totalCount) === 0) {\n    return (0, i18n_exports._)(\"No search results returned\");\n  }\n  if (dataSource.error) {\n    return dataSource.error.message;\n  }\n  return ((_c = dataSource.meta) == null ? void 0 : _c.statusMessage) || ((_f = (_e = (_d = dataSource.meta) == null ? void 0 : _d.serverLog) == null ? void 0 : _e[0]) == null ? void 0 : _f.message);\n}\n\n// src/PopoverContentFactory.tsx\nvar GenericPopoverContainer = styled_components_default.div`\n    padding: 12px;\n    max-width: 500px;\n    word-break: break-all;\n`;\nvar UnresolvedTokensPopoverContent = ({\n  message,\n  tokens\n}) => /* @__PURE__ */ react_default.createElement(GenericPopoverContainer, null, /* @__PURE__ */ react_default.createElement(Paragraph_default, null, message), /* @__PURE__ */ react_default.createElement(List_default, null, tokens.map((token) => /* @__PURE__ */ react_default.createElement(List_default.Item, { key: token }, token))));\nvar GenericPopover = ({ message }) => message ? /* @__PURE__ */ react_default.createElement(GenericPopoverContainer, null, message) : null;\nvar GenericPopoverContentFactory = ({\n  dataSource,\n  message\n}) => {\n  if (message) {\n    return /* @__PURE__ */ react_default.createElement(GenericPopover, { message });\n  }\n  if (!dataSource) {\n    return null;\n  }\n  const statusMessage = getStatusMessage(dataSource);\n  if (dataSource.meta && Array.isArray(dataSource.meta.missedTokens) && dataSource.meta.missedTokens.length) {\n    return /* @__PURE__ */ react_default.createElement(\n      UnresolvedTokensPopoverContent,\n      {\n        message: statusMessage,\n        tokens: dataSource.meta.missedTokens\n      }\n    );\n  }\n  return /* @__PURE__ */ react_default.createElement(GenericPopover, { message: statusMessage });\n};\nvar PopoverContentFactory_default = GenericPopoverContentFactory;\n\n// src/EnterprisePopoverContentFactory.tsx\nvar EnterprisePopoverContentFactory_default = ({\n  dataSource,\n  message,\n  componentId,\n  onRequestClose,\n  type = \"visualization\"\n}) => {\n  if (!dataSource) {\n    return /* @__PURE__ */ react_default.createElement(PopoverContentFactory_default, { message });\n  }\n  const statusMessage = getStatusMessage(dataSource);\n  if (statusMessage && (0, dashboard_utils_exports.isRiskyCommandError)(statusMessage)) {\n    return /* @__PURE__ */ react_default.createElement(\n      RiskyWarningPopoverContent_default,\n      {\n        dataSource,\n        componentId,\n        onRequestClose,\n        type\n      }\n    );\n  }\n  return /* @__PURE__ */ react_default.createElement(\n    PopoverContentFactory_default,\n    {\n      dataSource,\n      message\n    }\n  );\n};\n\n// src/ErrorBoundary.tsx\nvar ErrorBoundary = class extends react_exports.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      hasError: false,\n      errorMessage: void 0\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return { hasError: true, errorMessage: error.message };\n  }\n  render() {\n    const {\n      children,\n      errorMessage: customErrorMessage = (0, i18n_exports._)(\n        \"failed to render react component\"\n      ),\n      useMessageFromError = true,\n      render: customRender = (errorMessage2) => /* @__PURE__ */ react_default.createElement(\"div\", null, errorMessage2)\n    } = this.props;\n    const { hasError, errorMessage } = this.state;\n    if (hasError) {\n      return customRender(\n        useMessageFromError && errorMessage ? errorMessage : customErrorMessage\n      );\n    }\n    return children;\n  }\n};\nvar ErrorBoundary_default = ErrorBoundary;\n\n// esm-externals:@splunk/react-ui/Modal\nvar Modal_exports = {};\n__export(Modal_exports, {\n  default: () => Modal_default\n});\nvar defaultImport35 = __toESM(require(\"@splunk/react-ui/Modal\"));\n__reExport(Modal_exports, require(\"@splunk/react-ui/Modal\"));\nvar Modal_default = \"default\" in defaultImport35 ? defaultImport35.default : defaultImport35;\n\n// esm-externals:@splunk/react-ui/Select\nvar Select_exports = {};\n__export(Select_exports, {\n  default: () => Select_default\n});\nvar defaultImport36 = __toESM(require(\"@splunk/react-ui/Select\"));\n__reExport(Select_exports, require(\"@splunk/react-ui/Select\"));\nvar Select_default = \"default\" in defaultImport36 ? defaultImport36.default : defaultImport36;\n\n// esm-externals:@splunk/react-ui/Text\nvar Text_exports = {};\n__export(Text_exports, {\n  default: () => Text_default\n});\nvar defaultImport37 = __toESM(require(\"@splunk/react-ui/Text\"));\n__reExport(Text_exports, require(\"@splunk/react-ui/Text\"));\nvar Text_default = \"default\" in defaultImport37 ? defaultImport37.default : defaultImport37;\n\n// esm-externals:@splunk/react-ui/WaitSpinner\nvar WaitSpinner_exports = {};\n__export(WaitSpinner_exports, {\n  default: () => WaitSpinner_default\n});\nvar defaultImport38 = __toESM(require(\"@splunk/react-ui/WaitSpinner\"));\n__reExport(WaitSpinner_exports, require(\"@splunk/react-ui/WaitSpinner\"));\nvar WaitSpinner_default = \"default\" in defaultImport38 ? defaultImport38.default : defaultImport38;\n\n// src/ExportVisualizationModal.tsx\nvar modalStyle = { width: \"400px\" };\nvar LoadingMessage = styled_components_default.div`\n    display: flex;\n    gap: 10px;\n`;\nvar TRUNCATED_DATA_MESSAGE = `The exported CSV will only include %d rows due to application search limits.`;\nvar ExportVisualizationModal = ({\n  open,\n  onModalClose,\n  itemDefinition,\n  dashboardApi,\n  itemId,\n  createToast\n}) => {\n  var _a, _b, _c;\n  const searchApi = (0, dashboard_context_exports.useSearchContext)();\n  const telemetry = (0, dashboard_telemetry_exports.useTelemetryApi)();\n  const [filenameInput, setFilenameInput] = (0, react_exports.useState)();\n  const filenameInputRef = (0, react_exports.useCallback)((el) => setFilenameInput(el), []);\n  const userMessage = (0, dashboard_context_exports.useUserMessageAPI)();\n  const searchUnsubscribeFnRef = (0, react_exports.useRef)(null);\n  const [filename, setFilename] = (0, react_exports.useState)((_a = itemDefinition.title) != null ? _a : \"\");\n  const [exportValue, setExportValue] = (0, react_exports.useState)(\"png\" /* PNG */);\n  const [isLoading, setIsLoading] = (0, react_exports.useState)(false);\n  const searchData = (0, react_exports.useRef)(null);\n  const [searchDataWarning, setSearchDataWarning] = (0, react_exports.useState)(\"\");\n  const shouldFetchData = (0, react_exports.useRef)(false);\n  shouldFetchData.current = exportValue === \"csv\" /* CSV */ && !searchUnsubscribeFnRef.current && !searchData.current && !isLoading;\n  const handleErrorToast = (0, react_exports.useCallback)(\n    (message) => {\n      telemetry.emit({\n        pageAction: \"udf.export_viz\",\n        source: \"actionMenu\",\n        event: \"viz.export_failed\",\n        metadata: {\n          type: itemDefinition.type,\n          exportType: exportValue\n        },\n        error: message\n      });\n      if (createToast) {\n        createToast({\n          type: \"error\",\n          message\n        });\n        return;\n      }\n      userMessage == null ? void 0 : userMessage({ level: \"error\", message });\n    },\n    [createToast, exportValue, itemDefinition.type, telemetry, userMessage]\n  );\n  const handleResults = (0, react_exports.useCallback)(\n    (data = {}) => {\n      var _a2, _b2, _c2, _d, _e, _f, _g, _h, _i, _j;\n      if (((_a2 = data.meta) == null ? void 0 : _a2.status) !== \"done\" && !((_b2 = data.meta) == null ? void 0 : _b2.isRealTimeSearch) && !data.error) {\n        return;\n      }\n      setIsLoading(false);\n      (_c2 = searchUnsubscribeFnRef.current) == null ? void 0 : _c2.call(searchUnsubscribeFnRef);\n      searchUnsubscribeFnRef.current = null;\n      if (data.error) {\n        handleErrorToast(data.error.message);\n        return;\n      }\n      searchData.current = data;\n      const resultsCount = (_g = (_f = (_e = (_d = data == null ? void 0 : data.data) == null ? void 0 : _d.columns) == null ? void 0 : _e[0]) == null ? void 0 : _f.length) != null ? _g : 0;\n      const totalCount = (_i = (_h = data == null ? void 0 : data.meta) == null ? void 0 : _h.totalCount) != null ? _i : 0;\n      if (resultsCount < totalCount && !((_j = data == null ? void 0 : data.meta) == null ? void 0 : _j.isRealTimeSearch)) {\n        const message = TRUNCATED_DATA_MESSAGE.replace(\n          \"%d\",\n          resultsCount.toLocaleString()\n        );\n        setSearchDataWarning(message);\n      } else {\n        setSearchDataWarning(\"\");\n      }\n    },\n    [handleErrorToast]\n  );\n  (0, react_exports.useEffect)(() => {\n    return () => {\n      var _a2;\n      (_a2 = searchUnsubscribeFnRef.current) == null ? void 0 : _a2.call(searchUnsubscribeFnRef);\n    };\n  }, []);\n  const fetchData = (0, react_exports.useCallback)(() => {\n    var _a2, _b2;\n    const dsId = (_b2 = (_a2 = itemDefinition == null ? void 0 : itemDefinition.dataSources) == null ? void 0 : _a2.primary) != null ? _b2 : \"\";\n    const consumerId = `${itemId}_${(0, dashboard_definition_exports.generateId)(\"export\")}`;\n    setIsLoading(true);\n    const unsubscribe = searchApi.createSearchAndSubscribe({\n      dsId,\n      consumerId,\n      bindingType: \"unbound\",\n      initialRequestParams: {},\n      subscriberId: \"export-modal\",\n      onUpdate: handleResults\n    });\n    searchUnsubscribeFnRef.current = unsubscribe;\n  }, [\n    handleResults,\n    (_b = itemDefinition == null ? void 0 : itemDefinition.dataSources) == null ? void 0 : _b.primary,\n    itemId,\n    searchApi\n  ]);\n  (0, react_exports.useEffect)(() => {\n    var _a2;\n    if (open && shouldFetchData.current) {\n      fetchData();\n    }\n    if (!open) {\n      (_a2 = searchUnsubscribeFnRef.current) == null ? void 0 : _a2.call(searchUnsubscribeFnRef);\n      searchUnsubscribeFnRef.current = null;\n      searchData.current = null;\n      setSearchDataWarning(\"\");\n      setIsLoading(false);\n    }\n  }, [fetchData, open]);\n  const handleCloseModal = (0, react_exports.useCallback)(() => {\n    onModalClose();\n  }, [onModalClose]);\n  const handleExport = (0, react_exports.useCallback)(() => __async(void 0, null, function* () {\n    try {\n      switch (exportValue) {\n        case \"csv\" /* CSV */: {\n          if (!searchData.current) {\n            throw new Error(\n              (0, i18n_exports._)(\"Search data was not retrieved correctly\")\n            );\n          }\n          yield (0, dashboard_utils_exports.exportSearchDataAsCsv)(searchData.current, filename);\n          break;\n        }\n        case \"png\" /* PNG */: {\n          const vizDomElement = dashboardApi.getVisualizationDomElement(\n            itemId\n          );\n          yield (0, dashboard_utils_exports.exportVizAsPng)({\n            vizDomNode: vizDomElement,\n            vizId: itemId,\n            vizType: itemDefinition.type,\n            scale: 1.5,\n            filename\n          });\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      telemetry.emit({\n        pageAction: \"udf.export_viz\",\n        source: \"actionMenu\",\n        event: `viz.export_${exportValue}_success`,\n        metadata: {\n          type: itemDefinition.type,\n          exportType: exportValue\n        }\n      });\n    } catch (error) {\n      const { message } = error;\n      handleErrorToast(message);\n    }\n    handleCloseModal();\n  }), [\n    handleCloseModal,\n    exportValue,\n    telemetry,\n    itemDefinition.type,\n    filename,\n    dashboardApi,\n    itemId,\n    handleErrorToast\n  ]);\n  const handleExportValueChange = (0, react_exports.useCallback)(\n    (_e, { value }) => {\n      setExportValue(value);\n      if (value === \"csv\" /* CSV */ && !searchUnsubscribeFnRef.current && !searchData.current) {\n        fetchData();\n      }\n    },\n    [fetchData]\n  );\n  const handleFilenameChange = (0, react_exports.useCallback)(\n    (_e, { value }) => {\n      setFilename(String(value));\n    },\n    []\n  );\n  const showDataSourceWarning = (0, react_exports.useMemo)(() => {\n    var _a2;\n    const itemDefSources = (_a2 = itemDefinition.dataSources) != null ? _a2 : {};\n    const hasMultipleDataSources = Object.keys(itemDefSources).length > 1;\n    const csvOptionSelected = exportValue === \"csv\" /* CSV */;\n    return hasMultipleDataSources && csvOptionSelected;\n  }, [itemDefinition.dataSources, exportValue]);\n  return /* @__PURE__ */ react_default.createElement(\n    Modal_default,\n    {\n      open,\n      onRequestClose: handleCloseModal,\n      initialFocus: filenameInput,\n      style: modalStyle\n    },\n    /* @__PURE__ */ react_default.createElement(\n      Modal_default.Header,\n      {\n        onRequestClose: handleCloseModal,\n        title: (0, i18n_exports._)(\"Export visualization\")\n      }\n    ),\n    /* @__PURE__ */ react_default.createElement(Modal_default.Body, null, /* @__PURE__ */ react_default.createElement(\n      ControlGroup_default,\n      {\n        \"data-test\": \"file-name\",\n        label: (0, i18n_exports._)(\"File name\"),\n        labelPosition: \"top\"\n      },\n      /* @__PURE__ */ react_default.createElement(\n        Text_default,\n        {\n          inputRef: filenameInputRef,\n          onChange: handleFilenameChange,\n          value: filename\n        }\n      )\n    ), /* @__PURE__ */ react_default.createElement(\n      ControlGroup_default,\n      {\n        \"data-test\": \"file-type\",\n        label: (0, i18n_exports._)(\"File type\"),\n        labelPosition: \"top\"\n      },\n      /* @__PURE__ */ react_default.createElement(\n        Select_default,\n        {\n          value: exportValue,\n          onChange: handleExportValueChange\n        },\n        /* @__PURE__ */ react_default.createElement(\n          Select_default.Option,\n          {\n            label: (0, i18n_exports._)(\"PNG\"),\n            value: \"png\" /* PNG */\n          }\n        ),\n        !!((_c = itemDefinition == null ? void 0 : itemDefinition.dataSources) == null ? void 0 : _c.primary) && /* @__PURE__ */ react_default.createElement(\n          Select_default.Option,\n          {\n            label: (0, i18n_exports._)(\"CSV\"),\n            value: \"csv\" /* CSV */\n          }\n        )\n      )\n    ), showDataSourceWarning && /* @__PURE__ */ react_default.createElement(Paragraph_default, { \"data-test\": \"data-source-warning\" }, (0, i18n_exports._)(\n      \"Exported CSV data will only include the primary data source.\"\n    )), exportValue === \"csv\" /* CSV */ && searchDataWarning && /* @__PURE__ */ react_default.createElement(Paragraph_default, { \"data-test\": \"search-data-warning\" }, searchDataWarning), isLoading && exportValue === \"csv\" /* CSV */ && /* @__PURE__ */ react_default.createElement(LoadingMessage, null, /* @__PURE__ */ react_default.createElement(WaitSpinner_default, null), /* @__PURE__ */ react_default.createElement(Paragraph_default, { \"data-test\": \"fetching-data-warning\" }, (0, i18n_exports._)(\"Retrieving search data...\")))),\n    /* @__PURE__ */ react_default.createElement(Modal_default.Footer, null, /* @__PURE__ */ react_default.createElement(Button_default, { label: (0, i18n_exports._)(\"Cancel\"), onClick: handleCloseModal }), /* @__PURE__ */ react_default.createElement(\n      Button_default,\n      {\n        label: (0, i18n_exports._)(\"Export\"),\n        appearance: \"primary\",\n        onClick: handleExport,\n        \"data-test\": \"export-btn\",\n        disabled: isLoading && exportValue === \"csv\" /* CSV */\n      }\n    ))\n  );\n};\n\n// esm-externals:@splunk/themes/useSplunkTheme\nvar useSplunkTheme_exports = {};\n__export(useSplunkTheme_exports, {\n  default: () => useSplunkTheme_default\n});\nvar defaultImport39 = __toESM(require(\"@splunk/themes/useSplunkTheme\"));\n__reExport(useSplunkTheme_exports, require(\"@splunk/themes/useSplunkTheme\"));\nvar useSplunkTheme_default = \"default\" in defaultImport39 ? defaultImport39.default : defaultImport39;\n\n// src/GalleryDeletionModal.tsx\nvar FixedWidthModal = styled_components_default(Modal_default)`\n    width: 600px;\n`;\nvar GalleryDeletionModal = ({\n  testId = \"gallery-deletion-modal\",\n  objectName,\n  objectType,\n  sourceElement,\n  handleObjectDeletion,\n  handleDeletionCancel\n}) => {\n  const { family } = useSplunkTheme_default();\n  const handleCancelDeletion = (0, react_exports.useCallback)(\n    (event) => {\n      var _a;\n      if (handleDeletionCancel) {\n        handleDeletionCancel(event);\n      }\n      (_a = sourceElement == null ? void 0 : sourceElement.current) == null ? void 0 : _a.focus();\n    },\n    [sourceElement, handleDeletionCancel]\n  );\n  const handleRequestClose = (0, react_exports.useCallback)(\n    ({ event }) => handleCancelDeletion(event),\n    [handleCancelDeletion]\n  );\n  const modalBody = (0, react_exports.useMemo)(() => {\n    const preamble = (0, i18n_exports._)(\"Deleting the \");\n    let postscript = (0, i18n_exports._)(\n      \"is permanent for this dashboard and all other dashboards that use the\"\n    );\n    postscript = ` ${objectType} ${postscript} ${objectType}.`;\n    return /* @__PURE__ */ react_default.createElement(Paragraph_default, null, preamble, /* @__PURE__ */ react_default.createElement(\"i\", null, objectName), postscript);\n  }, [objectName, objectType]);\n  const capitalizedObjectType = objectType.length ? objectType[0].toUpperCase() + objectType.substring(1) : objectType;\n  const cancelButtonAppearance = family === \"enterprise\" ? \"pill\" : \"secondary\";\n  const confirmButtonAppearance = family === \"enterprise\" ? \"primary\" : \"destructive\";\n  return /* @__PURE__ */ react_default.createElement(\n    FixedWidthModal,\n    {\n      \"data-test\": testId,\n      onRequestClose: handleRequestClose,\n      open: true,\n      divider: \"none\"\n    },\n    /* @__PURE__ */ react_default.createElement(\n      Modal_default.Header,\n      {\n        onRequestClose: handleCancelDeletion,\n        title: `${(0, i18n_exports._)(\"Delete\")} ${objectName}`\n      }\n    ),\n    /* @__PURE__ */ react_default.createElement(Modal_default.Body, null, modalBody),\n    /* @__PURE__ */ react_default.createElement(Modal_default.Footer, null, /* @__PURE__ */ react_default.createElement(\n      Button_default,\n      {\n        \"data-test-appearance\": cancelButtonAppearance,\n        \"data-test-family\": family,\n        \"data-test\": `${testId}-cancel`,\n        appearance: cancelButtonAppearance,\n        onClick: handleCancelDeletion,\n        label: (0, i18n_exports._)(`Keep ${capitalizedObjectType}`)\n      }\n    ), /* @__PURE__ */ react_default.createElement(\n      Button_default,\n      {\n        \"data-test-appearance\": confirmButtonAppearance,\n        \"data-test-family\": family,\n        \"data-test\": `${testId}-confirm`,\n        appearance: confirmButtonAppearance,\n        label: (0, i18n_exports._)(`Delete ${capitalizedObjectType}`),\n        onClick: handleObjectDeletion\n      }\n    ))\n  );\n};\nvar GalleryDeletionModal_default = GalleryDeletionModal;\n\n// src/Gallery.tsx\nvar Container3 = styled_components_default.div`\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    flex-direction: column;\n    padding: 5px;\n    width: 515px;\n    min-height: 200px;\n    background-color: ${themes_exports.variables.backgroundColorDialog};\n`;\nvar GalleryList = styled_components_default.div`\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n    overflow: auto;\n    padding: 5px 0px;\n    width: 100%;\n    height: 200px;\n    border-bottom: ${(0, themes_exports.pick)({\n  prisma: \"1px solid #43454b\",\n  enterprise: \"1px solid #c3cbd4\"\n})};\n`;\nvar spinnerStyle = { margin: \"auto\" };\nvar Gallery = ({\n  isLoading = false,\n  search = null,\n  message = null,\n  upload = null,\n  items,\n  Item: Item2,\n  onItemRemove,\n  onItemClick = dashboard_utils_exports.noop,\n  testId = \"gallery\",\n  setHasChildModal,\n  galleryType = \"item\"\n}) => {\n  const hasItems = Array.isArray(items) && items.length > 0;\n  const [selectedItem, setSelectedItem] = (0, react_exports.useState)(null);\n  const [confirmationModalData, setConfirmationModalData] = (0, react_exports.useState)();\n  const confirmationModalIsOpen = (0, react_exports.useRef)(false);\n  const searchRef = (0, react_exports.useRef)(null);\n  const searchWithRef = (0, react_exports.useMemo)(() => {\n    if (search) {\n      return react_default.cloneElement(search, { ref: searchRef });\n    }\n    return null;\n  }, [search]);\n  const handleModalOpen = (0, react_exports.useCallback)(() => {\n    confirmationModalIsOpen.current = true;\n    setHasChildModal == null ? void 0 : setHasChildModal(true);\n  }, [setHasChildModal]);\n  const handleModalClose = (0, react_exports.useCallback)(() => {\n    var _a;\n    confirmationModalIsOpen.current = false;\n    setHasChildModal == null ? void 0 : setHasChildModal(false);\n    (_a = searchRef.current) == null ? void 0 : _a.focus();\n  }, [setHasChildModal]);\n  (0, react_exports.useEffect)(() => {\n    if (confirmationModalIsOpen.current && !confirmationModalData) {\n      handleModalClose();\n    } else if (!confirmationModalIsOpen.current && confirmationModalData) {\n      handleModalOpen();\n    }\n  }, [confirmationModalData, handleModalOpen, handleModalClose]);\n  const handleItemEnter = (0, react_exports.useCallback)(\n    (item) => setSelectedItem(item.url),\n    [setSelectedItem]\n  );\n  const handleItemLeave = (0, react_exports.useCallback)(\n    () => setSelectedItem(null),\n    [setSelectedItem]\n  );\n  const handleDeletionCancel = (0, react_exports.useCallback)(() => {\n    setConfirmationModalData(void 0);\n  }, []);\n  const handleObjectDeletion = (0, react_exports.useCallback)(\n    (item) => {\n      if (onItemRemove) {\n        onItemRemove(item);\n      }\n      handleDeletionCancel();\n    },\n    [onItemRemove, handleDeletionCancel]\n  );\n  const onRemove = (0, react_exports.useCallback)(\n    (item) => () => {\n      setConfirmationModalData({\n        objectName: item.name,\n        objectType: galleryType,\n        handleObjectDeletion: () => handleObjectDeletion(item),\n        handleDeletionCancel\n      });\n    },\n    [galleryType, handleDeletionCancel, handleObjectDeletion]\n  );\n  const galleryItems = (0, react_exports.useMemo)(() => {\n    if (isLoading || !hasItems) {\n      return [];\n    }\n    return items.map((item) => /* @__PURE__ */ react_default.createElement(\n      Item2,\n      {\n        key: item.url,\n        item,\n        selected: selectedItem === item.url,\n        onMouseEnter: handleItemEnter,\n        onMouseLeave: handleItemLeave,\n        onRemove: onItemRemove ? onRemove(item) : null,\n        onClick: onItemClick\n      }\n    ));\n  }, [\n    hasItems,\n    isLoading,\n    items,\n    selectedItem,\n    handleItemEnter,\n    handleItemLeave,\n    onItemClick,\n    onItemRemove,\n    onRemove,\n    Item2\n  ]);\n  if (confirmationModalData) {\n    return /* @__PURE__ */ react_default.createElement(\n      GalleryDeletionModal_default,\n      __spreadValues({\n        testId: `${testId}-deletion-modal`\n      }, confirmationModalData)\n    );\n  }\n  return /* @__PURE__ */ react_default.createElement(\n    Container3,\n    {\n      \"data-test\": testId,\n      \"data-test-loading\": `${isLoading}`,\n      tabIndex: -1\n    },\n    searchWithRef,\n    message,\n    isLoading && /* @__PURE__ */ react_default.createElement(\n      WaitSpinner_default,\n      {\n        size: \"medium\",\n        screenReaderText: (0, i18n_exports._)(\"loading\"),\n        style: spinnerStyle\n      }\n    ),\n    !isLoading && hasItems && /* @__PURE__ */ react_default.createElement(GalleryList, { \"data-test\": \"gallery-list\" }, galleryItems),\n    !isLoading && upload\n  );\n};\nvar Gallery_default = Gallery;\n\n// esm-externals:@splunk/react-ui/Message\nvar Message_exports = {};\n__export(Message_exports, {\n  default: () => Message_default\n});\nvar defaultImport40 = __toESM(require(\"@splunk/react-ui/Message\"));\n__reExport(Message_exports, require(\"@splunk/react-ui/Message\"));\nvar Message_default = \"default\" in defaultImport40 ? defaultImport40.default : defaultImport40;\n\n// src/Message.tsx\nvar centerDiv = styled_components_exports.css`\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n`;\nvar MessageContainer = styled_components_default.div`\n    ${(props) => props.centered ? centerDiv : null}\n    font-size: 15px;\n`;\nvar Message = ({\n  level = \"info\",\n  message = \"\",\n  centered = true\n}) => /* @__PURE__ */ react_default.createElement(MessageContainer, { \"data-test\": \"dashboard-message\", centered }, /* @__PURE__ */ react_default.createElement(Message_default, { type: level }, message));\nvar Message_default2 = Message;\n\n// src/GalleryMessage.tsx\nvar MsgContainer = styled_components_default.div`\n    display: inline-block;\n    width: 95%;\n    height: 200px;\n    position: relative;\n`;\nvar MsgClose = styled_components_default.div`\n    float: right;\n`;\nvar GalleryMessage = ({ error, warning, onClose }) => {\n  if (!error && !warning) {\n    return null;\n  }\n  const type = error ? \"error\" : \"warning\";\n  const msg = error || warning;\n  return /* @__PURE__ */ react_default.createElement(MsgContainer, null, /* @__PURE__ */ react_default.createElement(Message_default2, { level: type, message: msg }), onClose && /* @__PURE__ */ react_default.createElement(MsgClose, { onClick: onClose }, /* @__PURE__ */ react_default.createElement(Close_default, { size: 0.5 })));\n};\nvar GalleryMessage_default = GalleryMessage;\n\n// src/GallerySearch.tsx\nvar Search = styled_components_default.div`\n    height: 50px;\n    width: 100%;\n    padding: 5px 0px;\n`;\nvar GallerySearch = react_default.forwardRef(\n  ({ onSearch, disabled, placeholder = \"Search\" }, ref) => {\n    const [search, setSearch] = (0, react_exports.useState)(\"\");\n    const handleSearch = (0, react_exports.useCallback)(\n      (event, { value }) => {\n        setSearch(value);\n        onSearch == null ? void 0 : onSearch(value);\n      },\n      [onSearch]\n    );\n    if (!onSearch) {\n      return null;\n    }\n    return /* @__PURE__ */ react_default.createElement(Search, null, /* @__PURE__ */ react_default.createElement(\n      Text_default,\n      {\n        inputRef: ref,\n        canClear: true,\n        value: `${search}`,\n        disabled,\n        placeholder,\n        appearance: \"search\",\n        onChange: handleSearch,\n        \"data-test\": \"gallery-search\"\n      }\n    ));\n  }\n);\nvar GallerySearch_default = GallerySearch;\n\n// esm-externals:@splunk/react-ui/File\nvar File_exports = {};\n__export(File_exports, {\n  default: () => File_default\n});\nvar defaultImport41 = __toESM(require(\"@splunk/react-ui/File\"));\n__reExport(File_exports, require(\"@splunk/react-ui/File\"));\nvar File_default = \"default\" in defaultImport41 ? defaultImport41.default : defaultImport41;\n\n// src/GalleryUpload.tsx\nvar UploadItem = styled_components_default.div`\n    padding: 5px 0px;\n    width: 100%;\n`;\nvar SharingWarning = styled_components_default.span`\n    height: 20px;\n    font-size: smaller;\n    font-style: italic;\n`;\nvar warningText = (0, i18n_exports._)(\n  \"Note: Uploaded image files can be accessed and deleted by others in your organization\"\n);\nvar GalleryUpload = ({\n  fileTypes,\n  onUpload,\n  enableGallerySharingWarning\n}) => {\n  return /* @__PURE__ */ react_default.createElement(UploadItem, null, /* @__PURE__ */ react_default.createElement(File_default, { onRequestAdd: onUpload, accept: fileTypes, allowMultiple: true }, enableGallerySharingWarning ? /* @__PURE__ */ react_default.createElement(SharingWarning, { \"data-test\": \"gallery-sharing-warning\" }, warningText) : null));\n};\nvar GalleryUpload_default = GalleryUpload;\n\n// src/Header.tsx\nvar HeaderContainer3 = styled_components_default.div`\n    padding: 8px 8px 0px 8px;\n    background-color: ${customThemeVariables.dashboardBackgroundColor};\n    box-sizing: border-box;\n`;\nvar TitleContainer3 = styled_components_default.div`\n    display: flex;\n    align-items: flex-start;\n    min-height: ${LINE_HEIGHT};\n    box-sizing: inherit;\n`;\nvar TriangleContainer2 = styled_components_default.button`\n    display: flex;\n    align-items: center;\n    height: ${LINE_HEIGHT};\n    box-sizing: inherit;\n    color: ${themes_exports.variables.contentColorDefault};\n    background: none;\n    cursor: pointer;\n    border: 0;\n    padding: 0;\n`;\nvar Triangle = (0, react_exports.forwardRef)(\n  ({ isExpanded, onClick }, ref) => {\n    return /* @__PURE__ */ react_default.createElement(TriangleContainer2, { ref, onClick }, isExpanded ? /* @__PURE__ */ react_default.createElement(\n      TriangleDownSmall_default,\n      {\n        \"data-test\": \"triangle-header-expanded\",\n        screenReaderText: (0, i18n_exports._)(\"Show less\")\n      }\n    ) : /* @__PURE__ */ react_default.createElement(\n      TriangleRightSmall_default,\n      {\n        \"data-test\": \"triangle-header-collapsed\",\n        screenReaderText: (0, i18n_exports._)(\"Show more\")\n      }\n    ));\n  }\n);\nvar DashboardHeader = (0, react_exports.forwardRef)(\n  ({ definition, mode, dashboardApi, titleRef, descRef, handleRef }, ref) => {\n    const [isExpanded, setIsExpanded] = (0, react_exports.useState)(true);\n    const handleDefinitionChange = (0, react_exports.useCallback)(\n      (def) => {\n        dashboardApi == null ? void 0 : dashboardApi.updateDefinition(def);\n      },\n      [dashboardApi]\n    );\n    const handleExpandToggle = (0, react_exports.useCallback)(() => {\n      setIsExpanded((isExpandedVal) => !isExpandedVal);\n    }, []);\n    const handleTitleCommit = (0, react_exports.useCallback)(\n      (val) => handleDefinitionChange(__spreadProps(__spreadValues({}, definition), {\n        title: val\n      })),\n      [handleDefinitionChange, definition]\n    );\n    const {\n      onHandleBlur: onHandleBlurTitle,\n      onHandleChange: onHandleChangeTitle,\n      onHandleKeyDown: onHandleKeyDownTitle,\n      value: valueTitle\n    } = useTextInput({\n      initialValue: definition.title,\n      handleCommit: handleTitleCommit,\n      uniqKey: definition.title || \"\"\n    });\n    const handleDescCommit = (0, react_exports.useCallback)(\n      (val) => handleDefinitionChange(__spreadProps(__spreadValues({}, definition), {\n        description: val\n      })),\n      [handleDefinitionChange, definition]\n    );\n    const {\n      onHandleBlur: onHandleBlurDesc,\n      onHandleChange: onHandleChangeDesc,\n      onHandleKeyDown: onHandleKeyDownDesc,\n      value: valueDesc\n    } = useTextInput({\n      initialValue: definition.description,\n      handleCommit: handleDescCommit,\n      uniqKey: definition.description || \"\"\n    });\n    const renderTriangle = (0, react_exports.useMemo)(() => {\n      if (mode === \"edit\") {\n        return null;\n      }\n      return /* @__PURE__ */ react_default.createElement(\n        Triangle,\n        {\n          ref: handleRef,\n          isExpanded,\n          onClick: handleExpandToggle\n        }\n      );\n    }, [handleRef, mode, isExpanded, handleExpandToggle]);\n    if (!valueTitle && !valueDesc && mode === \"view\") {\n      return null;\n    }\n    return /* @__PURE__ */ react_default.createElement(HeaderContainer3, { \"data-test\": \"dashboard-header\", ref }, mode === \"view\" && !valueTitle ? null : /* @__PURE__ */ react_default.createElement(TitleContainer3, { \"data-test\": \"dashboard-header-title\" }, /* @__PURE__ */ react_default.createElement(\n      Title_default,\n      {\n        ref: titleRef,\n        handleBlur: onHandleBlurTitle,\n        handleChange: onHandleChangeTitle,\n        handleKeyDown: onHandleKeyDownTitle,\n        isExpanded,\n        mode,\n        value: valueTitle\n      }\n    ), mode === \"view\" && valueDesc && renderTriangle), mode === \"view\" && !valueDesc ? null : /* @__PURE__ */ react_default.createElement(\n      Description_default,\n      {\n        ref: descRef,\n        handleBlur: onHandleBlurDesc,\n        handleChange: onHandleChangeDesc,\n        handleKeyDown: onHandleKeyDownDesc,\n        showInViewMode: isExpanded,\n        mode,\n        value: valueDesc\n      }\n    ));\n  }\n);\nvar Header_default = DashboardHeader;\n\n// esm-externals:@splunk/react-icons/enterprise/Remove\nvar Remove_exports = {};\n__export(Remove_exports, {\n  default: () => Remove_default\n});\nvar defaultImport42 = __toESM(require(\"@splunk/react-icons/enterprise/Remove\"));\n__reExport(Remove_exports, require(\"@splunk/react-icons/enterprise/Remove\"));\nvar Remove_default = \"default\" in defaultImport42 ? defaultImport42.default : defaultImport42;\n\n// esm-externals:@splunk/visualizations-shared/RemoteIcon\nvar RemoteIcon_exports = {};\n__export(RemoteIcon_exports, {\n  default: () => RemoteIcon_default\n});\nvar defaultImport43 = __toESM(require(\"@splunk/visualizations-shared/RemoteIcon\"));\n__reExport(RemoteIcon_exports, require(\"@splunk/visualizations-shared/RemoteIcon\"));\nvar RemoteIcon_default = \"default\" in defaultImport43 ? defaultImport43.default : defaultImport43;\n\n// src/IconGalleryItem.tsx\nvar customVariables = {\n  transparentPatternEvenColor: (0, themes_exports.pick)({\n    enterprise: themes_exports.variables.gray80,\n    prisma: themes_exports.variables.neutral400\n  }),\n  transparentPatternOddColor: (0, themes_exports.pick)({\n    enterprise: themes_exports.variables.gray92,\n    prisma: themes_exports.variables.neutral500\n  })\n};\nvar IconContainer = styled_components_default.div`\n    width: 60px;\n    height: 65px;\n    margin: 8px 5px 0 5px;\n    border-radius: 3px;\n    &:hover {\n        cursor: pointer;\n        background: ${themes_exports.variables.backgroundColorHover};\n    }\n`;\nvar IconClose = styled_components_default.div`\n    display: flex;\n    visibility: ${(props) => props.selected ? \"visible\" : \"hidden\"};\n    justify-content: flex-end;\n`;\nvar IconText = styled_components_default.div`\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    text-align: center;\n    color: ${themes_exports.variables.contentColorDefault};\n`;\nvar Icon2 = styled_components_default.div`\n    width: 40px;\n    height: 40px;\n    margin: 0px 10px 0px 10px;\n    background-color: transparent;\n    background-image: linear-gradient(\n            45deg,\n            ${customVariables.transparentPatternOddColor} 25%,\n            transparent 25%,\n            transparent 75%,\n            ${customVariables.transparentPatternOddColor} 75%,\n            ${customVariables.transparentPatternOddColor} 100%\n        ),\n        linear-gradient(\n            45deg,\n            ${customVariables.transparentPatternOddColor} 25%,\n            ${customVariables.transparentPatternEvenColor} 25%,\n            ${customVariables.transparentPatternEvenColor} 75%,\n            ${customVariables.transparentPatternOddColor} 75%,\n            ${customVariables.transparentPatternOddColor} 100%\n        );\n    background-size: 5px 5px;\n    background-position: 0 0, 2.5px 2.5px;\n    border-radius: 3px;\n    display: flex;\n    align-items: center;\n`;\nvar IconGalleryItem = ({\n  item,\n  selected = false,\n  onClick = dashboard_utils_exports.noop,\n  onMouseEnter = dashboard_utils_exports.noop,\n  onMouseLeave = dashboard_utils_exports.noop,\n  onRemove = dashboard_utils_exports.noop\n}) => {\n  const { name, url } = item;\n  const handleClick2 = (0, react_exports.useCallback)(() => onClick(item.url), [onClick, item]);\n  const handleMouseEnter = (0, react_exports.useCallback)(\n    () => onMouseEnter(item),\n    [onMouseEnter, item]\n  );\n  const handleMouseLeave = (0, react_exports.useCallback)(\n    () => onMouseLeave(item),\n    [onMouseLeave, item]\n  );\n  const handleDelete = (0, react_exports.useCallback)(\n    (evt) => {\n      evt.stopPropagation();\n      onRemove == null ? void 0 : onRemove(item);\n    },\n    [onRemove, item]\n  );\n  return /* @__PURE__ */ react_default.createElement(\n    IconContainer,\n    {\n      \"data-test\": \"icon-container\",\n      \"data-url\": url,\n      key: url,\n      title: name,\n      onClick: handleClick2,\n      onMouseEnter: handleMouseEnter,\n      onMouseLeave: handleMouseLeave\n    },\n    onRemove && /* @__PURE__ */ react_default.createElement(\n      IconClose,\n      {\n        selected,\n        \"data-test\": \"icon-close\",\n        onClick: handleDelete\n      },\n      /* @__PURE__ */ react_default.createElement(Remove_default, { size: 0.5 })\n    ),\n    /* @__PURE__ */ react_default.createElement(Icon2, { \"data-test\": \"icon\" }, /* @__PURE__ */ react_default.createElement(RemoteIcon_default, { iconURL: url, width: 30, height: 30 })),\n    /* @__PURE__ */ react_default.createElement(IconText, { \"data-test\": \"icon-name\" }, name)\n  );\n};\nvar IconGalleryItem_default = IconGalleryItem;\n\n// src/IconGallery.tsx\nvar getWarning = (icons, msg) => {\n  if (Array.isArray(icons) && icons.length) {\n    return void 0;\n  }\n  return msg;\n};\nvar IconGallery = ({\n  providerType: initialProviderType,\n  onClick = dashboard_utils_exports.noop,\n  enableSearch = true,\n  setHasChildModal\n}) => {\n  const [icons, setIcons] = (0, react_exports.useState)([]);\n  const [providerType, setProviderType] = (0, react_exports.useState)(initialProviderType);\n  const [loading, setLoading] = (0, react_exports.useState)(true);\n  const [searching, setSearching] = (0, react_exports.useState)(false);\n  const [error, setError] = (0, react_exports.useState)();\n  const [warning, setWarning] = (0, react_exports.useState)();\n  const iconRegistry = (0, dashboard_context_exports.useIconRegistry)();\n  const { enableIconUploads, enableIconDelete, enableGallerySharingWarning } = (0, dashboard_context_exports.useFeatureFlags)();\n  const getIconRegistry = (0, react_exports.useCallback)(() => {\n    if (!iconRegistry) {\n      throw new Error((0, i18n_exports._)(\"No icon registry found\"));\n    }\n    return iconRegistry;\n  }, [iconRegistry]);\n  (0, react_exports.useEffect)(() => {\n    if (!providerType) {\n      try {\n        const provider = getIconRegistry().listProviders().find((type) => type.isDefault);\n        if (!provider) {\n          throw new Error(\"No icon providers found\");\n        }\n        setProviderType(provider.type);\n      } catch (err) {\n        if (err instanceof Error) {\n          setError(err.message);\n        }\n      }\n    }\n  }, [providerType, getIconRegistry]);\n  const getIconsFromAllProviders = (0, react_exports.useCallback)(\n    (options) => __async(void 0, null, function* () {\n      const registry = getIconRegistry();\n      const providers = registry.listProviders();\n      const iconLists = yield Promise.all(\n        providers.map((provider) => __async(void 0, null, function* () {\n          const { type } = provider;\n          const ids = yield registry.listIds(type, __spreadProps(__spreadValues({}, options), {\n            meta: [\"name\"]\n          }));\n          return ids.map((id) => __spreadProps(__spreadValues({}, id), { providerType: type }));\n        }))\n      );\n      return iconLists.reduce(\n        (iconList, currentList) => iconList.concat(currentList),\n        []\n      );\n    }),\n    [getIconRegistry]\n  );\n  const fetchIcons = (0, react_exports.useCallback)(() => __async(void 0, null, function* () {\n    if (!providerType) {\n      setLoading(false);\n      return;\n    }\n    try {\n      const ids = yield getIconsFromAllProviders();\n      const newIcons = ids.map((idObj) => ({\n        url: `${idObj.providerType}://${idObj.id}`,\n        name: idObj.metaData.name.split(\".\")[0]\n      }));\n      setIcons((0, lodash_exports.sortBy)(newIcons, [\"name\"]));\n      setError(void 0);\n      setLoading(false);\n      setWarning(\n        getWarning(newIcons, (0, i18n_exports._)(\"No icons. Please upload icons.\"))\n      );\n    } catch (err) {\n      if (err instanceof Error) {\n        setError(err.message);\n      }\n      setLoading(false);\n    }\n  }), [providerType, getIconsFromAllProviders]);\n  (0, react_exports.useEffect)(() => {\n    fetchIcons();\n  }, [fetchIcons]);\n  const handleIconUpload = (0, react_exports.useCallback)(\n    (files) => {\n      if (!enableIconUploads || !providerType) {\n        return;\n      }\n      setLoading(true);\n      files.forEach((file) => {\n        const fileReader = new FileReader();\n        fileReader.onload = () => __async(void 0, null, function* () {\n          const fileName = file.name;\n          try {\n            const iconURL = yield getIconRegistry().upload(\n              fileReader.result,\n              { name: fileName },\n              providerType\n            );\n            setIcons(\n              (currentIcons) => (0, lodash_exports.sortBy)(\n                [\n                  ...currentIcons,\n                  { url: iconURL, name: fileName }\n                ],\n                [\"name\"]\n              )\n            );\n            setWarning(void 0);\n            setError(void 0);\n            setLoading(false);\n          } catch (err) {\n            if (err instanceof Error) {\n              setError(err.message);\n            }\n            setLoading(false);\n          }\n        });\n        fileReader.readAsDataURL(file);\n      });\n    },\n    [providerType, enableIconUploads, getIconRegistry]\n  );\n  const handleSearch = (0, react_exports.useCallback)(\n    (searchStr = \"\") => __async(void 0, null, function* () {\n      setSearching(true);\n      try {\n        const ids = yield getIconsFromAllProviders({\n          meta: [\"name\"],\n          search: searchStr.trim()\n        });\n        const newIcons = ids.map((idObj) => ({\n          url: `${idObj.providerType}://${idObj.id}`,\n          name: idObj.metaData.name.split(\".\")[0]\n        }));\n        setIcons((0, lodash_exports.sortBy)(newIcons, [\"name\"]));\n        setError(void 0);\n        setWarning(getWarning(newIcons, (0, i18n_exports._)(\"No icons found.\")));\n        setSearching(false);\n      } catch (err) {\n        if (err instanceof Error) {\n          setError(err.message);\n        }\n        setSearching(false);\n      }\n    }),\n    [getIconsFromAllProviders]\n  );\n  const handleDelete = (0, react_exports.useCallback)(\n    (deletedIcon) => __async(void 0, null, function* () {\n      if (!enableIconDelete) {\n        return;\n      }\n      setLoading(true);\n      try {\n        yield getIconRegistry().deleteByURL(deletedIcon.url);\n        const newIcons = icons.filter(\n          (icon) => icon.url !== deletedIcon.url\n        );\n        setIcons(newIcons);\n        setLoading(false);\n        setWarning(\n          getWarning(newIcons, (0, i18n_exports._)(\"No Icons. Please upload icons.\"))\n        );\n      } catch (err) {\n        if (err instanceof Error) {\n          setError(err.message);\n        }\n        setLoading(false);\n      }\n    }),\n    [icons, getIconRegistry, enableIconDelete]\n  );\n  const handleItemClick = (0, react_exports.useCallback)(\n    (url) => onClick(url),\n    [onClick]\n  );\n  const search = (0, react_exports.useMemo)(\n    () => /* @__PURE__ */ react_default.createElement(\n      GallerySearch_default,\n      {\n        placeholder: (0, i18n_exports._)(\"Search Icons\"),\n        onSearch: handleSearch\n      }\n    ),\n    [handleSearch]\n  );\n  const message = (0, react_exports.useMemo)(() => {\n    return /* @__PURE__ */ react_default.createElement(GalleryMessage_default, { error, warning });\n  }, [error, warning]);\n  return /* @__PURE__ */ react_default.createElement(\n    Gallery_default,\n    {\n      testId: \"icon-gallery\",\n      isLoading: loading || searching,\n      search: enableSearch && !error && icons ? search : null,\n      message,\n      items: icons,\n      Item: IconGalleryItem_default,\n      upload: error || !enableIconUploads ? null : /* @__PURE__ */ react_default.createElement(\n        GalleryUpload_default,\n        {\n          fileTypes: \".svg\",\n          onUpload: handleIconUpload,\n          enableGallerySharingWarning\n        }\n      ),\n      onItemClick: handleItemClick,\n      onItemRemove: enableIconDelete ? handleDelete : void 0,\n      setHasChildModal,\n      galleryType: \"icon\"\n    }\n  );\n};\nvar IconGallery_default = IconGallery;\n\n// src/ImageGalleryItem.tsx\nvar ImageContainer = styled_components_default.div`\n    width: 90px;\n    height: 35px;\n    margin: 8px 5px 0 5px;\n    border-radius: 3px;\n    &:hover {\n        cursor: pointer;\n        background: ${themes_exports.variables.backgroundColorHover};\n    }\n`;\nvar ImageClose = styled_components_default.div`\n    display: flex;\n    visibility: ${(props) => props.selected ? \"visible\" : \"hidden\"};\n    justify-content: flex-end;\n`;\nvar ImageText = styled_components_default.div`\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    text-align: center;\n    color: ${themes_exports.variables.contentColorDefault};\n`;\nvar ImageGalleryItem = ({\n  item,\n  selected = false,\n  onClick = dashboard_utils_exports.noop,\n  onMouseEnter = dashboard_utils_exports.noop,\n  onMouseLeave = dashboard_utils_exports.noop,\n  onRemove = dashboard_utils_exports.noop\n}) => {\n  const { name, url } = item;\n  const handleClick2 = (0, react_exports.useCallback)(() => onClick(item.url), [onClick, item]);\n  const handleMouseEnter = (0, react_exports.useCallback)(\n    () => onMouseEnter(item),\n    [onMouseEnter, item]\n  );\n  const handleMouseLeave = (0, react_exports.useCallback)(\n    () => onMouseLeave(item),\n    [onMouseLeave, item]\n  );\n  const handleDelete = (0, react_exports.useCallback)(\n    (evt) => {\n      evt.stopPropagation();\n      onRemove == null ? void 0 : onRemove(item);\n    },\n    [onRemove, item]\n  );\n  return /* @__PURE__ */ react_default.createElement(\n    ImageContainer,\n    {\n      \"data-test\": \"image-container\",\n      \"data-url\": url,\n      key: url,\n      title: name,\n      onClick: handleClick2,\n      onMouseEnter: handleMouseEnter,\n      onMouseLeave: handleMouseLeave\n    },\n    onRemove && /* @__PURE__ */ react_default.createElement(\n      ImageClose,\n      {\n        selected,\n        \"data-test\": \"image-close\",\n        onClick: handleDelete\n      },\n      /* @__PURE__ */ react_default.createElement(Remove_default, { size: 0.5 })\n    ),\n    /* @__PURE__ */ react_default.createElement(ImageText, { \"data-test\": \"image-name\" }, name)\n  );\n};\nvar ImageGalleryItem_default = ImageGalleryItem;\n\n// src/ImageGallery.tsx\nvar getWarning2 = (images, msg) => {\n  if (Array.isArray(images) && images.length) {\n    return void 0;\n  }\n  return msg;\n};\nvar ImageGallery = ({\n  providerType: initialProviderType,\n  onClick = dashboard_utils_exports.noop,\n  enableSearch = true,\n  setHasChildModal\n}) => {\n  const [images, setImages] = (0, react_exports.useState)([]);\n  const [providerType, setProviderType] = (0, react_exports.useState)(initialProviderType);\n  const [loading, setLoading] = (0, react_exports.useState)(true);\n  const [searching, setSearching] = (0, react_exports.useState)(false);\n  const [error, setError] = (0, react_exports.useState)();\n  const [warning, setWarning] = (0, react_exports.useState)();\n  const imageRegistry = (0, dashboard_context_exports.useImageRegistry)();\n  const getImageRegistry = (0, react_exports.useCallback)(() => {\n    if (!imageRegistry) {\n      throw new Error((0, i18n_exports._)(\"No image registry found\"));\n    }\n    return imageRegistry;\n  }, [imageRegistry]);\n  (0, react_exports.useEffect)(() => {\n    if (!providerType) {\n      try {\n        const provider = getImageRegistry().listProviders().find((type) => type.isDefault);\n        if (!provider) {\n          throw new Error(\"No image providers found\");\n        }\n        setProviderType(provider.type);\n      } catch (err) {\n        if (err instanceof Error) {\n          setError(err.message);\n        }\n      }\n    }\n  }, [providerType, getImageRegistry]);\n  const getImagesFromAllProviders = (0, react_exports.useCallback)(\n    (options) => __async(void 0, null, function* () {\n      const registry = getImageRegistry();\n      const providers = registry.listProviders();\n      const imageLists = yield Promise.all(\n        providers.map((provider) => __async(void 0, null, function* () {\n          const { type } = provider;\n          const ids = yield registry.listIds(type, __spreadProps(__spreadValues({}, options), {\n            meta: [\"name\"]\n          }));\n          return ids.map((id) => __spreadProps(__spreadValues({}, id), { providerType: type }));\n        }))\n      );\n      return imageLists.reduce(\n        (imageList, currentList) => imageList.concat(currentList),\n        []\n      );\n    }),\n    [getImageRegistry]\n  );\n  const fetchImages = (0, react_exports.useCallback)(() => __async(void 0, null, function* () {\n    if (!providerType) {\n      setLoading(false);\n      return;\n    }\n    try {\n      const ids = yield getImagesFromAllProviders();\n      const newImages = ids.map((idObj) => ({\n        url: `${idObj.providerType}://${idObj.id}`,\n        name: idObj.metaData.name ? idObj.metaData.name.split(\".\")[0] : (0, i18n_exports._)(\"Unnamed image\")\n      }));\n      setImages((0, lodash_exports.sortBy)(newImages, [\"name\"]));\n      setError(void 0);\n      setLoading(false);\n      setWarning(\n        getWarning2(newImages, (0, i18n_exports._)(\"No images. Please upload images.\"))\n      );\n    } catch (err) {\n      if (err instanceof Error) {\n        setError(err.message);\n      }\n      setLoading(false);\n    }\n  }), [providerType, getImagesFromAllProviders]);\n  (0, react_exports.useEffect)(() => {\n    fetchImages();\n  }, [fetchImages]);\n  const handleImageUpload = (0, react_exports.useCallback)(\n    (files) => {\n      if (!providerType) {\n        return;\n      }\n      setLoading(true);\n      files.forEach((file) => {\n        const fileReader = new FileReader();\n        fileReader.onload = () => __async(void 0, null, function* () {\n          const fileName = file.name;\n          try {\n            const imageURL = yield getImageRegistry().upload(\n              fileReader.result,\n              { name: fileName },\n              providerType\n            );\n            setImages(\n              (currentImages) => (0, lodash_exports.sortBy)(\n                [\n                  ...currentImages,\n                  {\n                    url: imageURL,\n                    name: fileName\n                  }\n                ],\n                [\"name\"]\n              )\n            );\n            setWarning(void 0);\n            setError(void 0);\n            setLoading(false);\n          } catch (err) {\n            if (err instanceof Error) {\n              setError(err.message);\n            }\n            setLoading(false);\n          }\n        });\n        fileReader.readAsDataURL(file);\n      });\n    },\n    [getImageRegistry, providerType]\n  );\n  const handleSearch = (0, react_exports.useCallback)(\n    (searchStr = \"\") => __async(void 0, null, function* () {\n      setSearching(true);\n      try {\n        const ids = yield getImagesFromAllProviders({\n          search: searchStr.trim()\n        });\n        const newImages = ids.map((idObj) => ({\n          url: `${idObj.providerType}://${idObj.id}`,\n          name: idObj.filename ? idObj.filename.split(\".\")[0] : idObj.filename || idObj.metaData.name\n        }));\n        setImages((0, lodash_exports.sortBy)(newImages, [\"name\"]));\n        setError(void 0);\n        setSearching(false);\n        setWarning(getWarning2(newImages, (0, i18n_exports._)(\"No images found.\")));\n      } catch (err) {\n        if (err instanceof Error) {\n          setError(err.message);\n        }\n        setSearching(false);\n      }\n    }),\n    [getImagesFromAllProviders]\n  );\n  const handleDelete = (0, react_exports.useCallback)(\n    (deletedImage) => __async(void 0, null, function* () {\n      setLoading(true);\n      try {\n        yield getImageRegistry().deleteByURL(deletedImage.url);\n        const newImages = images.filter(\n          (image) => image.url !== deletedImage.url\n        );\n        setImages(newImages);\n        setLoading(false);\n        setWarning(\n          getWarning2(newImages, (0, i18n_exports._)(\"No images. Please upload images.\"))\n        );\n      } catch (err) {\n        if (err instanceof Error) {\n          setError(err.message);\n        }\n        setLoading(false);\n      }\n    }),\n    [images, getImageRegistry]\n  );\n  const handleItemClick = (0, react_exports.useCallback)(\n    (url) => onClick(url),\n    [onClick]\n  );\n  const search = (0, react_exports.useMemo)(\n    () => /* @__PURE__ */ react_default.createElement(\n      GallerySearch_default,\n      {\n        placeholder: (0, i18n_exports._)(\"Search Images\"),\n        onSearch: handleSearch\n      }\n    ),\n    [handleSearch]\n  );\n  const message = (0, react_exports.useMemo)(\n    () => /* @__PURE__ */ react_default.createElement(GalleryMessage_default, { error, warning }),\n    [error, warning]\n  );\n  return /* @__PURE__ */ react_default.createElement(\n    Gallery_default,\n    {\n      testId: \"image-gallery\",\n      isLoading: loading || searching,\n      search: enableSearch && !error && images ? search : null,\n      message,\n      items: images,\n      Item: ImageGalleryItem_default,\n      upload: error ? null : /* @__PURE__ */ react_default.createElement(\n        GalleryUpload_default,\n        {\n          fileTypes: \".jpeg,.png,.gif\",\n          onUpload: handleImageUpload\n        }\n      ),\n      onItemClick: handleItemClick,\n      onItemRemove: handleDelete,\n      setHasChildModal,\n      galleryType: \"image\"\n    }\n  );\n};\nvar ImageGallery_default = ImageGallery;\n\n// src/InlineCode.tsx\nvar StyledInlineCode = styled_components_default.span`\n    word-break: ${(props) => props.wordBreak};\n    color: ${(0, themes_exports.pick)({\n  enterprise: {\n    light: themes_exports.variables.white,\n    dark: themes_exports.variables.gray30\n  },\n  prisma: themes_exports.variables.contentColorDefault\n})};\n    background-color: ${(0, themes_exports.pick)({\n  enterprise: {\n    dark: themes_exports.variables.gray92,\n    light: themes_exports.variables.gray22\n  },\n  prisma: themes_exports.variables.neutral200\n})};\n    font-family: ${themes_exports.variables.monoFontFamily};\n`;\nvar InlineCode = ({\n  text,\n  wordBreak = \"break-all\"\n}) => /* @__PURE__ */ react_default.createElement(StyledInlineCode, { wordBreak }, text);\n\n// esm-externals:@splunk/react-icons/Cross\nvar Cross_exports = {};\n__export(Cross_exports, {\n  default: () => Cross_default\n});\nvar defaultImport44 = __toESM(require(\"@splunk/react-icons/Cross\"));\n__reExport(Cross_exports, require(\"@splunk/react-icons/Cross\"));\nvar Cross_default = \"default\" in defaultImport44 ? defaultImport44.default : defaultImport44;\n\n// esm-externals:@splunk/react-ui/ScreenReaderContent\nvar ScreenReaderContent_exports = {};\n__export(ScreenReaderContent_exports, {\n  default: () => ScreenReaderContent_default\n});\nvar defaultImport45 = __toESM(require(\"@splunk/react-ui/ScreenReaderContent\"));\n__reExport(ScreenReaderContent_exports, require(\"@splunk/react-ui/ScreenReaderContent\"));\nvar ScreenReaderContent_default = \"default\" in defaultImport45 ? defaultImport45.default : defaultImport45;\n\n// src/utils/colorUtils.ts\nvar isColor = (strColor) => {\n  if (typeof strColor !== \"string\") {\n    return false;\n  }\n  const s = new Option().style;\n  s.color = strColor.toLowerCase();\n  return s.color !== \"\";\n};\nvar sanitizeColor = (color) => isColor(color) ? color : null;\n\n// src/utils/getIconStatus.ts\nvar getIconStatus = (dataSource) => {\n  var _a, _b, _c, _d, _e;\n  if (!dataSource) {\n    return null;\n  }\n  const status = (dataSource == null ? void 0 : dataSource.error) ? \"failed\" : ((_a = dataSource == null ? void 0 : dataSource.meta) == null ? void 0 : _a.status) || \"queued\";\n  if (((_d = (_c = (_b = dataSource == null ? void 0 : dataSource.meta) == null ? void 0 : _b.serverLog) == null ? void 0 : _c[0]) == null ? void 0 : _d.level) === \"WARN\") {\n    return \"warning\";\n  }\n  switch (status) {\n    case \"queued\":\n    case \"parsing\":\n    case \"running\":\n    case \"finalizing\":\n    case \"refreshing\":\n      return \"ok\";\n    case \"pause\":\n      return \"warning\";\n    case \"failed\":\n      return \"error\";\n    case \"done\":\n      return ((_e = dataSource.meta) == null ? void 0 : _e.totalCount) === 0 ? \"warning\" : null;\n    case \"canceled\":\n    default:\n      return null;\n  }\n};\n\n// src/utils/namedColors.ts\nvar namedColors_default = [\n  \"transparent\",\n  \"aliceblue\",\n  \"antiquewhite\",\n  \"aqua\",\n  \"aquamarine\",\n  \"azure\",\n  \"beige\",\n  \"bisque\",\n  \"black\",\n  \"blanchedalmond\",\n  \"blue\",\n  \"blueviolet\",\n  \"brown\",\n  \"burlywood\",\n  \"cadetblue\",\n  \"chartreuse\",\n  \"chocolate\",\n  \"coral\",\n  \"cornflowerblue\",\n  \"cornsilk\",\n  \"crimson\",\n  \"cyan\",\n  \"darkblue\",\n  \"darkcyan\",\n  \"darkgoldenrod\",\n  \"darkgray\",\n  \"darkgreen\",\n  \"darkgrey\",\n  \"darkkhaki\",\n  \"darkmagenta\",\n  \"darkolivegreen\",\n  \"darkorange\",\n  \"darkorchid\",\n  \"darkred\",\n  \"darksalmon\",\n  \"darkseagreen\",\n  \"darkslateblue\",\n  \"darkslategray\",\n  \"darkslategrey\",\n  \"darkturquoise\",\n  \"darkviolet\",\n  \"deeppink\",\n  \"deepskyblue\",\n  \"dimgray\",\n  \"dimgrey\",\n  \"dodgerblue\",\n  \"firebrick\",\n  \"floralwhite\",\n  \"forestgreen\",\n  \"fuchsia\",\n  \"gainsboro\",\n  \"ghostwhite\",\n  \"gold\",\n  \"goldenrod\",\n  \"gray\",\n  \"green\",\n  \"greenyellow\",\n  \"grey\",\n  \"honeydew\",\n  \"hotpink\",\n  \"indianred\",\n  \"indigo\",\n  \"ivory\",\n  \"khaki\",\n  \"lavender\",\n  \"lavenderblush\",\n  \"lawngreen\",\n  \"lemonchiffon\",\n  \"lightblue\",\n  \"lightcoral\",\n  \"lightcyan\",\n  \"lightgoldenrodyellow\",\n  \"lightgray\",\n  \"lightgreen\",\n  \"lightgrey\",\n  \"lightpink\",\n  \"lightsalmon\",\n  \"lightseagreen\",\n  \"lightskyblue\",\n  \"lightslategray\",\n  \"lightslategrey\",\n  \"lightsteelblue\",\n  \"lightyellow\",\n  \"lime\",\n  \"limegreen\",\n  \"linen\",\n  \"magenta\",\n  \"maroon\",\n  \"mediumaquamarine\",\n  \"mediumblue\",\n  \"mediumorchid\",\n  \"mediumpurple\",\n  \"mediumseagreen\",\n  \"mediumslateblue\",\n  \"mediumspringgreen\",\n  \"mediumturquoise\",\n  \"mediumvioletred\",\n  \"midnightblue\",\n  \"mintcream\",\n  \"mistyrose\",\n  \"moccasin\",\n  \"navajowhite\",\n  \"navy\",\n  \"oldlace\",\n  \"olive\",\n  \"olivedrab\",\n  \"orange\",\n  \"orangered\",\n  \"orchid\",\n  \"palegoldenrod\",\n  \"palegreen\",\n  \"paleturquoise\",\n  \"palevioletred\",\n  \"papayawhip\",\n  \"peachpuff\",\n  \"peru\",\n  \"pink\",\n  \"plum\",\n  \"powderblue\",\n  \"purple\",\n  \"rebeccapurple\",\n  \"red\",\n  \"rosybrown\",\n  \"royalblue\",\n  \"saddlebrown\",\n  \"salmon\",\n  \"sandybrown\",\n  \"seagreen\",\n  \"seashell\",\n  \"sienna\",\n  \"silver\",\n  \"skyblue\",\n  \"slateblue\",\n  \"slategray\",\n  \"slategrey\",\n  \"snow\",\n  \"springgreen\",\n  \"steelblue\",\n  \"tan\",\n  \"teal\",\n  \"thistle\",\n  \"tomato\",\n  \"turquoise\",\n  \"violet\",\n  \"wheat\",\n  \"white\",\n  \"whitesmoke\",\n  \"yellow\",\n  \"yellowgreen\"\n];\n\n// src/utils/textUtils.ts\nvar getInflection = (amount, singular, plural, none = \"\") => {\n  let text = none;\n  if (amount === 1) {\n    text = `${amount} ${singular}`;\n  } else if (amount > 1) {\n    text = `${amount} ${plural}`;\n  }\n  return text;\n};\nvar getWarningTextForDataSource = (numViz, numChainSearch, numInputsInUse = 0) => {\n  const vizText = getInflection(\n    numViz,\n    (0, i18n_exports._)(\"visualization\"),\n    (0, i18n_exports._)(\"visualizations\")\n  );\n  const chainSearchText = getInflection(\n    numChainSearch,\n    (0, i18n_exports._)(\"chain search\"),\n    (0, i18n_exports._)(\"chain searches\")\n  );\n  const inputText = getInflection(numInputsInUse, (0, i18n_exports._)(\"input\"), (0, i18n_exports._)(\"inputs\"));\n  return { vizText, chainSearchText, inputText };\n};\n\n// src/InputTitle/InputTitle.tsx\nvar InputRemoveIcon = /* @__PURE__ */ react_default.createElement(react_default.Fragment, null, /* @__PURE__ */ react_default.createElement(Cross_default, { width: 11, height: 11 }), /* @__PURE__ */ react_default.createElement(ScreenReaderContent_default, null, (0, i18n_exports._)(\"Delete input\")));\nvar Spacer = styled_components_default.div`\n    display: flex;\n    flex-grow: 1;\n`;\nvar InputTitleRemoveContainer = styled_components_default.div.attrs({\n  \"data-test\": \"input-title-remove-container\"\n})`\n    display: flex;\n    margin-bottom: 4px;\n    align-items: center;\n`;\nvar InputTitleContainer = styled_components_default.div.attrs({\n  \"data-test\": \"input-title\"\n})`\n    display: flex;\n    align-items: center;\n    overflow: hidden;\n    white-space: nowrap;\n    font-size: 13px;\n    cursor: default;\n    color: ${themes_exports.variables.contentColorActive};\n    color: ${(props) => {\n  var _a, _b, _c, _d;\n  return ((_b = (_a = props.containerOptions) == null ? void 0 : _a.title) == null ? void 0 : _b.color) ? sanitizeColor((_d = (_c = props.containerOptions) == null ? void 0 : _c.title) == null ? void 0 : _d.color) : themes_exports.variables.contentColorActive;\n}};\n    min-height: ${themes_exports.variables.lineHeight};\n    flex-grow: 0;\n`;\nvar InputTitleText = styled_components_default.div`\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    min-width: 0;\n`;\nvar InputRemove = styled_components_default.div.attrs({\n  \"data-test\": \"input-remove\"\n})`\n    height: 16px;\n    margin-left: 8px;\n    visibility: ${(props) => props.isSelected ? \"visible\" : \"hidden\"};\n    color: ${themes_exports.variables.contentColorMuted};\n    &:hover {\n        cursor: pointer;\n    }\n    display: flex;\n    align-items: center;\n    flex-direction: row-reverse;\n    flex-grow: 0;\n`;\nvar InputTitle = ({\n  title,\n  containerOptions,\n  isSelected,\n  StatusIcon = null,\n  handleRemove\n}) => /* @__PURE__ */ react_default.createElement(InputTitleRemoveContainer, null, /* @__PURE__ */ react_default.createElement(InputTitleContainer, { title, containerOptions }, /* @__PURE__ */ react_default.createElement(InputTitleText, null, title)), StatusIcon, /* @__PURE__ */ react_default.createElement(Spacer, null), !!handleRemove && /* @__PURE__ */ react_default.createElement(InputRemove, { onClick: handleRemove, isSelected }, InputRemoveIcon));\n\n// src/LoadingIndicator.tsx\nvar WaitSpinnerContainer = styled_components_default.div`\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    font-size: 15px;\n`;\nvar LoadingIndicator = () => /* @__PURE__ */ react_default.createElement(WaitSpinnerContainer, { \"data-test\": \"loading-indicators\" }, /* @__PURE__ */ react_default.createElement(WaitSpinner_default, { size: \"medium\" }));\nLoadingIndicator.propTypes = {};\nLoadingIndicator.defaultProps = {};\nvar LoadingIndicator_default = LoadingIndicator;\n\n// src/PaddedContainer.tsx\nvar PaddedContainer = styled_components_default.div`\n    // top & bottom padding\n    padding-block: ${(0, themes_exports.pick)({\n  enterprise: themes_exports.variables.spacingMedium,\n  prisma: {\n    compact: themes_exports.variables.spacingMedium,\n    comfortable: themes_exports.variables.spacingLarge\n  }\n})};\n    // left & right padding\n    padding-inline: ${(0, themes_exports.pick)({\n  enterprise: themes_exports.variables.spacingMedium,\n  prisma: themes_exports.variables.spacingLarge\n})};\n    // first child should have same top padding as sides\n    &:first-child {\n        padding-top: ${(0, themes_exports.pick)({\n  enterprise: themes_exports.variables.spacingMedium,\n  prisma: themes_exports.variables.spacingLarge\n})};\n    }\n    // last child should have same bottom padding as sides\n    &:last-child {\n        padding-bottom: ${(0, themes_exports.pick)({\n  enterprise: themes_exports.variables.spacingMedium,\n  prisma: themes_exports.variables.spacingLarge\n})};\n    }\n`;\n\n// src/Option.tsx\nvar OptionContainer = PaddedContainer;\nvar OptionLabel = styled_components_default.div`\n    padding-bottom: ${themes_exports.variables.spacingXSmall};\n    font-weight: ${themes_exports.variables.fontWeightSemiBold};\n    font-size: ${themes_exports.variables.fontSize};\n    display: flex;\n    justify-content: space-between;\n`;\nvar OptionContent = styled_components_default.div``;\nvar Option2 = ({\n  label,\n  children,\n  depends = () => true,\n  \"data-test\": dataTestId\n}) => {\n  if (!depends()) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(PaddedContainer, { \"data-test\": \"option\", \"data-test-id\": dataTestId }, /* @__PURE__ */ react_default.createElement(OptionLabel, { \"data-test\": \"option-label\" }, label), /* @__PURE__ */ react_default.createElement(OptionContent, { \"data-test\": \"option-content\" }, children));\n};\n\n// src/OptionGroup.tsx\nvar Group = styled_components_default.div`\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n`;\nvar OptionGroup = ({ children }) => /* @__PURE__ */ react_default.createElement(Group, { \"data-test\": \"option-group\" }, children);\nvar OptionGroup_default = OptionGroup;\n\n// esm-externals:@splunk/react-ui/Popover\nvar Popover_exports = {};\n__export(Popover_exports, {\n  default: () => Popover_default\n});\nvar defaultImport46 = __toESM(require(\"@splunk/react-ui/Popover\"));\n__reExport(Popover_exports, require(\"@splunk/react-ui/Popover\"));\nvar Popover_default = \"default\" in defaultImport46 ? defaultImport46.default : defaultImport46;\n\n// esm-externals:@splunk/react-icons/enterprise/Warning\nvar Warning_exports = {};\n__export(Warning_exports, {\n  default: () => Warning_default\n});\nvar defaultImport47 = __toESM(require(\"@splunk/react-icons/enterprise/Warning\"));\n__reExport(Warning_exports, require(\"@splunk/react-icons/enterprise/Warning\"));\nvar Warning_default = \"default\" in defaultImport47 ? defaultImport47.default : defaultImport47;\n\n// esm-externals:@splunk/react-icons/enterprise/Error\nvar Error_exports = {};\n__export(Error_exports, {\n  default: () => Error_default\n});\nvar defaultImport48 = __toESM(require(\"@splunk/react-icons/enterprise/Error\"));\n__reExport(Error_exports, require(\"@splunk/react-icons/enterprise/Error\"));\nvar Error_default = \"default\" in defaultImport48 ? defaultImport48.default : defaultImport48;\n\n// src/SimpleStatusIcon.tsx\nvar types = [\"error\", \"ok\", \"warning\"];\nvar statusMap = {\n  error: {\n    icon: Error_default,\n    color: \"statusColorHigh\"\n  },\n  ok: { icon: dashboard_icons_exports.StatusOk, color: \"statusColorInfo\" },\n  warning: {\n    icon: Warning_default,\n    color: \"statusColorMedium\"\n  }\n};\nvar ClickableIcon = styled_components_default(Clickable_default)`\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`;\nvar IconContainer2 = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"simple-status-icon-container\"\n}))`\n    height: ${({ height }) => height}px;\n    width: ${({ width }) => width}px;\n    // padding to increase the hover area on the icon to show tooltip\n    padding: 0 12px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    svg {\n        height: ${({ iconSize }) => iconSize}px;\n        width: ${({ iconSize }) => iconSize}px;\n    }\n\n    // Increase SVG size when this component is hovered over or has keyboard focus\n    &:hover svg,\n    *:focus > & svg {\n        height: ${({ iconSizeOnHover }) => iconSizeOnHover}px;\n        width: ${({ iconSizeOnHover }) => iconSizeOnHover}px;\n    }\n    color: ${({ colorKey }) => themes_exports.variables[colorKey]};\n    cursor: ${({ clickable }) => clickable ? \"pointer\" : \"auto\"};\n`;\nvar SimpleStatusIcon = ({\n  status,\n  height = 24,\n  iconSize = 13,\n  iconSizeOnHover = 15,\n  onClick,\n  elementRef\n}) => {\n  if (!status || !types.includes(status)) {\n    return null;\n  }\n  const Icon3 = statusMap[status].icon;\n  const clickable = typeof onClick === \"function\";\n  const ContainedIcon = /* @__PURE__ */ react_default.createElement(\n    IconContainer2,\n    {\n      height,\n      width: iconSizeOnHover,\n      iconSize,\n      iconSizeOnHover: clickable ? iconSizeOnHover : iconSize,\n      colorKey: statusMap[status].color,\n      clickable\n    },\n    /* @__PURE__ */ react_default.createElement(Icon3, { hideDefaultTooltip: true })\n  );\n  return clickable ? /* @__PURE__ */ react_default.createElement(ClickableIcon, { onClick, tabIndex: 0, elementRef }, ContainedIcon) : ContainedIcon;\n};\nvar SimpleStatusIcon_default = SimpleStatusIcon;\n\n// src/PopoverStatusIcon.tsx\nvar PopoverStatusIcon = ({\n  status,\n  height,\n  iconSize,\n  iconSizeOnHover,\n  open,\n  anchor,\n  onRequestOpen,\n  onRequestClose,\n  children,\n  hasContent\n}) => {\n  const internalAnchor = (0, react_exports.useRef)(null);\n  const setAnchor = (0, react_exports.useCallback)(\n    (element) => {\n      if (anchor) {\n        anchor.current = element;\n      }\n      internalAnchor.current = element;\n    },\n    [anchor]\n  );\n  if (!status) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(react_default.Fragment, null, /* @__PURE__ */ react_default.createElement(\n    SimpleStatusIcon_default,\n    {\n      elementRef: setAnchor,\n      status,\n      height,\n      iconSize,\n      iconSizeOnHover,\n      onClick: hasContent ? onRequestOpen : null\n    }\n  ), hasContent && /* @__PURE__ */ react_default.createElement(\n    Popover_default,\n    {\n      open,\n      anchor: internalAnchor.current,\n      onRequestClose,\n      takeFocus: true,\n      defaultPlacement: \"below\"\n    },\n    children\n  ));\n};\nvar PopoverStatusIcon_default = PopoverStatusIcon;\n\n// esm-externals:@splunk/react-ui/Switch\nvar Switch_exports = {};\n__export(Switch_exports, {\n  default: () => Switch_default\n});\nvar defaultImport49 = __toESM(require(\"@splunk/react-ui/Switch\"));\n__reExport(Switch_exports, require(\"@splunk/react-ui/Switch\"));\nvar Switch_default = \"default\" in defaultImport49 ? defaultImport49.default : defaultImport49;\n\n// src/ProtectedUrlModal/constants.ts\nvar StyledSwitch = styled_components_default(Switch_default)`\n    float: left;\n`;\nvar StyledUrl = styled_components_default.span`\n    word-break: break-word;\n`;\nvar redirectionStyle = {\n  fontWeight: 500,\n  marginBottom: 0\n};\nvar noteStyle = {\n  fontSize: \"12px\",\n  maxWidth: \"500px\"\n};\nvar TEXT = {\n  TITLE: (0, i18n_exports._)(\"Redirecting away from Splunk\"),\n  INVALID_TITLE: (0, i18n_exports._)(\"Invalid URL\"),\n  CONTINUE: (0, i18n_exports._)(\"Continue\"),\n  CANCEL: (0, i18n_exports._)(\"Cancel\"),\n  CLOSE: (0, i18n_exports._)(\"Close\"),\n  ALLOW_AND_DONT_ASK: (0, i18n_exports._)(\"Don't show this again\"),\n  ALLOW_AND_DONT_ASK_NOTE: (0, i18n_exports._)(\n    \"Applies to your current session for this URL domain and parameters.\"\n  ),\n  REDIRECTION: (0, i18n_exports._)(\"You are being redirected away from Splunk to:\"),\n  INVALID_REDIRECTION: (0, i18n_exports._)(\"You cannot redirect away from Splunk to:\"),\n  INVALID_NOTE: (0, i18n_exports._)(\n    \"The URL you clicked cannot open as it is invalid and might contain malicious code. Change the URL to a relative or absolute URL, such as /app/search/datasets or https://www.splunk.com.\"\n  ),\n  NOTE: (0, i18n_exports._)(\n    \"Note that tokens embedded in a URL could contain sensitive information.\"\n  )\n};\n\n// src/ProtectedUrlModal/InvalidUrlModal.tsx\nvar InvalidUrlModal = (_a) => {\n  var _b = _a, {\n    url,\n    onRequestClose\n  } = _b, rest = __objRest(_b, [\n    \"url\",\n    \"onRequestClose\"\n  ]);\n  return /* @__PURE__ */ react_default.createElement(\n    Modal_default,\n    __spreadValues({\n      onRequestClose,\n      open: !!url,\n      divider: \"none\"\n    }, rest),\n    /* @__PURE__ */ react_default.createElement(\n      Modal_default.Header,\n      {\n        title: TEXT.INVALID_TITLE,\n        onRequestClose\n      }\n    ),\n    /* @__PURE__ */ react_default.createElement(Modal_default.Body, null, /* @__PURE__ */ react_default.createElement(StyledUrl, null, /* @__PURE__ */ react_default.createElement(Paragraph_default, { style: redirectionStyle }, TEXT.INVALID_REDIRECTION), /* @__PURE__ */ react_default.createElement(Paragraph_default, null, url), /* @__PURE__ */ react_default.createElement(Paragraph_default, { style: noteStyle }, TEXT.INVALID_NOTE))),\n    /* @__PURE__ */ react_default.createElement(Modal_default.Footer, null, /* @__PURE__ */ react_default.createElement(\n      Button_default,\n      {\n        appearance: \"primary\",\n        onClick: onRequestClose,\n        label: TEXT.CLOSE\n      }\n    ))\n  );\n};\n\n// src/ProtectedUrlModal/ValidUrlModal.tsx\nvar ValidUrlModal = (_a) => {\n  var _b = _a, {\n    url,\n    newTab,\n    onRequestClose,\n    onAddUrlToAllowList\n  } = _b, rest = __objRest(_b, [\n    \"url\",\n    \"newTab\",\n    \"onRequestClose\",\n    \"onAddUrlToAllowList\"\n  ]);\n  const [isDontAskChecked, setIsDontAskChecked] = (0, react_exports.useState)(false);\n  const handleClose = (0, react_exports.useCallback)(() => {\n    onRequestClose == null ? void 0 : onRequestClose();\n  }, [onRequestClose]);\n  const handleAllow = (0, react_exports.useCallback)(() => {\n    if (url) {\n      if (isDontAskChecked) {\n        onAddUrlToAllowList == null ? void 0 : onAddUrlToAllowList(url);\n      }\n      (0, dashboard_utils_exports.navigateToUrl)(url, newTab);\n    }\n    handleClose();\n  }, [url, newTab, isDontAskChecked, handleClose, onAddUrlToAllowList]);\n  const handleDontAsk = (0, react_exports.useCallback)(\n    (_e, { selected }) => {\n      setIsDontAskChecked(!selected);\n    },\n    []\n  );\n  return /* @__PURE__ */ react_default.createElement(\n    Modal_default,\n    __spreadValues({\n      onRequestClose: handleClose,\n      open: !!url,\n      divider: \"none\"\n    }, rest),\n    /* @__PURE__ */ react_default.createElement(Modal_default.Header, { title: TEXT.TITLE, onRequestClose: handleClose }),\n    /* @__PURE__ */ react_default.createElement(Modal_default.Body, null, /* @__PURE__ */ react_default.createElement(StyledUrl, null, /* @__PURE__ */ react_default.createElement(Paragraph_default, { style: redirectionStyle }, TEXT.REDIRECTION), /* @__PURE__ */ react_default.createElement(Paragraph_default, null, url), /* @__PURE__ */ react_default.createElement(Paragraph_default, { style: noteStyle }, TEXT.NOTE)), typeof onAddUrlToAllowList === \"function\" && /* @__PURE__ */ react_default.createElement(\n      StyledSwitch,\n      {\n        selected: isDontAskChecked,\n        onClick: handleDontAsk,\n        appearance: \"checkbox\",\n        inline: true\n      },\n      /* @__PURE__ */ react_default.createElement(Paragraph_default, null, TEXT.ALLOW_AND_DONT_ASK),\n      /* @__PURE__ */ react_default.createElement(Paragraph_default, { style: noteStyle }, TEXT.ALLOW_AND_DONT_ASK_NOTE)\n    )),\n    /* @__PURE__ */ react_default.createElement(Modal_default.Footer, null, /* @__PURE__ */ react_default.createElement(\n      Button_default,\n      {\n        appearance: \"secondary\",\n        onClick: handleClose,\n        label: TEXT.CANCEL\n      }\n    ), /* @__PURE__ */ react_default.createElement(\n      Button_default,\n      {\n        appearance: \"primary\",\n        onClick: handleAllow,\n        label: TEXT.CONTINUE\n      }\n    ))\n  );\n};\n\n// src/ProtectedUrlModal/ProtectedUrlModal.tsx\nvar ProtectedUrlModal = (_a) => {\n  var _b = _a, {\n    event,\n    onAddUrlToAllowList\n  } = _b, rest = __objRest(_b, [\n    \"event\",\n    \"onAddUrlToAllowList\"\n  ]);\n  const { url, newTab, isInvalidUrl } = event != null ? event : {};\n  return isInvalidUrl ? /* @__PURE__ */ react_default.createElement(InvalidUrlModal, __spreadValues({ url }, rest)) : /* @__PURE__ */ react_default.createElement(\n    ValidUrlModal,\n    __spreadValues({\n      url,\n      newTab,\n      onAddUrlToAllowList\n    }, rest)\n  );\n};\n\n// src/SelectableContainer.tsx\nvar getBorderStyle = ({\n  isSelected,\n  layoutItemType,\n  mode = \"view\",\n  hasDrilldown = false,\n  canBeHidden = false\n}) => {\n  let outlineStyle = \"none\";\n  if (layoutItemType === \"input\" && mode === \"view\" && isSelected) {\n    outlineStyle = \"none\";\n  } else if (isSelected) {\n    outlineStyle = \"selected\";\n  } else if (canBeHidden && mode === \"edit\") {\n    outlineStyle = \"highContrastGray\";\n  } else if (hasDrilldown || mode === \"edit\") {\n    outlineStyle = \"lowContrastGray\";\n  }\n  return outlineStyle;\n};\nvar EnterpriseColorsTree = {\n  dark: themes_exports.variables.borderLightColor,\n  light: themes_exports.variables.borderColor\n};\nvar UnselectedHoverColorTree = {\n  enterprise: EnterpriseColorsTree,\n  prisma: themes_exports.variables.interactiveColorBorderHover\n};\nvar SelectableContainer = styled_components_default.div.attrs(\n  ({ itemId, width, height, outlineStyle, canBeHidden }) => ({\n    \"data-test\": \"select-outline\",\n    \"data-id\": itemId,\n    \"data-outline\": canBeHidden ? \"dashed\" : \"none\",\n    \"data-outline-style\": `${outlineStyle}`,\n    style: {\n      width,\n      height\n    }\n  })\n)`\n    display: flex;\n    flex-flow: column nowrap;\n    position: relative;\n\n    // We position an outline using a pseudo-element absolutely positioned\n    &::after {\n        content: '';\n        position: absolute;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        z-index: ${(props) => props.zIndex};\n        pointer-events: none;\n        cursor: default;\n        outline-style: ${(props) => props.canBeHidden ? \"dashed\" : \"solid\"};\n        outline-offset: ${(props) => props.canBeHidden ? \"-2px\" : \"1px\"};\n        outline-width: 2px;\n        outline-color: ${(0, themes_exports.pickVariant)(\"outlineStyle\", {\n  selected: {\n    enterprise: themes_exports.variables.focusColor,\n    prisma: themes_exports.variables.interactiveColorPrimary\n  },\n  highContrastGray: {\n    enterprise: EnterpriseColorsTree,\n    prisma: themes_exports.variables.interactiveColorBorder\n  },\n  lowContrastGray: \"transparent\",\n  none: \"transparent\"\n})};\n        opacity: ${(0, themes_exports.pickVariant)(\"outlineStyle\", {\n  highContrastGray: 0.7\n})};\n    }\n\n    ${AbsoluteItemContainer}:hover &::after {\n        opacity: 1;\n        outline-color: ${(0, themes_exports.pickVariant)(\"outlineStyle\", {\n  lowContrastGray: UnselectedHoverColorTree,\n  highContrastGray: UnselectedHoverColorTree\n})};\n    }\n\n    // Odd behaviors with pickVariant when :hover is applied to a parent instead\n    // of this component cause it not to recalculate colors\n    ${AbsoluteItemContainer}[data-selected='true']:hover &::after {\n        outline-color: ${(0, themes_exports.pickVariant)(\"outlineStyle\", {\n  selected: {\n    enterprise: themes_exports.variables.focusColor,\n    prisma: themes_exports.variables.interactiveColorPrimary\n  }\n})};\n    }\n`;\n\n// src/Separator.tsx\nvar Separator = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"separator\"\n}))`\n    border-bottom: 1px solid ${customThemeVariables.sidebarPanelBorderColor};\n`;\nvar Separator_default = Separator;\n\n// esm-externals:@splunk/react-ui/CollapsiblePanel\nvar CollapsiblePanel_exports = {};\n__export(CollapsiblePanel_exports, {\n  default: () => CollapsiblePanel_default\n});\nvar defaultImport50 = __toESM(require(\"@splunk/react-ui/CollapsiblePanel\"));\n__reExport(CollapsiblePanel_exports, require(\"@splunk/react-ui/CollapsiblePanel\"));\nvar CollapsiblePanel_default = \"default\" in defaultImport50 ? defaultImport50.default : defaultImport50;\n\n// src/SidebarCollapsiblePanel.tsx\nvar padding = {\n  enterprise: themes_exports.variables.spacingMedium,\n  prisma: themes_exports.variables.spacingLarge\n};\nvar isPadded = styled_components_exports.css`\n    padding: ${(0, themes_exports.pick)(padding)};\n`;\nvar StyledContainer = styled_components_default.div`\n    background-color: ${customThemeVariables.sidebarPanelBackgroundColor};\n    ${(props) => props.padded ? isPadded : \"\"}\n`;\nvar StyledCP = styled_components_default(CollapsiblePanel_default)`\n    border-bottom: solid\n        ${(0, themes_exports.pick)({\n  enterprise: themes_exports.variables.borderColor,\n  prisma: themes_exports.variables.contentColorDisabled\n})};\n\n    border-bottom-width: ${(0, themes_exports.pickVariant)(\"open\", {\n  true: {\n    enterprise: \"1px\",\n    prisma: 0\n  },\n  false: 0\n})};\n`;\nvar SidebarCollapsiblePanel = (_a) => {\n  var _b = _a, {\n    children,\n    padded = true,\n    panelId,\n    defaultOpen\n  } = _b, rest = __objRest(_b, [\n    \"children\",\n    \"padded\",\n    \"panelId\",\n    \"defaultOpen\"\n  ]);\n  var _a2;\n  const { collapsibleState, onCollapsibleOpen, onCollapsibleClose } = (_a2 = (0, dashboard_context_exports.useSidebarContext)()) != null ? _a2 : {};\n  const openState = collapsibleState == null ? void 0 : collapsibleState[panelId];\n  const isOpen = typeof openState === \"undefined\" ? !!defaultOpen : openState;\n  const handleChange = (0, react_exports.useCallback)(\n    (_event, { action }) => {\n      if (action === \"close\") {\n        onCollapsibleClose == null ? void 0 : onCollapsibleClose(panelId);\n      } else {\n        onCollapsibleOpen == null ? void 0 : onCollapsibleOpen(panelId);\n      }\n    },\n    [panelId, onCollapsibleOpen, onCollapsibleClose]\n  );\n  return /* @__PURE__ */ react_default.createElement(\n    StyledCP,\n    __spreadProps(__spreadValues({}, rest), {\n      panelId,\n      open: isOpen,\n      onChange: handleChange,\n      \"data-test-open\": isOpen\n    }),\n    /* @__PURE__ */ react_default.createElement(StyledContainer, { padded }, children)\n  );\n};\n\n// esm-externals:lodash/isFunction\nvar isFunction_exports = {};\n__export(isFunction_exports, {\n  default: () => isFunction_default\n});\nvar defaultImport51 = __toESM(require(\"lodash/isFunction\"));\n__reExport(isFunction_exports, require(\"lodash/isFunction\"));\nvar isFunction_default = \"default\" in defaultImport51 ? defaultImport51.default : defaultImport51;\n\n// esm-externals:resize-observer-polyfill\nvar resize_observer_polyfill_exports = {};\n__export(resize_observer_polyfill_exports, {\n  default: () => resize_observer_polyfill_default\n});\nvar defaultImport52 = __toESM(require(\"resize-observer-polyfill\"));\n__reExport(resize_observer_polyfill_exports, require(\"resize-observer-polyfill\"));\nvar resize_observer_polyfill_default = \"default\" in defaultImport52 ? defaultImport52.default : defaultImport52;\n\n// src/SizeAwareWrapper.tsx\nvar ResizeObserverDiv = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"resize-detector\"\n}))`\n    position: 'absolute';\n    width: 0;\n    height: 0;\n    visibility: 'hidden';\n    display: 'none';\n`;\nvar SizeAwareWrapper = class extends react_exports.PureComponent {\n  constructor(props) {\n    super(props);\n    this.animationFrameID = null;\n    this.el = null;\n    this.getElement = () => (\n      // it listens on the size of its parent element\n      this.el && this.el.parentElement\n    );\n    this.handleResize = (entries) => {\n      entries.forEach((entry) => {\n        const { inlineSize: width, blockSize: height } = entry.borderBoxSize[0];\n        this.animationFrameID = window.requestAnimationFrame(() => {\n          this.setState({ width, height });\n        });\n      });\n    };\n    this.renderChildren = () => {\n      const { width, height } = this.state;\n      const { children = null } = this.props;\n      if (width !== null && height !== null && isFunction_default(children)) {\n        return children({ width, height });\n      }\n      return null;\n    };\n    this.handleRef = (el) => {\n      this.el = el;\n    };\n    this.state = {\n      width: null,\n      height: null\n    };\n    this.animationFrameID = null;\n    this.ro = new resize_observer_polyfill_default(this.handleResize);\n  }\n  componentDidMount() {\n    const resizableElement = this.getElement();\n    if (resizableElement) {\n      this.ro.observe(resizableElement);\n    }\n  }\n  componentWillUnmount() {\n    const resizableElement = this.getElement();\n    if (resizableElement) {\n      this.ro.unobserve(resizableElement);\n    }\n    if (window && this.animationFrameID) {\n      window.cancelAnimationFrame(this.animationFrameID);\n    }\n  }\n  render() {\n    return /* @__PURE__ */ react_default.createElement(react_default.Fragment, null, /* @__PURE__ */ react_default.createElement(ResizeObserverDiv, { key: \"resize-detector\", ref: this.handleRef }), this.renderChildren());\n  }\n};\nvar SizeAwareWrapper_default = SizeAwareWrapper;\n\n// src/SizeWrapper.tsx\nvar SizeWrapper = ({ children }) => {\n  const { enableSSR } = (0, dashboard_context_exports.useFeatureFlags)();\n  return enableSSR ? /* @__PURE__ */ react_default.createElement(ActualSizeWrapper, null, children) : /* @__PURE__ */ react_default.createElement(SizeAwareWrapper_default, null, children);\n};\n\n// src/SubmitButton.tsx\nvar SubmitButton = (_a) => {\n  var _b = _a, {\n    disabled = false,\n    label = (0, i18n_exports._)(\"Submit\"),\n    onClick = dashboard_utils_exports.noop\n  } = _b, rest = __objRest(_b, [\n    \"disabled\",\n    \"label\",\n    \"onClick\"\n  ]);\n  return /* @__PURE__ */ react_default.createElement(\n    Button_default,\n    __spreadProps(__spreadValues({}, rest), {\n      disabled,\n      label,\n      appearance: \"primary\",\n      onClick\n    })\n  );\n};\nvar SubmitButton_default = SubmitButton;\n\n// src/TextEditor.tsx\nvar noop7 = () => void 0;\nvar TextEditor = (_a) => {\n  var _b = _a, {\n    value: initialValue,\n    onValueChange = noop7,\n    uniqKey,\n    \"data-test\": dataTest = \"text-editor\",\n    defaultValue,\n    canClear = true,\n    id\n  } = _b, otherProps = __objRest(_b, [\n    \"value\",\n    \"onValueChange\",\n    \"uniqKey\",\n    \"data-test\",\n    \"defaultValue\",\n    \"canClear\",\n    \"id\"\n  ]);\n  const { onHandleBlur, onHandleChange, onHandleKeyDown, value } = useTextInput({\n    initialValue,\n    handleCommit: onValueChange,\n    uniqKey,\n    defaultValue\n  });\n  return /* @__PURE__ */ react_default.createElement(\n    Text_default,\n    __spreadProps(__spreadValues({}, otherProps), {\n      canClear,\n      value,\n      onBlur: onHandleBlur,\n      onChange: onHandleChange,\n      onKeyDown: onHandleKeyDown,\n      \"data-test\": dataTest,\n      inputId: id\n    })\n  );\n};\nvar TextEditor_default = TextEditor;\n\n// esm-externals:@splunk/react-ui/AnimationToggle\nvar AnimationToggle_exports = {};\n__export(AnimationToggle_exports, {\n  default: () => AnimationToggle_default\n});\nvar defaultImport53 = __toESM(require(\"@splunk/react-ui/AnimationToggle\"));\n__reExport(AnimationToggle_exports, require(\"@splunk/react-ui/AnimationToggle\"));\nvar AnimationToggle_default = \"default\" in defaultImport53 ? defaultImport53.default : defaultImport53;\n\n// esm-externals:@splunk/react-ui/RadioList\nvar RadioList_exports = {};\n__export(RadioList_exports, {\n  default: () => RadioList_default\n});\nvar defaultImport54 = __toESM(require(\"@splunk/react-ui/RadioList\"));\n__reExport(RadioList_exports, require(\"@splunk/react-ui/RadioList\"));\nvar RadioList_default = \"default\" in defaultImport54 ? defaultImport54.default : defaultImport54;\n\n// esm-externals:@splunk/react-ui/Heading\nvar Heading_exports = {};\n__export(Heading_exports, {\n  default: () => Heading_default\n});\nvar defaultImport55 = __toESM(require(\"@splunk/react-ui/Heading\"));\n__reExport(Heading_exports, require(\"@splunk/react-ui/Heading\"));\nvar Heading_default = \"default\" in defaultImport55 ? defaultImport55.default : defaultImport55;\n\n// esm-externals:@splunk/react-ui/Dropdown\nvar Dropdown_exports = {};\n__export(Dropdown_exports, {\n  default: () => Dropdown_default\n});\nvar defaultImport56 = __toESM(require(\"@splunk/react-ui/Dropdown\"));\n__reExport(Dropdown_exports, require(\"@splunk/react-ui/Dropdown\"));\nvar Dropdown_default = \"default\" in defaultImport56 ? defaultImport56.default : defaultImport56;\n\n// src/ThemeMenu.tsx\nvar StyledSectionWrapper = styled_components_default.div`\n    padding: 12px 20px;\n    width: 220px;\n\n    & + & {\n        border-top: 1px solid\n            ${(0, themes_exports.pick)({\n  enterprise: themes_exports.variables.borderColor,\n  prisma: themes_exports.variables.neutral200\n})};\n    }\n`;\nvar StyledButton = styled_components_default(Button_default)`\n    text-transform: capitalize;\n`;\nvar ThemeMenu = ({\n  onToggleAnimation,\n  onChangeThemeFamily,\n  onChangeColorScheme,\n  onChangeDensity\n}) => {\n  const animationToggleContextEnabled = (0, react_exports.useContext)(AnimationToggle_exports.AnimationToggleContext);\n  const { colorScheme, density, family } = useSplunkTheme_default();\n  const handleFamilyChange = (0, react_exports.useCallback)(\n    (_e, { value }) => onChangeThemeFamily == null ? void 0 : onChangeThemeFamily(value),\n    [onChangeThemeFamily]\n  );\n  const handleColorSchemeChange = (0, react_exports.useCallback)(\n    (_e, { value }) => onChangeColorScheme == null ? void 0 : onChangeColorScheme(value),\n    [onChangeColorScheme]\n  );\n  const handleDensityChange = (0, react_exports.useCallback)(\n    (_e, { value }) => onChangeDensity == null ? void 0 : onChangeDensity(value),\n    [onChangeDensity]\n  );\n  const handleAnimationChange = (0, react_exports.useCallback)(\n    (_e, { value }) => onToggleAnimation == null ? void 0 : onToggleAnimation(value),\n    [onToggleAnimation]\n  );\n  const Toggle = (0, react_exports.useMemo)(\n    () => /* @__PURE__ */ react_default.createElement(\n      StyledButton,\n      {\n        isMenu: true,\n        label: `${family} ${colorScheme} ${density}`\n      }\n    ),\n    [family, colorScheme, density]\n  );\n  return /* @__PURE__ */ react_default.createElement(Dropdown_default, { toggle: Toggle }, onChangeThemeFamily && /* @__PURE__ */ react_default.createElement(StyledSectionWrapper, null, /* @__PURE__ */ react_default.createElement(Heading_default, { level: \"ss\" }, \"Theme Family\"), /* @__PURE__ */ react_default.createElement(RadioList_default, { onChange: handleFamilyChange, value: family }, /* @__PURE__ */ react_default.createElement(RadioList_default.Option, { value: \"enterprise\" }, \"Enterprise\"), /* @__PURE__ */ react_default.createElement(RadioList_default.Option, { value: \"prisma\" }, \"Prisma\"))), onChangeColorScheme && /* @__PURE__ */ react_default.createElement(StyledSectionWrapper, null, /* @__PURE__ */ react_default.createElement(Heading_default, { level: \"ss\" }, \"Color Scheme\"), /* @__PURE__ */ react_default.createElement(\n    RadioList_default,\n    {\n      onChange: handleColorSchemeChange,\n      value: colorScheme\n    },\n    /* @__PURE__ */ react_default.createElement(RadioList_default.Option, { value: \"light\" }, \"Light\"),\n    /* @__PURE__ */ react_default.createElement(RadioList_default.Option, { value: \"dark\" }, \"Dark\")\n  )), onChangeDensity && /* @__PURE__ */ react_default.createElement(StyledSectionWrapper, null, /* @__PURE__ */ react_default.createElement(Heading_default, { level: \"ss\" }, \"Density\"), /* @__PURE__ */ react_default.createElement(RadioList_default, { onChange: handleDensityChange, value: density }, /* @__PURE__ */ react_default.createElement(RadioList_default.Option, { value: \"comfortable\" }, \"Comfortable\"), /* @__PURE__ */ react_default.createElement(RadioList_default.Option, { value: \"compact\" }, \"Compact\"))), onToggleAnimation && /* @__PURE__ */ react_default.createElement(StyledSectionWrapper, null, /* @__PURE__ */ react_default.createElement(Heading_default, { level: \"ss\" }, \"Animation\"), /* @__PURE__ */ react_default.createElement(\n    RadioList_default,\n    {\n      onChange: handleAnimationChange,\n      value: animationToggleContextEnabled\n    },\n    /* @__PURE__ */ react_default.createElement(RadioList_default.Option, { value: true }, \"Enabled\"),\n    /* @__PURE__ */ react_default.createElement(RadioList_default.Option, { value: false }, \"Disabled\")\n  )));\n};\n\n// esm-externals:@splunk/react-ui/Progress\nvar Progress_exports = {};\n__export(Progress_exports, {\n  default: () => Progress_default\n});\nvar defaultImport57 = __toESM(require(\"@splunk/react-ui/Progress\"));\n__reExport(Progress_exports, require(\"@splunk/react-ui/Progress\"));\nvar Progress_default = \"default\" in defaultImport57 ? defaultImport57.default : defaultImport57;\n\n// src/VisualizationContent/VisualizationProgressBar.tsx\nvar PROGRESSBAR_HEIGHT = 3;\nvar ProgressBarContainer = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"progress-bar-container\"\n}))`\n    height: ${PROGRESSBAR_HEIGHT}px;\n    background-color: ${(props) => props.backgroundColor || customThemeVariables.vizPanelBackgroundColor};\n    width: 100%;\n    display: block;\n    /* Fix sub-pixel gaps between elements when scaled */\n    box-shadow: 0 1px 1px 0\n        ${(props) => props.backgroundColor || customThemeVariables.vizPanelBackgroundColor};\n`;\nvar VizProgressBar = ({\n  backgroundColor,\n  percentage = 0,\n  hasData = true\n}) => {\n  if (percentage >= 100 || !hasData) {\n    return /* @__PURE__ */ react_default.createElement(ProgressBarContainer, { backgroundColor });\n  }\n  const progressBarPercent = Math.max(percentage, 5);\n  return /* @__PURE__ */ react_default.createElement(ProgressBarContainer, { backgroundColor }, /* @__PURE__ */ react_default.createElement(\n    Progress_default,\n    {\n      percentage: progressBarPercent,\n      tooltip: `${percentage}% complete`\n    }\n  ));\n};\nvar VisualizationProgressBar_default = VizProgressBar;\n\n// src/VisualizationContent/VisualizationTitleAndDescription.tsx\nvar TITLE_CONTAINER_PADDING = 12;\nvar TITLE_HEIGHT = 20;\nvar DESCRIPTION_HEIGHT = 16;\nvar Title2 = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"viz-title\"\n}))`\n    flex-basis: auto;\n    font-size: 14px;\n    font-weight: 600;\n    line-height: ${TITLE_HEIGHT}px;\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    color: ${themes_exports.variables.contentColorActive};\n    color: ${(props) => {\n  var _a, _b, _c, _d;\n  return ((_b = (_a = props.options) == null ? void 0 : _a.title) == null ? void 0 : _b.color) ? sanitizeColor((_d = (_c = props.options) == null ? void 0 : _c.title) == null ? void 0 : _d.color) : themes_exports.variables.contentColorActive;\n}};\n`;\nvar Description3 = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"viz-description\"\n}))`\n    flex-basis: auto;\n    font-size: 12px;\n    line-height: ${DESCRIPTION_HEIGHT}px;\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    color: ${themes_exports.variables.contentColorActive};\n    color: ${(props) => {\n  var _a, _b, _c, _d;\n  return ((_b = (_a = props.options) == null ? void 0 : _a.description) == null ? void 0 : _b.color) ? sanitizeColor((_d = (_c = props.options) == null ? void 0 : _c.description) == null ? void 0 : _d.color) : themes_exports.variables.contentColorActive;\n}};\n    opacity: ${(0, themes_exports.pick)({\n  enterprise: {\n    light: 0.6,\n    dark: 0.7\n  },\n  prisma: 0.7\n})};\n    /* offset top margin when there is no title so description lines up with other titles */\n    margin-top: ${({ noTitle }) => noTitle ? \"3px\" : \"unset\"};\n`;\nvar Container4 = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"viz-title-description-container\"\n}))`\n    padding: ${TITLE_CONTAINER_PADDING / 2}px 10px;\n    background-color: ${(props) => props.backgroundColor || customThemeVariables.vizPanelBackgroundColor};\n    /* Fix sub-pixel gaps between elements when scaled */\n    box-shadow: 0 1px 1px 0\n        ${(props) => props.backgroundColor || customThemeVariables.vizPanelBackgroundColor};\n    overflow: hidden;\n`;\nvar TextWithStatusAllotment = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"viz-title-description-status-padding\"\n}))`\n    width: calc(100% - 12px);\n`;\nvar defaultContainerOptions = Object.freeze({});\nvar VizTitleAndDescription = ({\n  description,\n  title,\n  backgroundColor,\n  truncateFirstLine,\n  containerOptions = defaultContainerOptions\n}) => {\n  const TitleMemo = (0, react_exports.useMemo)(() => {\n    if (!title) {\n      return null;\n    }\n    if (truncateFirstLine) {\n      return /* @__PURE__ */ react_default.createElement(TextWithStatusAllotment, null, /* @__PURE__ */ react_default.createElement(Title2, null, title));\n    }\n    return /* @__PURE__ */ react_default.createElement(Title2, { options: containerOptions }, title);\n  }, [title, truncateFirstLine, containerOptions]);\n  const DescriptionMemo = (0, react_exports.useMemo)(() => {\n    if (!description) {\n      return null;\n    }\n    if (title || !truncateFirstLine) {\n      return /* @__PURE__ */ react_default.createElement(Description3, { options: containerOptions }, description);\n    }\n    return /* @__PURE__ */ react_default.createElement(TextWithStatusAllotment, null, /* @__PURE__ */ react_default.createElement(Description3, { noTitle: true, options: containerOptions }, description));\n  }, [description, title, truncateFirstLine, containerOptions]);\n  if (!title && !description) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(Container4, { backgroundColor }, TitleMemo, DescriptionMemo);\n};\nvar VisualizationTitleAndDescription_default = VizTitleAndDescription;\n\n// src/VisualizationContent/VisualizationStatusIcon.tsx\nvar statusIconHeight = 20;\nvar StatusIconContainer = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"status-icon-container\"\n}))`\n    height: ${statusIconHeight}px;\n    display: flex;\n    align-items: center;\n    position: absolute;\n    top: 5px;\n    right: -3px;\n\n    // Move the status icon when the progress bar pushes the title/desc/viz\n    ${ProgressBarContainer}:not(:empty) ~ & {\n        top: 8px;\n    }\n\n    &:focus-within svg {\n        outline-style: solid;\n        outline-offset: 1px;\n        outline-width: 2px;\n        outline-color: ${themes_exports.variables.focusColor};\n    }\n`;\nvar VizStatusIcon = ({\n  dataSource,\n  id\n}) => {\n  const anchor = (0, react_exports.useRef)(null);\n  const { open, onRequestOpen, onRequestClose } = usePopoverState({ anchor });\n  const iconStatus = getIconStatus(dataSource);\n  if (!iconStatus) {\n    return null;\n  }\n  const statusMessage = getStatusMessage(dataSource);\n  return /* @__PURE__ */ react_default.createElement(StatusIconContainer, null, /* @__PURE__ */ react_default.createElement(\n    PopoverStatusIcon_default,\n    {\n      height: statusIconHeight,\n      open,\n      onRequestOpen,\n      onRequestClose,\n      status: iconStatus,\n      anchor,\n      hasContent: !!statusMessage\n    },\n    /* @__PURE__ */ react_default.createElement(\n      EnterprisePopoverContentFactory_default,\n      {\n        dataSource,\n        componentId: id,\n        onRequestClose\n      }\n    )\n  ));\n};\nVizStatusIcon.propTypes = {\n  dataSource: prop_types_default.object,\n  id: prop_types_default.string\n};\nvar VisualizationStatusIcon_default = VizStatusIcon;\n\n// src/VisualizationContent/VisualizationContent.tsx\nvar VizWrapper = styled_components_default.div.attrs(({ width, height }) => ({\n  \"data-test\": \"viz-size-wrapper\",\n  style: {\n    width: (0, dashboard_utils_exports.toPx)(width),\n    height: (0, dashboard_utils_exports.toPx)(height)\n  }\n}))``;\nvar empty2 = {};\nvar VisualizationContent = ({\n  id,\n  height,\n  width,\n  dataSources = empty2,\n  visualizationDefinition: vizDef,\n  isFullscreen,\n  computedProps,\n  children\n}) => {\n  var _a, _b, _c, _d, _e;\n  const {\n    title,\n    description,\n    options = empty2,\n    showProgressBar = false,\n    containerOptions\n  } = vizDef;\n  const { backgroundColor } = options;\n  let bgColor = (computedProps == null ? void 0 : computedProps.backgroundColor) || backgroundColor || null;\n  if (bgColor) {\n    bgColor = sanitizeColor(bgColor);\n  }\n  const hasStatusIcon = !!getIconStatus(dataSources.primary);\n  const hasTitle = !!title || !!description;\n  const siblingHeights = (0, react_exports.useMemo)(() => {\n    let h = 0;\n    if (showProgressBar) {\n      h += PROGRESSBAR_HEIGHT;\n    }\n    if (hasTitle) {\n      h += title || description ? TITLE_CONTAINER_PADDING : 0;\n      h += title ? TITLE_HEIGHT : 0;\n      h += description ? DESCRIPTION_HEIGHT : 0;\n    }\n    return h;\n  }, [showProgressBar, hasTitle, title, description]);\n  const containerWidth = (0, react_exports.useMemo)(\n    () => isFullscreen ? \"100vw\" : width,\n    [isFullscreen, width]\n  );\n  const containerHeight = (0, react_exports.useMemo)(\n    () => isFullscreen ? `calc(100vh - ${siblingHeights}px)` : Number(height) - siblingHeights || height,\n    [isFullscreen, siblingHeights, height]\n  );\n  const VizWrapperHeight = Number(containerHeight) || isFullscreen ? containerHeight : `calc(${height} - ${siblingHeights}px)`;\n  let currentProgress = (_c = (_b = (_a = dataSources == null ? void 0 : dataSources.primary) == null ? void 0 : _a.meta) == null ? void 0 : _b.percentComplete) != null ? _c : 0;\n  if ((_e = (_d = dataSources == null ? void 0 : dataSources.primary) == null ? void 0 : _d.error) == null ? void 0 : _e.message) {\n    currentProgress = 100;\n  }\n  const ChildrenWithDimensions = (0, react_exports.useMemo)(\n    () => children && react_default.cloneElement(children, {\n      width: containerWidth,\n      height: containerHeight\n    }),\n    [children, containerWidth, containerHeight]\n  );\n  return /* @__PURE__ */ react_default.createElement(react_default.Fragment, null, showProgressBar && /* @__PURE__ */ react_default.createElement(\n    VisualizationProgressBar_default,\n    {\n      hasData: !!dataSources.primary,\n      percentage: currentProgress,\n      backgroundColor: bgColor\n    }\n  ), /* @__PURE__ */ react_default.createElement(\n    VisualizationTitleAndDescription_default,\n    {\n      title,\n      description,\n      backgroundColor: bgColor,\n      truncateFirstLine: hasStatusIcon,\n      containerOptions\n    }\n  ), /* @__PURE__ */ react_default.createElement(VizWrapper, { width: containerWidth, height: VizWrapperHeight }, ChildrenWithDimensions), /* @__PURE__ */ react_default.createElement(VisualizationStatusIcon_default, { dataSource: dataSources.primary, id }));\n};\nvar VisualizationContent_default = VisualizationContent;\n\n// src/VisualizationFilter.ts\nvar isMatchedCategory = (cat, matcher) => new RegExp(matcher, \"i\").test(cat);\nvar filterVisualizations = (visualizations, label) => visualizations.filter(\n  ({ label: l }) => l && new RegExp(label, \"i\").test(l)\n);\nvar filterByCategory = (categories, category) => {\n  return categories.filter(\n    ({ category: cat }) => isMatchedCategory(cat, category)\n  );\n};\nvar filterByLabel = (categories, label) => {\n  const filteredCategories = [];\n  categories.forEach(({ category: cat, visualizations }) => {\n    const list = visualizations.filter(\n      ({ label: l }) => l && new RegExp(label, \"i\").test(l)\n    );\n    if (list.length) {\n      filteredCategories.push({ category: cat, visualizations: list });\n    }\n  });\n  return filteredCategories;\n};\nvar VisualizationFilter = class {\n  /**\n   * @constructor\n   * @param {Object} preset Hash of dashboard presets\n   * @param {Array} [taxonomy] List of category -> visualizationId mapping [{ category: Foo, visualizations: ['viz.foo'] }]\n   */\n  constructor(preset) {\n    if (!preset || !preset.visualizations) {\n      throw new Error(\"Must provide a valid preset\");\n    }\n    const categoryValues = [...dashboard_context_exports.vizCategories.values()];\n    this.taxonomy = Object.entries(\n      (0, lodash_exports.groupBy)(\n        Object.values(preset.visualizations).map(\n          ({\n            config: { category, key, icon, name } = {},\n            meta,\n            includeInVizSwitcher,\n            includeInToolbar\n          }) => {\n            var _a;\n            return {\n              type: key != null ? key : \"viz.unknown_viz_type\",\n              label: name != null ? name : (0, i18n_exports._)(\"Unknown Viz Type\"),\n              icon: icon != null ? icon : dashboard_icons_exports.AddChartDropdown,\n              initialOptions: (_a = meta == null ? void 0 : meta.initialOptions) != null ? _a : {},\n              category,\n              includeInVizSwitcher,\n              includeInToolbar\n            };\n          }\n        ),\n        \"category\"\n      )\n    ).map(\n      ([category, visualizations]) => ({\n        category,\n        visualizations\n      })\n    ).sort(\n      (catA, catB) => categoryValues.indexOf(catA.category) - categoryValues.indexOf(catB.category)\n    );\n  }\n  /**\n   * Retrieve a filtered taxonomy of visualization metadata\n   * @method getVisualizationList\n   * @param {Object} [searchCriteria] Filter { label, category}\n   * @returns Array of category metadata\n   */\n  getVisualizationList({\n    label,\n    category\n  } = {}) {\n    if (!label && !category) {\n      return this.taxonomy;\n    }\n    if (category && !label) {\n      return filterByCategory(this.taxonomy, category);\n    }\n    if (label && !category) {\n      return filterByLabel(this.taxonomy, label);\n    }\n    const result = [];\n    this.taxonomy.forEach(({ category: cat, visualizations }) => {\n      if (isMatchedCategory(cat, category)) {\n        result.push({ category: cat, visualizations });\n      } else {\n        const filteredViz = filterVisualizations(\n          visualizations,\n          label\n        );\n        if (filteredViz.length) {\n          result.push({ category: cat, visualizations: filteredViz });\n        }\n      }\n    });\n    return result;\n  }\n};\nvar VisualizationFilter_default = VisualizationFilter;\n\n// esm-externals:@splunk/visualization-icons/placeholders\nvar placeholders_exports = {};\n__export(placeholders_exports, {\n  default: () => placeholders_default\n});\nvar defaultImport58 = __toESM(require(\"@splunk/visualization-icons/placeholders\"));\n__reExport(placeholders_exports, require(\"@splunk/visualization-icons/placeholders\"));\nvar placeholders_default = \"default\" in defaultImport58 ? defaultImport58.default : defaultImport58;\n\n// src/VisualizationWaitingForInput/VisualizationWaitingForInput.tsx\nvar maxLengthOfTextMessage = 45;\nvar Container5 = styled_components_default.div.attrs(({ width, height }) => ({\n  \"data-test\": \"viz-waiting-for-input\",\n  style: {\n    width,\n    height\n  }\n}))`\n    background-color: ${(props) => props.backgroundColor || customThemeVariables.vizPanelBackgroundColor};\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: column;\n    overflow: hidden;\n`;\nvar Text = styled_components_default.p.attrs(() => ({\n  \"data-test\": \"viz-waiting-for-input-message\"\n}))`\n    color: ${(0, themes_exports.pick)({\n  enterprise: {\n    light: themes_exports.variables.gray20,\n    dark: themes_exports.variables.gray92\n  },\n  prisma: themes_exports.variables.contentColorDefault\n})};\n    text-overflow: ellipsis;\n    text-align: center;\n    font-size: 14px;\n    margin: 0 50px;\n`;\nvar MessageContainer2 = styled_components_default.div`\n    max-width: 500px;\n    word-break: break-all;\n`;\nvar Message2 = ({ message }) => message.length > maxLengthOfTextMessage ? /* @__PURE__ */ react_default.createElement(Tooltip_default, { content: /* @__PURE__ */ react_default.createElement(MessageContainer2, null, message) }, /* @__PURE__ */ react_default.createElement(Text, null, `${message.slice(0, maxLengthOfTextMessage)}...`)) : /* @__PURE__ */ react_default.createElement(Text, null, message);\nvar StyledPlaceholder = styled_components_default(placeholders_exports.Column).attrs((props) => {\n  const hasAs = typeof props.as !== \"undefined\";\n  return {\n    \"data-test\": `${hasAs ? \"placeholder\" : \"column\"}-icon`\n  };\n})`\n    color: ${themes_exports.variables.contentColorActive};\n    opacity: 0.15;\n    height: ${(props) => props.$height};\n    width: 100%;\n`;\nvar VizWaitingForInput = ({\n  message,\n  backgroundColor,\n  width,\n  height,\n  PlaceholderIcon\n}) => {\n  const pxHeight = (0, react_exports.useMemo)(\n    () => typeof height !== \"undefined\" ? (0, dashboard_utils_exports.toPx)(height) : \"100%\",\n    [height]\n  );\n  const styledPlaceholderProps = (0, react_exports.useMemo)(() => {\n    const calcdHeight = `calc(${pxHeight} * 0.35)`;\n    if (PlaceholderIcon) {\n      return {\n        $height: calcdHeight,\n        as: PlaceholderIcon\n      };\n    }\n    return { $height: calcdHeight };\n  }, [pxHeight, PlaceholderIcon]);\n  return /* @__PURE__ */ react_default.createElement(\n    Container5,\n    {\n      width,\n      height,\n      backgroundColor\n    },\n    /* @__PURE__ */ react_default.createElement(StyledPlaceholder, __spreadValues({}, styledPlaceholderProps)),\n    // don't render text if viz height or width is too small\n    (typeof height !== \"number\" || height > 150) && (typeof width !== \"number\" || width > 80) ? /* @__PURE__ */ react_default.createElement(Message2, { message }) : null\n  );\n};\nVizWaitingForInput.propTypes = {\n  message: prop_types_default.string,\n  backgroundColor: prop_types_default.string,\n  width: prop_types_default.oneOfType([prop_types_default.string, prop_types_default.number]).isRequired,\n  height: prop_types_default.oneOfType([prop_types_default.string, prop_types_default.number]),\n  PlaceholderIcon: prop_types_default.func\n};\nVizWaitingForInput.defaultProps = {\n  message: dashboard_state_exports.WAITING_FOR_INPUT_MSG\n};\nMessage2.propTypes = {\n  message: prop_types_default.string\n};\nvar VisualizationWaitingForInput_default = VizWaitingForInput;\n\n// esm-externals:hoist-non-react-statics\nvar hoist_non_react_statics_exports = {};\n__export(hoist_non_react_statics_exports, {\n  default: () => hoist_non_react_statics_default\n});\nvar defaultImport59 = __toESM(require(\"hoist-non-react-statics\"));\n__reExport(hoist_non_react_statics_exports, require(\"hoist-non-react-statics\"));\nvar hoist_non_react_statics_default = \"default\" in defaultImport59 ? defaultImport59.default : defaultImport59;\n\n// src/withRiskySearchToast.tsx\nvar withRiskySearchToast = (ComponentToWrap) => hoist_non_react_statics_default((_a) => {\n  var _b = _a, { dataSources } = _b, rest = __objRest(_b, [\"dataSources\"]);\n  useRiskySearchToast({ dataSource: dataSources == null ? void 0 : dataSources.primary });\n  return /* @__PURE__ */ react_default.createElement(ComponentToWrap, __spreadProps(__spreadValues({}, rest), { dataSources }));\n}, ComponentToWrap);\nvar mapWithRiskySearchToast = (components) => Object.fromEntries(\n  Object.entries(components).map(([key, value]) => [\n    key,\n    withRiskySearchToast(value)\n  ])\n);\n\n// esm-externals:@splunk/react-ui/Resize\nvar Resize_exports = {};\n__export(Resize_exports, {\n  default: () => Resize_default\n});\nvar defaultImport60 = __toESM(require(\"@splunk/react-ui/Resize\"));\n__reExport(Resize_exports, require(\"@splunk/react-ui/Resize\"));\nvar Resize_default = \"default\" in defaultImport60 ? defaultImport60.default : defaultImport60;\n\n// src/flyout/themeInterpolation.ts\nvar headerHeightInterpolationTree = {\n  enterprise: {\n    compact: 38,\n    comfortable: 42\n  },\n  prisma: {\n    compact: 42,\n    comfortable: 50\n  }\n};\nvar headerPaddingInterpolationTree = {\n  enterprise: {\n    compact: 15,\n    comfortable: 16.25\n  },\n  prisma: {\n    compact: 15.5,\n    comfortable: 17.625\n  }\n};\n\n// esm-externals:@splunk/react-icons/enterprise/ChevronDown\nvar ChevronDown_exports = {};\n__export(ChevronDown_exports, {\n  default: () => ChevronDown_default\n});\nvar defaultImport61 = __toESM(require(\"@splunk/react-icons/enterprise/ChevronDown\"));\n__reExport(ChevronDown_exports, require(\"@splunk/react-icons/enterprise/ChevronDown\"));\nvar ChevronDown_default = \"default\" in defaultImport61 ? defaultImport61.default : defaultImport61;\n\n// esm-externals:@splunk/react-icons/enterprise/ChevronUp\nvar ChevronUp_exports = {};\n__export(ChevronUp_exports, {\n  default: () => ChevronUp_default\n});\nvar defaultImport62 = __toESM(require(\"@splunk/react-icons/enterprise/ChevronUp\"));\n__reExport(ChevronUp_exports, require(\"@splunk/react-icons/enterprise/ChevronUp\"));\nvar ChevronUp_default = \"default\" in defaultImport62 ? defaultImport62.default : defaultImport62;\n\n// src/flyout/FlyoutHeaderButtons.tsx\nvar labels = {\n  close: (0, i18n_exports._)(\"Close Pane\"),\n  collapse: (0, i18n_exports._)(\"Collapse Pane\"),\n  expand: (0, i18n_exports._)(\"Expand Pane\")\n};\nvar ButtonGroup = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"flyout-header-button-group\"\n}))`\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-items: center;\n`;\nvar IconButton = ({ dataTest, icon, tooltip, onClick }) => {\n  const { isPrisma } = (0, themes_exports.useSplunkTheme)();\n  return /* @__PURE__ */ react_default.createElement(\n    Tooltip_default,\n    {\n      contentRelationship: \"label\",\n      content: tooltip,\n      openDelay: \"primary\"\n    },\n    /* @__PURE__ */ react_default.createElement(\n      Button_default,\n      {\n        \"data-test\": dataTest,\n        appearance: isPrisma ? \"secondary\" : \"pill\",\n        icon,\n        onClick\n      }\n    )\n  );\n};\nvar CloseButtonIcon = /* @__PURE__ */ react_default.createElement(Close_default, { screenReaderText: labels.close });\nvar CloseButton2 = ({ onClick }) => /* @__PURE__ */ react_default.createElement(\n  IconButton,\n  {\n    dataTest: \"flyout-header-close-btn\",\n    icon: CloseButtonIcon,\n    tooltip: labels.close,\n    onClick\n  }\n);\nvar CollapseButtonIcon = /* @__PURE__ */ react_default.createElement(ChevronDown_default, { screenReaderText: labels.collapse });\nvar CollapseButton = ({ onClick }) => /* @__PURE__ */ react_default.createElement(\n  IconButton,\n  {\n    dataTest: \"flyout-header-collapse-btn\",\n    icon: CollapseButtonIcon,\n    tooltip: labels.collapse,\n    onClick\n  }\n);\nvar ExpandButtonIcon = /* @__PURE__ */ react_default.createElement(ChevronUp_default, { screenReaderText: labels.expand });\nvar ExpandButton = ({ onClick }) => /* @__PURE__ */ react_default.createElement(\n  IconButton,\n  {\n    dataTest: \"flyout-header-expand-btn\",\n    icon: ExpandButtonIcon,\n    tooltip: labels.expand,\n    onClick\n  }\n);\n\n// src/flyout/FlyoutHeader.tsx\nvar HeaderContainer4 = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"flyout-header-container\"\n}))`\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    justify-content: space-between;\n    padding: 0 24px;\n    height: ${(0, themes_exports.pick)(headerHeightInterpolationTree)}px;\n    color: ${themes_exports.variables.contentColorActive};\n    border-bottom: 1px solid ${customThemeVariables.toolbarBorderColor};\n    background-color: ${customThemeVariables.sidebarPanelBackgroundColor};\n`;\nvar HeaderTitle = styled_components_default.span`\n    font-size: 16px;\n`;\nvar FlyoutHeader = ({\n  collapsible = false,\n  isCollapsed = false,\n  text,\n  toggleExpansion = dashboard_utils_exports.noop,\n  onCloseClick\n}) => {\n  return /* @__PURE__ */ react_default.createElement(HeaderContainer4, null, /* @__PURE__ */ react_default.createElement(HeaderTitle, null, text), /* @__PURE__ */ react_default.createElement(ButtonGroup, null, collapsible && isCollapsed && /* @__PURE__ */ react_default.createElement(ExpandButton, { onClick: toggleExpansion }), collapsible && !isCollapsed && /* @__PURE__ */ react_default.createElement(CollapseButton, { onClick: toggleExpansion }), /* @__PURE__ */ react_default.createElement(CloseButton2, { onClick: onCloseClick })));\n};\n\n// src/flyout/useGetFlyoutHeaderHeight.ts\nvar useGetFlyoutHeaderHeight = () => {\n  const { density, family } = (0, themes_exports.useSplunkTheme)();\n  return headerHeightInterpolationTree[family][density];\n};\n\n// src/flyout/FlyoutPane.tsx\nvar FlyoutContainer = styled_components_default.div.attrs(() => ({\n  \"data-test\": \"flyout-pane\"\n}))`\n    background: ${customThemeVariables.sidebarPanelBackgroundColor};\n    border-top: 1px solid ${customThemeVariables.toolbarBorderColor};\n`;\nvar DisabledFlyoutResizeHandles = [];\nvar FlyoutResizeHandles = [\"n\"];\nvar FlyoutPane = (0, react_exports.forwardRef)(\n  ({\n    children,\n    collapsible = false,\n    collapsed = false,\n    headerText,\n    height,\n    onClose,\n    onResize,\n    onToggleExpansion = dashboard_utils_exports.noop\n  }, ref) => {\n    const headerHeight = useGetFlyoutHeaderHeight();\n    const isCollapsed = collapsible && collapsed;\n    const handlePaneClose = (0, react_exports.useCallback)(() => {\n      onClose();\n    }, [onClose]);\n    const handlePaneResize = (0, react_exports.useCallback)(\n      (_event, { height: newHeight }) => {\n        if (newHeight < headerHeight) {\n          onResize(headerHeight);\n        } else {\n          onResize(newHeight);\n        }\n      },\n      [headerHeight, onResize]\n    );\n    const paneStyle = (0, react_exports.useMemo)(\n      () => ({\n        height: isCollapsed ? headerHeight : height\n      }),\n      [headerHeight, height, isCollapsed]\n    );\n    return /* @__PURE__ */ react_default.createElement(FlyoutContainer, { ref }, /* @__PURE__ */ react_default.createElement(\n      Resize_default,\n      {\n        onRequestResize: handlePaneResize,\n        resizeHandles: (\n          // If collapsed don't allow resizing\n          isCollapsed ? DisabledFlyoutResizeHandles : FlyoutResizeHandles\n        ),\n        appearance: \"overlay\",\n        showHandles: \"on-hover\",\n        style: paneStyle\n      },\n      /* @__PURE__ */ react_default.createElement(\n        FlyoutHeader,\n        {\n          onCloseClick: handlePaneClose,\n          collapsible,\n          isCollapsed,\n          toggleExpansion: onToggleExpansion,\n          text: headerText\n        }\n      ),\n      !isCollapsed && height > headerHeight && children\n    ));\n  }\n);\n\n// src/flyout/useGetFlyoutHeaderPadding.ts\nvar useGetFlyoutHeaderPadding = () => {\n  const { density, family } = (0, themes_exports.useSplunkTheme)();\n  return headerPaddingInterpolationTree[family][density];\n};\n\n// esm-externals:tinycolor2\nvar tinycolor2_exports = {};\n__export(tinycolor2_exports, {\n  default: () => tinycolor2_default\n});\nvar defaultImport63 = __toESM(require(\"tinycolor2\"));\n__reExport(tinycolor2_exports, require(\"tinycolor2\"));\nvar tinycolor2_default = \"default\" in defaultImport63 ? defaultImport63.default : defaultImport63;\n\n// src/mixins/applyTranslucence.ts\nvar applyTranslucence = (color, alpha) => (props) => {\n  var _a;\n  const colorValue = typeof color === \"function\" ? color(props) : color;\n  const colorObj = tinycolor2_default(colorValue);\n  if (alpha > 1) {\n    return colorObj.toRgbString();\n  }\n  if (alpha < 0) {\n    return colorObj.setAlpha(0).toRgbString();\n  }\n  const origAlpha = (_a = colorObj.getAlpha()) != null ? _a : 1;\n  return colorObj.setAlpha(alpha * origAlpha).toRgbString();\n};\n\n// src/CheckboxEditor.tsx\nvar Container6 = styled_components_default.div`\n    display: flex;\n    flex-direction: row;\n    width: 100%;\n    justify-content: flex-start;\n    align-items: center;\n`;\nvar PaddedSwitch = styled_components_default(Switch_default)`\n    padding-right: ${(0, themes_exports.pick)({\n  enterprise: \"12px\"\n})};\n`;\nvar CheckboxEditor = ({\n  onChange,\n  label,\n  checked = false,\n  tooltipContent = null,\n  dataTest\n}) => {\n  return /* @__PURE__ */ react_default.createElement(Container6, { \"data-test\": dataTest }, /* @__PURE__ */ react_default.createElement(\n    PaddedSwitch,\n    {\n      onClick: onChange,\n      appearance: \"checkbox\",\n      selected: checked,\n      inline: true\n    },\n    !!label && label\n  ), !!tooltipContent && /* @__PURE__ */ react_default.createElement(\n    Tooltip_default,\n    {\n      openDelay: 100,\n      closeDelay: 500,\n      content: tooltipContent,\n      inline: true\n    }\n  ));\n};\n\n// esm-externals:@splunk/react-ui/Menu\nvar Menu_exports = {};\n__export(Menu_exports, {\n  default: () => Menu_default\n});\nvar defaultImport64 = __toESM(require(\"@splunk/react-ui/Menu\"));\n__reExport(Menu_exports, require(\"@splunk/react-ui/Menu\"));\nvar Menu_default = \"default\" in defaultImport64 ? defaultImport64.default : defaultImport64;\n\n// src/TabListMenu.tsx\nvar menuStyle = { width: 240, maxHeight: 650 };\nvar prismaHeadingStyle = { margin: \"-7px 0px\" };\nvar TabListMenu = ({\n  open,\n  onRequestClose,\n  anchor,\n  onSelectTab,\n  showActiveTab = false,\n  heading\n}) => {\n  const tabs = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectTabs);\n  const activeTab = (0, dashboard_state_exports.useSelector)(dashboard_state_exports.selectActiveTab);\n  const { family } = (0, themes_exports.useSplunkTheme)();\n  const headingStyle = family === \"prisma\" ? prismaHeadingStyle : void 0;\n  const onBlur = usePopoverBlurCallback_default(onRequestClose);\n  const handleClickGenerator = (0, react_exports.useCallback)(\n    (layoutId) => () => onSelectTab(layoutId),\n    [onSelectTab]\n  );\n  const menuItems = (0, react_exports.useMemo)(() => {\n    return tabs.reduce((items, tab) => {\n      var _a;\n      if (!showActiveTab && tab.layoutId === activeTab) {\n        return items;\n      }\n      const menuItem = /* @__PURE__ */ react_default.createElement(\n        Menu_default.Item,\n        {\n          onClick: handleClickGenerator(tab.layoutId),\n          key: tab.layoutId,\n          description: tab.layoutId === activeTab ? (0, i18n_exports._)(\"Current tab\") : void 0\n        },\n        ((_a = tab.label) == null ? void 0 : _a.trim()) || (0, i18n_exports._)(`Unnamed tab`)\n      );\n      if (tab.layoutId === activeTab) {\n        items.unshift(\n          menuItem,\n          /* @__PURE__ */ react_default.createElement(Menu_default.Divider, { key: \"active-tab-divider\" })\n        );\n      } else {\n        items.push(menuItem);\n      }\n      return items;\n    }, []);\n  }, [tabs, showActiveTab, activeTab, handleClickGenerator]);\n  if (tabs.length <= 0 || tabs.length === 1 && !showActiveTab) {\n    return null;\n  }\n  return /* @__PURE__ */ react_default.createElement(\n    Popover_default,\n    {\n      open,\n      anchor,\n      onRequestClose,\n      onBlur,\n      defaultPlacement: \"right\",\n      appearance: \"normal\",\n      takeFocus: true\n    },\n    /* @__PURE__ */ react_default.createElement(Menu_default, { style: menuStyle, \"data-test\": \"tab-list-menu\" }, !!heading && /* @__PURE__ */ react_default.createElement(Menu_default.Heading, { title: true, outerStyle: headingStyle }, heading), !!heading && /* @__PURE__ */ react_default.createElement(Menu_default.Divider, null), menuItems)\n  );\n};\nvar useTabListMenu = () => {\n  const [open, setOpen] = (0, react_exports.useState)(false);\n  const [anchor, setAnchor] = (0, react_exports.useState)(null);\n  const handleOpen = (0, react_exports.useCallback)(() => {\n    setOpen(true);\n  }, []);\n  const handleRequestClose = (0, react_exports.useCallback)(() => {\n    setOpen(false);\n    anchor == null ? void 0 : anchor.focus();\n  }, [anchor]);\n  return {\n    handleOpen,\n    handleRequestClose,\n    setRef: setAnchor,\n    open,\n    anchor\n  };\n};\n//# sourceMappingURL=index.js.map\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nconst rules_1 = require(\"../rules\");\nconst applicability_1 = require(\"./applicability\");\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n    DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType || (exports.DataType = DataType = {}));\nfunction getSchemaTypes(schema) {\n    const types = getJSONTypes(schema.type);\n    const hasNull = types.includes(\"null\");\n    if (hasNull) {\n        if (schema.nullable === false)\n            throw new Error(\"type: null contradicts nullable: false\");\n    }\n    else {\n        if (!types.length && schema.nullable !== undefined) {\n            throw new Error('\"nullable\" cannot be used without \"type\"');\n        }\n        if (schema.nullable === true)\n            types.push(\"null\");\n    }\n    return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nfunction getJSONTypes(ts) {\n    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n    if (types.every(rules_1.isJSONType))\n        return types;\n    throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n    const { gen, data, opts } = it;\n    const coerceTo = coerceToTypes(types, opts.coerceTypes);\n    const checkTypes = types.length > 0 &&\n        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n    if (checkTypes) {\n        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n        gen.if(wrongType, () => {\n            if (coerceTo.length)\n                coerceData(it, types, coerceTo);\n            else\n                reportTypeError(it);\n        });\n    }\n    return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction coerceToTypes(types, coerceTypes) {\n    return coerceTypes\n        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n        : [];\n}\nfunction coerceData(it, types, coerceTo) {\n    const { gen, data, opts } = it;\n    const dataType = gen.let(\"dataType\", (0, codegen_1._) `typeof ${data}`);\n    const coerced = gen.let(\"coerced\", (0, codegen_1._) `undefined`);\n    if (opts.coerceTypes === \"array\") {\n        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen\n            .assign(data, (0, codegen_1._) `${data}[0]`)\n            .assign(dataType, (0, codegen_1._) `typeof ${data}`)\n            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n    }\n    gen.if((0, codegen_1._) `${coerced} !== undefined`);\n    for (const t of coerceTo) {\n        if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n            coerceSpecificType(t);\n        }\n    }\n    gen.else();\n    reportTypeError(it);\n    gen.endIf();\n    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {\n        gen.assign(data, coerced);\n        assignParentData(it, coerced);\n    });\n    function coerceSpecificType(t) {\n        switch (t) {\n            case \"string\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n                    .assign(coerced, (0, codegen_1._) `\"\" + ${data}`)\n                    .elseIf((0, codegen_1._) `${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `\"\"`);\n                return;\n            case \"number\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"integer\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"boolean\":\n                gen\n                    .elseIf((0, codegen_1._) `${data} === \"false\" || ${data} === 0 || ${data} === null`)\n                    .assign(coerced, false)\n                    .elseIf((0, codegen_1._) `${data} === \"true\" || ${data} === 1`)\n                    .assign(coerced, true);\n                return;\n            case \"null\":\n                gen.elseIf((0, codegen_1._) `${data} === \"\" || ${data} === 0 || ${data} === false`);\n                gen.assign(coerced, null);\n                return;\n            case \"array\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `[${data}]`);\n        }\n    }\n}\nfunction assignParentData({ gen, parentData, parentDataProperty }, expr) {\n    // TODO use gen.property\n    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));\n}\nfunction checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n    let cond;\n    switch (dataType) {\n        case \"null\":\n            return (0, codegen_1._) `${data} ${EQ} null`;\n        case \"array\":\n            cond = (0, codegen_1._) `Array.isArray(${data})`;\n            break;\n        case \"object\":\n            cond = (0, codegen_1._) `${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n            break;\n        case \"integer\":\n            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);\n            break;\n        case \"number\":\n            cond = numCond();\n            break;\n        default:\n            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;\n    }\n    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n    function numCond(_cond = codegen_1.nil) {\n        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);\n    }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n    if (dataTypes.length === 1) {\n        return checkDataType(dataTypes[0], data, strictNums, correct);\n    }\n    let cond;\n    const types = (0, util_1.toHash)(dataTypes);\n    if (types.array && types.object) {\n        const notObj = (0, codegen_1._) `typeof ${data} != \"object\"`;\n        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;\n        delete types.null;\n        delete types.array;\n        delete types.object;\n    }\n    else {\n        cond = codegen_1.nil;\n    }\n    if (types.number)\n        delete types.integer;\n    for (const t in types)\n        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n    return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n    message: ({ schema }) => `must be ${schema}`,\n    params: ({ schema, schemaValue }) => typeof schema == \"string\" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,\n};\nfunction reportTypeError(it) {\n    const cxt = getTypeErrorContext(it);\n    (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n    const { gen, data, schema } = it;\n    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n    return {\n        gen,\n        keyword: \"type\",\n        data,\n        schema: schema.type,\n        schemaCode,\n        schemaValue: schemaCode,\n        parentSchema: schema,\n        params: {},\n        it,\n    };\n}\n//# sourceMappingURL=dataType.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nexports.error = {\n    message: ({ params: { property, depsCount, deps } }) => {\n        const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;\n    },\n    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n};\nconst def = {\n    keyword: \"dependencies\",\n    type: \"object\",\n    schemaType: \"object\",\n    error: exports.error,\n    code(cxt) {\n        const [propDeps, schDeps] = splitDependencies(cxt);\n        validatePropertyDeps(cxt, propDeps);\n        validateSchemaDeps(cxt, schDeps);\n    },\n};\nfunction splitDependencies({ schema }) {\n    const propertyDeps = {};\n    const schemaDeps = {};\n    for (const key in schema) {\n        if (key === \"__proto__\")\n            continue;\n        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n        deps[key] = schema[key];\n    }\n    return [propertyDeps, schemaDeps];\n}\nfunction validatePropertyDeps(cxt, propertyDeps = cxt.schema) {\n    const { gen, data, it } = cxt;\n    if (Object.keys(propertyDeps).length === 0)\n        return;\n    const missing = gen.let(\"missing\");\n    for (const prop in propertyDeps) {\n        const deps = propertyDeps[prop];\n        if (deps.length === 0)\n            continue;\n        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n        cxt.setParams({\n            property: prop,\n            depsCount: deps.length,\n            deps: deps.join(\", \"),\n        });\n        if (it.allErrors) {\n            gen.if(hasProperty, () => {\n                for (const depProp of deps) {\n                    (0, code_1.checkReportMissingProp)(cxt, depProp);\n                }\n            });\n        }\n        else {\n            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);\n            (0, code_1.reportMissingProp)(cxt, missing);\n            gen.else();\n        }\n    }\n}\nexports.validatePropertyDeps = validatePropertyDeps;\nfunction validateSchemaDeps(cxt, schemaDeps = cxt.schema) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    for (const prop in schemaDeps) {\n        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))\n            continue;\n        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {\n            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);\n            cxt.mergeValidEvaluated(schCxt, valid);\n        }, () => gen.var(valid, true) // TODO var\n        );\n        cxt.ok(valid);\n    }\n}\nexports.validateSchemaDeps = validateSchemaDeps;\nexports.default = def;\n//# sourceMappingURL=dependencies.js.map"],"names":[],"sourceRoot":""}